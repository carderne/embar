{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Embar","text":"<p>A Python ORM with types</p> <p>Embar is a new ORM for Python with the following goals: - Type safety: your type checker should know what arguments are valid, and what is being returned from any call. - Type hints: your LSP should be able to guide you towards the query you want to write. - SQL-esque: you should be able to write queries simply by knowing SQL and your data model. - You should be able to actually just write SQL when you need to.</p> <p>These are mostly inspired by Drizzle. The Python ecosystem deserves something with similar DX.</p> <p>Embar supports three database clients:</p> <ul> <li>SQLite 3 via the Python standard library</li> <li>Postgres via psycopg3</li> <li>Postgres via async psycopg3</li> </ul> <p>The async psycopg3 client is recommended. The others are provided mostly for testing and experimenting locally.</p> <p>Embar uses Template strings and so only supports Python 3.14.</p> <p>Embar is pre-alpha and ready for experimentation but not production use.</p> <p>Documentation: embar.rdrn.me</p>"},{"location":"#roadmap","title":"Roadmap","text":"<ul> <li>Improve the story around updates. Requires codegen.</li> <li>Create a drizzle-style <code>db.query.users.findMany({ where: ... })</code> alternative syntax. Requires codegen.</li> <li>Create a migration diffing engine.</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>The usual process to make a contribution is to:</p> <ol> <li>Check for existing related issues</li> <li>Fork the repository and create a new branch</li> <li>Make your changes</li> <li>Make sure formatting, linting and tests passes.</li> <li>Add tests if possible to cover the lines you added.</li> <li>Commit, and send a Pull Request.</li> </ol>"},{"location":"contributing/#fork-the-repository","title":"Fork the repository","text":"<p>So that you have your own copy.</p>"},{"location":"contributing/#clone-the-repository","title":"Clone the repository","text":"<pre><code># replace 'carderne' with your own username if you made a fork\ngit clone git@github.com:carderne/embar.git\ncd embar\ngit checkout -b add-my-contribution\n</code></pre>"},{"location":"contributing/#setup-uv","title":"Setup uv","text":"<p>Install it if needed (full instructions here): <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre></p> <p>Then sync your local environment: <pre><code>uv sync\n</code></pre></p>"},{"location":"contributing/#run-all-code-quality-checks","title":"Run all code quality checks","text":"<p>This project uses poethepoet for tasks/scripts.</p> <p>You'll need Docker installed to run tests.</p> <p>Format, lint, type-check, test: <pre><code>uv run poe fmt\n           lint\n           check\n           test\n\n# or\nuv run poe all\n</code></pre></p> <p>Or do this: <pre><code># Run this or put it in .zshrc/.bashrc/etc\nalias poe=\"uv run poe\"\n\n# Then you can just:\npoe test\n</code></pre></p>"},{"location":"contributing/#open-a-pr","title":"Open a PR","text":"<p>Push your changes to your branch on your fork, then open a PR against the main repository.</p>"},{"location":"migrations/","title":"Migrations","text":"<p>Properly diffing migrations is not supported yet, but it's in the pipeline.</p> <p>In the meantime, you have two options:</p>"},{"location":"migrations/#embar-cli-work-in-progress","title":"Embar CLI (work in progress)","text":"<p>This uses which uses an LLM (and your <code>ANTHROPIC_API_KEY</code>) to generate vibe-diffs. You should inspect these before running them.</p> <p>You can see a working example at example/.</p> <p>First create a config file <code>embar.toml</code> in your app root:</p> <pre><code>dialect = \"postgresql\"\ndb_url = \"postgresql://pg:pw@localhost:3601/db\"\nschema_path = \"app.schema\"\nmigrations_dir = \"migrations\"  # optional\n</code></pre>"},{"location":"migrations/#simple-ddl-output","title":"Simple DDL output","text":"<p>If you just want to output the current schema as SQL (DDL), run: <pre><code>embar schema\n</code></pre></p>"},{"location":"migrations/#migration-files","title":"Migration files","text":"<p>Then to generate migrations, run the following and follow the prompts:</p> <pre><code>embar migrate\n</code></pre>"},{"location":"migrations/#push-changes","title":"Push changes","text":"<p>Or to push directly to your db, run the following. You will be prompted before each change.</p> <pre><code>embar push\n</code></pre>"},{"location":"migrations/#or-use-an-external-schema-management-tool","title":"Or use an external schema management tool","text":"<p>Use the <code>migrate()</code> method shown in the quickstart to dump the current DDL to a <code>.sql</code> file.</p> <p>Then use a schema management tool to manage updates. Some options are:</p> <ul> <li>Atlas</li> <li>sqldef</li> <li>sqitch</li> </ul>"},{"location":"postgres-quickstart/","title":"Postgres Quickstart","text":""},{"location":"postgres-quickstart/#install","title":"Install","text":"<pre><code>uv add embar\n</code></pre>"},{"location":"postgres-quickstart/#set-up-database-models","title":"Set up database models","text":"<p>These are exactly the same regardless of which database client is used.</p> <pre><code># schema.py\nfrom embar.column.common import Integer, Text\nfrom embar.config import EmbarConfig\nfrom embar.table import Table\n\nclass User(Table):\n    # If you don't provide a table name, it is generated from your class name\n    embar_config: EmbarConfig = EmbarConfig(table_name=\"users\")\n\n    id: Integer = Integer(primary=True)\n    # Columns will also generate their own name if not provided\n    email: Text = Text(\"user_email\", default=\"text\", not_null=True)\n\n\nclass Message(Table):\n    id: Integer = Integer()\n    # Foreign key constraints are easy to add\n    user_id: Integer = Integer().fk(lambda: User.id)\n    content: Text = Text()\n</code></pre>"},{"location":"postgres-quickstart/#create-client-and-apply-migrations","title":"Create client and apply migrations","text":"<p>In production, you would (probably) use the <code>embar</code> CLI to generate and run migrations. This example uses the utility function to do it all in code.</p> <pre><code># db.py\nimport asyncio\n\nimport psycopg\n\nfrom embar.db.pg import AsyncPgDb\n\nasync def setup_db():\n    # Replace with an env var pointing at your postgres\n    database_url = \"postgres://pg:pw@localhost:25432/db\"\n    conn = await psycopg.AsyncConnection.connect(database_url)\n    db = AsyncPgDb(conn)\n\n    # You can also use db.migrates() and pass an entire imported module\n    await db.migrate([User, Message])\n    return db\n</code></pre>"},{"location":"postgres-quickstart/#use-the-db-client-in-your-app","title":"Use the db client in your app","text":"<p>This whole section has been merged into a single code block to make the async-await easier on the eyes.</p> <pre><code># app.py\nfrom datetime import datetime\nfrom typing import Annotated, TypedDict\n\nfrom pydantic import BaseModel\n\nfrom embar.constraint import Index\nfrom embar.query.where import Eq, Like, Or\nfrom embar.sql import Sql\n\nasync def app():\n    db = await setup_db()\n    user = User(id=1, email=\"foo@bar.com\")\n    message = Message(id=1, user_id=user.id, content=\"Hello!\")\n\n    # Unlike with the sync example, we don't have to call run() everywhere.\n    # We can await any full constructed query and get the result\n    await db.insert(User).values(user)\n    await db.insert(Message).values(message)\n\n    # Query some data\n    # With join, where and group by.\n    class UserSel(BaseModel):\n        id: Annotated[int, User.id]\n        messages: Annotated[list[str], Message.content.many()]\n\n    users = await (\n        db.select(UserSel)\n        .from_(User)\n        .left_join(Message, Eq(User.id, Message.user_id))\n        .where(Or(Eq(User.id, 1), Like(User.email, \"foo%\")))\n        .group_by(User.id)\n    )\n    print(users)\n    # [ UserSel(id=1, messages=['Hello!']) ]\n\n    # Query some more data\n    # This time with fully nested child tables, and some raw SQL.\n    class UserHydrated(BaseModel):\n        email: Annotated[str, User.email]\n        messages: Annotated[list[Message], Message.many()]\n        date: Annotated[datetime, Sql(t\"CURRENT_TIMESTAMP\")]\n\n    users = await (\n        db.select(UserHydrated)\n        .from_(User)\n        .left_join(Message, Eq(User.id, Message.user_id))\n        .group_by(User.id)\n        .limit(2)\n    )\n    print(users)\n    # [UserHydrated(\n    #      email='foo@bar.com',\n    #      messages=[Message(content='Hello!', id=1, user_id=1)],\n    #      date: datetime(2025, 10, 26, ...)\n    # )]\n\n    # See the SQL\n    # Every query produces exactly one... query.\n    # And you can always see what's happening under the hood with the `.sql()`\n    # method:\n    users_query = (\n        db.select(UserHydrated)\n        .from_(User)\n        .left_join(Message, Eq(User.id, Message.user_id))\n        .group_by(User.id)\n        .sql()\n    )\n    print(users_query.sql)\n    # SELECT\n    #     \"users\".\"user_email\" AS \"email\",\n    #     json_group_array(json_object(\n    #         'id', \"message\".\"id\",\n    #         'user_id', \"message\".\"user_id\",\n    #         'content', \"message\".\"content\"\n    #     )) AS \"messages\",\n    #     CURRENT_TIMESTAMP AS \"date\"\n    # FROM \"users\"\n    # LEFT JOIN \"message\" ON \"users\".\"id\" = \"message\".\"user_id\"\n    # GROUP BY \"users\".\"id\"\n\n    # Update a row\n    # Unfortunately this requires another model to be defined,\n    # as Python doesn't have a `Partial[]` type.\n    class MessageUpdate(TypedDict, total=False):\n        id: int\n        user_id: int\n        content: str\n\n    await (\n        db.update(Message)\n        .set(MessageUpdate(content=\"Goodbye\"))\n        .where(Eq(Message.id, 1))\n    )\n\n    # Add indexes\n    class MessageIndexed(Table):  # pyright:ignore[reportUnusedClass]\n        embar_config: EmbarConfig = EmbarConfig(\n            constraints=[Index(\"message_idx\").on(lambda: Message.user_id)]\n        )\n        user_id: Integer = Integer().fk(lambda: User.id)\n\n    # Run raw SQL\n    await db.sql(t\"DELETE FROM {Message}\")\n\n    # Or with a return:\n    class UserId(BaseModel):\n        id: Annotated[int, int]\n\n    res = await db.sql(t\"SELECT * FROM {User}\").model(UserId)\n    print(res)\n    # [UserId(id=1)]\n\n\nasyncio.run(app())\n</code></pre>"},{"location":"quickstart/","title":"Quickstart","text":"<p>The quickstart uses the non-async sqlite client to make an easy example.</p> <p>If you want to see a fully worked Postgres example, check out the Postgres Quickstart.</p>"},{"location":"quickstart/#install","title":"Install","text":"<pre><code>uv add embar\n</code></pre>"},{"location":"quickstart/#set-up-database-models","title":"Set up database models","text":"<pre><code># schema.py\nfrom embar.column.common import Integer, Text\nfrom embar.config import EmbarConfig\nfrom embar.table import Table\n\nclass User(Table):\n    # If you don't provide a table name, it is generated from your class name\n    embar_config: EmbarConfig = EmbarConfig(table_name=\"users\")\n\n    id: Integer = Integer(primary=True)\n    # Columns will also generate their own name if not provided\n    email: Text = Text(\"user_email\", default=\"text\", not_null=True)\n\nclass Message(Table):\n    id: Integer = Integer()\n    # Foreign key constraints are easy to add\n    user_id: Integer = Integer().fk(lambda: User.id)\n    content: Text = Text()\n</code></pre>"},{"location":"quickstart/#create-client-and-apply-migrations","title":"Create client and apply migrations","text":"<p>In production, you would (probably) use the <code>embar</code> CLI to generate and run migrations. This example uses the utility function to do it all in code.</p> <pre><code># main.py\nimport sqlite3\nfrom embar.db.sqlite import SqliteDb\n\nconn = sqlite3.connect(\":memory:\")\ndb = SqliteDb(conn)\ndb.migrate([User, Message]).run()\n</code></pre>"},{"location":"quickstart/#insert-some-data","title":"Insert some data","text":"<pre><code>user = User(id=1, email=\"foo@bar.com\")\nmessage = Message(id=1, user_id=user.id, content=\"Hello!\")\n\ndb.insert(User).values(user).run()\n\n# you can return your inserted data if you want\nmsg_inserted = db.insert(Message).values(message).returning().run()\nassert msg_inserted[0].content == message.content\n</code></pre>"},{"location":"quickstart/#query-some-data","title":"Query some data","text":"<p>With join, where and group by.</p> <pre><code>from typing import Annotated\nfrom pydantic import BaseModel\nfrom embar.query.where import Eq, Like, Or\n\nclass UserSel(BaseModel):\n    id: Annotated[int, User.id]\n    messages: Annotated[list[str], Message.content.many()]\n\nusers = (\n    db.select(UserSel)\n    .from_(User)\n    .left_join(Message, Eq(User.id, Message.user_id))\n    .where(Or(\n        Eq(User.id, 1),\n        Like(User.email, \"foo%\")\n    ))\n    .group_by(User.id)\n    .run()\n)\n# [ UserSel(id=1, messages=['Hello!']) ]\n</code></pre>"},{"location":"quickstart/#query-some-more-data","title":"Query some more data","text":"<p>This time with fully nested child tables, and some raw SQL.</p> <pre><code>from datetime import datetime\nfrom embar.sql import Sql\n\nclass UserHydrated(BaseModel):\n    email: Annotated[str, User.email]\n    messages: Annotated[list[Message], Message.many()]\n    date: Annotated[datetime, Sql(t\"CURRENT_TIMESTAMP\")]\n\nusers = (\n    db.select(UserHydrated)\n    .from_(User)\n    .left_join(Message, Eq(User.id, Message.user_id))\n    .group_by(User.id)\n    .limit(2)\n    .run()\n)\n# [UserHydrated(\n#      email='foo@bar.com',\n#      messages=[Message(content='Hello!', id=1, user_id=1)],\n#      date: datetime(2025, 10, 26, ...)\n# )]\n</code></pre>"},{"location":"quickstart/#see-the-sql","title":"See the SQL","text":"<p>Every query produces exactly one... query. And you can always see what's happening under the hood with the <code>.sql()</code> method:</p> <pre><code>users_query = (\n    db.select(UserHydrated)\n    .from_(User)\n    .left_join(Message, Eq(User.id, Message.user_id))\n    .group_by(User.id)\n    .sql()\n)\nusers_query.sql\n# SELECT \n#     \"users\".\"user_email\" AS \"email\",\n#     json_group_array(json_object(\n#         'id', \"message\".\"id\",\n#         'user_id', \"message\".\"user_id\",\n#         'content', \"message\".\"content\"\n#     )) AS \"messages\",\n#     CURRENT_TIMESTAMP AS \"date\"\n# FROM \"users\"\n# LEFT JOIN \"message\" ON \"users\".\"id\" = \"message\".\"user_id\"\n# GROUP BY \"users\".\"id\"\n</code></pre>"},{"location":"quickstart/#update-a-row","title":"Update a row","text":"<p>Unfortunately this requires another model to be defined, as Python doesn't have a <code>Partial[]</code> type.</p> <pre><code>from typing import TypedDict\n\nclass MessageUpdate(TypedDict, total=False):\n    id: int\n    user_id: int\n    content: str\n\n(\n    db.update(Message)\n    .set(MessageUpdate(content=\"Goodbye\"))\n    .where(Eq(Message.id, 1))\n    .run()\n)\n</code></pre>"},{"location":"quickstart/#delete-some-rows","title":"Delete some rows","text":"<p>And return the deleted data if you like.</p> <pre><code>deleted = db.delete(Message).returning().run()\nassert len(deleted) == 1\n</code></pre>"},{"location":"quickstart/#add-indexes","title":"Add indexes","text":"<pre><code>from embar.constraint import Index\n\nclass MessageIndexed(Table):\n    embar_config: EmbarConfig = EmbarConfig(\n        constraints=[Index(\"message_idx\").on(lambda: MessageIndexed.user_id)]\n    )\n    user_id: Integer = Integer().fk(lambda: User.id)\n</code></pre>"},{"location":"quickstart/#run-raw-sql","title":"Run raw SQL","text":"<pre><code>db.sql(t\"DELETE FROM {Message}\").run()\n</code></pre> <p>Or with a return:</p> <pre><code>class UserId(BaseModel):\n    id: Annotated[int, int]\n\nres = (\n    db.sql(t\"SELECT * FROM {User}\")\n    .model(UserId)\n    .run()\n)\n# [UserId(id=1)]\n</code></pre>"},{"location":"types/","title":"Types and tests","text":"<p>Embar is designed from the ground up for type safety and useful type hints.</p> <p>Right now, the best way to take advantage of this is to install basedpyright. It's a fork of pyright that adds some extra features.</p> <pre><code>uv add --dev basedpyright\n</code></pre> <p>Then you should add something like this your <code>pyproject.toml</code>:</p> <pre><code>[tool.pyright]\nvenvPath = \".\"\nvenv = \".venv\"\npythonVersion = \"3.14\"\nstrict = [\"**/*.py\"]\n</code></pre> <p>Once that is added, you can run <code>uv run pyright</code> in the root and it should work correctly.</p>"},{"location":"extensions/vector/","title":"Vector","text":"<p>Embar supports pgvector, the open-source vector similarity search extension for PostgreSQL.</p> <p>Before using vector columns, you must install and activate the extension:</p> <pre><code>CREATE EXTENSION vector;\n</code></pre>"},{"location":"extensions/vector/#creating-a-vector-column","title":"Creating a Vector Column","text":"<p>Use <code>Vector</code> to store embeddings with a fixed dimension:</p> <pre><code>import asyncio\nimport psycopg\n\nfrom embar.column.common import Integer\nfrom embar.column.pg import Vector\nfrom embar.db.pg import AsyncPgDb\nfrom embar.table import Table\n\nclass Document(Table):\n    id: Integer = Integer()\n    embedding: Vector = Vector(3)  # 3-dimensional vector\n\nasync def get_db():\n    database_url = \"postgres://pg:pw@localhost:25432/db\"\n    conn = await psycopg.AsyncConnection.connect(database_url)\n    await conn.execute(\"CREATE EXTENSION IF NOT EXISTS vector\")\n    db = AsyncPgDb(conn)\n    await db.migrate([Document])\n    return db\n\nasync def setup():\n    db = await get_db()\n    # Insert some documents with embeddings\n    await db.insert(Document).values(Document(id=1, embedding=[1.0, 0.0, 0.0]))\n    await db.insert(Document).values(Document(id=2, embedding=[0.0, 1.0, 0.0]))\n    await db.insert(Document).values(Document(id=3, embedding=[0.0, 0.0, 1.0]))\n\nasyncio.run(setup())\n</code></pre>"},{"location":"extensions/vector/#l2-distance","title":"L2 Distance","text":"<p>Use <code>L2Distance</code> for Euclidean distance searches. This uses the <code>&lt;-&gt;</code> operator.</p>"},{"location":"extensions/vector/#order-by-l2-distance","title":"Order By L2 Distance","text":"<p>Find documents ordered by distance to a query vector:</p> <pre><code>from embar.query.vector import L2Distance\n\nasync def order_by_l2():\n    db = await get_db()\n    query_vector = [1.0, 0.5, 0.0]\n    docs = await (\n        db.select(Document.all())\n        .from_(Document)\n        .order_by(L2Distance(Document.embedding, query_vector))\n    )\n    print([d.id for d in docs])\n\nasyncio.run(order_by_l2())\n</code></pre>"},{"location":"extensions/vector/#filter-by-l2-distance","title":"Filter By L2 Distance","text":"<p>Find documents within a distance threshold:</p> <pre><code>from embar.query.where import Lt\n\nasync def filter_by_l2():\n    db = await get_db()\n    query_vector = [1.0, 0.0, 0.0]\n    docs = await (\n        db.select(Document.all())\n        .from_(Document)\n        .where(Lt(L2Distance(Document.embedding, query_vector), 0.5))\n    )\n    print([d.id for d in docs])\n\nasyncio.run(filter_by_l2())\n</code></pre>"},{"location":"extensions/vector/#cosine-distance","title":"Cosine Distance","text":"<p>Use <code>CosineDistance</code> for cosine similarity searches. This uses the <code>&lt;=&gt;</code> operator.</p>"},{"location":"extensions/vector/#order-by-cosine-distance","title":"Order By Cosine Distance","text":"<pre><code>from embar.query.vector import CosineDistance\n\nasync def order_by_cosine():\n    db = await get_db()\n    query_vector = [1.0, 0.5, 0.0]\n    docs = await (\n        db.select(Document.all())\n        .from_(Document)\n        .order_by(CosineDistance(Document.embedding, query_vector))\n    )\n    print([d.id for d in docs])\n\nasyncio.run(order_by_cosine())\n</code></pre>"},{"location":"integration/connection-pool/","title":"Connection Pooling","text":"<p>Connection pooling allows you to reuse database connections across multiple operations, reducing the overhead of establishing new connections. This is particularly useful in web applications where many concurrent requests need database access.</p>"},{"location":"integration/connection-pool/#usage","title":"Usage","text":"<p>Pass a <code>ConnectionPool</code> (or <code>AsyncConnectionPool</code>) to <code>PgDb</code> instead of a raw connection:</p> <pre><code>from psycopg_pool import ConnectionPool\nfrom pydantic import BaseModel\nfrom typing import Annotated\n\nfrom embar.column.common import Integer, Text\nfrom embar.config import EmbarConfig\nfrom embar.db.pg import PgDb\nfrom embar.table import Table\n\n\nclass User(Table):\n    embar_config: EmbarConfig = EmbarConfig(table_name=\"users\")\n    id: Integer = Integer(primary=True)\n    name: Text = Text()\n\n\n# Create a connection pool\npool = ConnectionPool(\"postgres://pg:pw@localhost:25432/db\", open=True)\n\n# Pass the pool to PgDb\ndb = PgDb(pool)\n\n# Run migrations\ndb.migrate([User]).run()\n\n# Insert a user\ndb.insert(User).values(User(id=1, name=\"Alice\")).run()\n\n# Query it back\nclass UserRead(BaseModel):\n    id: Annotated[int, User.id]\n    name: Annotated[str, User.name]\n\nusers = db.select(UserRead).from_(User).run()\nprint(users)\n# [UserRead(id=1, name='Alice')]\n\n# Clean up\npool.close()\n</code></pre>"},{"location":"integration/connection-pool/#unopened-pools","title":"Unopened Pools","text":"<p>If you create a pool with <code>open=False</code>, it will be automatically opened on first use:</p> <p>```python notest pool = ConnectionPool(\"postgres://...\", open=False) db = PgDb(pool)</p>"},{"location":"integration/connection-pool/#pool-is-opened-automatically-when-the-first-query-runs","title":"Pool is opened automatically when the first query runs","text":"<p>```</p>"},{"location":"query/delete/","title":"Delete","text":"<p>Delete operations remove rows from your database. Embar provides a straightforward interface for deleting data with optional result retrieval.</p>"},{"location":"query/delete/#basic-delete","title":"Basic Delete","text":"<p>To delete rows, use <code>.delete()</code> with a <code>.where()</code> clause to specify which rows to remove:</p> <pre><code>import asyncio\nimport psycopg\n\nfrom embar.column.common import Integer, Text\nfrom embar.db.pg import AsyncPgDb\nfrom embar.query.where import Eq\nfrom embar.table import Table\n\nclass Message(Table):\n    id: Integer = Integer(primary=True)\n    user_id: Integer = Integer()\n    content: Text = Text()\n\nasync def get_db():\n    database_url = \"postgres://pg:pw@localhost:25432/db\"\n    conn = await psycopg.AsyncConnection.connect(database_url)\n    db = AsyncPgDb(conn)\n    await db.migrate([Message])\n    return db\n\nasync def basic():\n    db = await get_db()\n    await db.delete(Message).where(Eq(Message.id, 1))\n\nasyncio.run(basic())\n</code></pre> <p>This generates:</p> <pre><code>DELETE FROM \"message\"\nWHERE \"message\".\"id\" = %(p0)s\n</code></pre> <p>With parameters: <code>{'p0': 1}</code></p>"},{"location":"query/delete/#returning-deleted-data","title":"Returning Deleted Data","text":"<p>Use <code>.returning()</code> to get back the deleted rows. This is useful when you need to know what was removed or to perform cleanup actions:</p> <pre><code>async def returning():\n    db = await get_db()\n    message = Message(id=1, user_id=2, content=\"foo\")\n    await db.insert(Message).values(message)\n    deleted = await db.delete(Message).where(Eq(Message.id, 1)).returning()\n\n    # deleted is a list of Message instances\n    assert deleted[0].id == message.id\n    assert deleted[0].content == message.content\n\nasyncio.run(returning())\n</code></pre> <p>This generates:</p> <pre><code>DELETE FROM \"message\"\nWHERE \"message\".\"id\" = %(p0)s\nRETURNING *\n</code></pre> <p>The <code>RETURNING *</code> clause tells the database to return all columns of the deleted rows.</p>"},{"location":"query/delete/#where-clauses","title":"Where Clauses","text":"<p>The <code>.where()</code> method specifies which rows to delete. You can use simple conditions or combine multiple criteria:</p> <pre><code>from embar.query.where import Eq, Gt, And, Or\n\nasync def where():\n    db = await get_db()\n    # Delete a specific row\n    await db.delete(Message).where(Eq(Message.id, 1))\n\n    # Delete multiple rows matching a condition\n    await db.delete(Message).where(Gt(Message.id, 100))\n\n    # Delete with multiple conditions\n    await db.delete(Message).where(And(\n        Eq(Message.user_id, 5),\n        Gt(Message.id, 10)\n    ))\n\n    # Delete with OR logic\n    await db.delete(Message).where(Or(\n        Eq(Message.user_id, 5),\n        Eq(Message.user_id, 10)\n    ))\n\nasyncio.run(where())\n</code></pre> <p>For more on where clauses, see Where.</p>"},{"location":"query/delete/#deleting-without-where","title":"Deleting Without Where","text":"<p>!!! warning     Deleting without a where clause removes all rows from the table. Use with extreme caution.</p> <pre><code>async def no_where():\n    db = await get_db()\n\n    # This deletes every row in the table\n    await db.delete(Message)\n\nasyncio.run(no_where())\n</code></pre> <p>This generates:</p> <pre><code>DELETE FROM \"message\"\n</code></pre> <p>Always double-check before running delete operations without where clauses. Consider using <code>.returning()</code> to see what will be deleted:</p> <pre><code># See what would be deleted\nasync def verify():\n    db = await get_db()\n    query = db.delete(Message).sql()\n    print(query.sql)\n\n    # Or return the deleted data to verify\n    deleted = await db.delete(Message).where(Gt(Message.id, 100)).returning()\n    print(f\"Deleted {len(deleted)} rows\")\n\nasyncio.run(verify())\n</code></pre>"},{"location":"query/delete/#viewing-the-sql","title":"Viewing the SQL","text":"<p>Inspect the generated query without executing it:</p> <pre><code>async def view_sql():\n    db = await get_db()\n    query = db.delete(Message).where(Eq(Message.id, 1)).sql()\n\n    print(query.sql)\n    # DELETE FROM \"message\"\n    # WHERE \"message\".\"id\" = %(p0)s\n\n    print(query.params)\n    # {'p0': 1}\n\nasyncio.run(view_sql())\n</code></pre>"},{"location":"query/delete/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Where clauses for filtering</li> <li>See how to Update data</li> <li>Explore Insert operations</li> </ul>"},{"location":"query/insert/","title":"Insert","text":"<p>Insert operations in Embar are straightforward. You create a table row instance and insert it into the database.</p>"},{"location":"query/insert/#basic-insert","title":"Basic Insert","text":"<p>Insert a single row:</p> <pre><code>import asyncio\nimport psycopg\n\nfrom embar.db.pg import AsyncPgDb\nfrom embar.column.common import Integer, Text\nfrom embar.table import Table\n\nclass User(Table):\n    id: Integer = Integer()\n    email: Text = Text()\n\nasync def get_db(tables: list[Table] = None):\n    tables = tables if tables is not None else [User]\n    database_url = \"postgres://pg:pw@localhost:25432/db\"\n    conn = await psycopg.AsyncConnection.connect(database_url)\n    db = AsyncPgDb(conn)\n    await db.migrate(tables)\n    return db\n\nasync def basic():\n    db = await get_db()\n    user = User(id=1, email=\"alice@example.com\")\n    await db.insert(User).values(user)\n\nasyncio.run(basic())\n</code></pre> <p>This generates:</p> <pre><code>INSERT INTO \"user\" (\"id\", \"email\") VALUES (%(id)s, %(email)s)\n</code></pre> <p>With parameters: <code>{'id': 1, 'email': 'alice@example.com'}</code></p>"},{"location":"query/insert/#inserting-multiple-rows","title":"Inserting Multiple Rows","text":"<p>Pass multiple row instances to <code>.values()</code>:</p> <pre><code>async def multiple():\n    users = [\n        User(id=10, email=\"alice@example.com\"),\n        User(id=11, email=\"bob@example.com\"),\n        User(id=12, email=\"charlie@example.com\"),\n    ]\n    db = await get_db()\n    await db.insert(User).values(*users)\n\nasyncio.run(multiple())\n</code></pre> <p>This generates a single insert statement with multiple parameter sets:</p> <pre><code>INSERT INTO \"user\" (\"id\", \"email\") VALUES (%(id)s, %(email)s)\n</code></pre> <p>With parameters: <pre><code>[\n    {'id': 10, 'email': 'alice@example.com'},\n    {'id': 11, 'email': 'bob@example.com'},\n    {'id': 12, 'email': 'charlie@example.com'},\n]\n</code></pre></p>"},{"location":"query/insert/#returning-inserted-data","title":"Returning Inserted Data","text":"<p>Use <code>.returning()</code> to get back the inserted rows. This is useful for retrieving auto-generated IDs or default values:</p> <pre><code>async def returning():\n    db = await get_db()\n    user = User(id=20, email=\"alice@example.com\")\n    inserted = await db.insert(User).values(user).returning()\n\n    # inserted is a list of User instances\n    assert inserted[0].id == 20\n    assert inserted[0].email == \"alice@example.com\"\n\nasyncio.run(returning())\n</code></pre> <p>This generates:</p> <pre><code>INSERT INTO \"user\" (\"id\", \"email\") VALUES (%(id)s, %(email)s) RETURNING *\n</code></pre> <p>The <code>RETURNING *</code> clause tells the database to return all columns of the inserted row.</p>"},{"location":"query/insert/#working-with-defaults","title":"Working with Defaults","text":"<p>Columns with default values can be omitted when creating instances:</p> <pre><code>class UserStatus(Table):\n    id: Integer = Integer()\n    email: Text = Text(not_null=True)\n    status: Text = Text(default=\"active\")\n\nuser = UserStatus(id=30, email=\"alice@example.com\")\n# status will be set to \"active\" by the database\n\nasync def defaults():\n    db = await get_db([UserStatus])\n    inserted = await db.insert(UserStatus).values(user).returning()\n    assert inserted[0].status == \"active\"\n\nasyncio.run(defaults())\n</code></pre>"},{"location":"query/insert/#viewing-the-sql","title":"Viewing the SQL","text":"<p>Use <code>.sql()</code> to inspect the generated query without executing it:</p> <pre><code>async def view_sql():\n    user = User(id=1, email=\"alice@example.com\")\n    query = db.insert(User).values(user).sql()\n\n    print(query.sql)\n    # INSERT INTO \"user\" (\"id\", \"email\") VALUES (%(id)s, %(email)s)\n\n    print(query.many_params)\n    # [{'id': 1, 'email': 'alice@example.com'}]\n</code></pre>"},{"location":"query/insert/#inserting-with-foreign-keys","title":"Inserting with Foreign Keys","text":"<p>When inserting rows with foreign key relationships, insert the parent row first:</p> <pre><code>class UserSimple(Table):\n    id: Integer = Integer(primary=True)\n\nclass Message(Table):\n    id: Integer = Integer(primary=True)\n    user_id: Integer = Integer().fk(lambda: UserSimple.id)\n    content: Text = Text()\n\nasync def relations():\n    db = await get_db([Message,UserSimple])\n    user = UserSimple(id=40)\n    await db.insert(UserSimple).values(user)\n\n    message = Message(id=1, user_id=user.id, content=\"Hello!\")\n    await db.insert(Message).values(message)\n\nasyncio.run(relations())\n</code></pre>"},{"location":"query/insert/#on-conflict-upsert","title":"On Conflict (Upsert)","text":"<p>Handle duplicate key conflicts with <code>on_conflict_do_nothing()</code> or <code>on_conflict_do_update()</code>.</p>"},{"location":"query/insert/#do-nothing","title":"Do Nothing","text":"<p>Ignore rows that would cause a unique constraint violation:</p> <pre><code>import asyncio\nimport psycopg\n\nfrom embar.db.pg import AsyncPgDb\nfrom embar.column.common import Integer, Text\nfrom embar.table import Table\n\nclass Product(Table):\n    id: Integer = Integer(primary=True)\n    name: Text = Text()\n\nasync def get_db(tables: list[Table] = None):\n    tables = tables if tables is not None else [Product]\n    database_url = \"postgres://pg:pw@localhost:25432/db\"\n    conn = await psycopg.AsyncConnection.connect(database_url)\n    db = AsyncPgDb(conn)\n    await db.migrate(tables)\n    return db\n\nasync def do_nothing():\n    db = await get_db([Product])\n\n    # Insert initial product (using on_conflict for idempotency)\n    await db.insert(Product).values(Product(id=100, name=\"Widget\")).on_conflict_do_nothing((\"id\",))\n\n    # Attempt to insert duplicate - will be ignored\n    await db.insert(Product).values(\n        Product(id=100, name=\"Gadget\")\n    ).on_conflict_do_nothing((\"id\",))\n\nasyncio.run(do_nothing())\n</code></pre> <p>This generates:</p> <pre><code>INSERT INTO \"product\" (\"id\", \"name\") VALUES (%(id)s, %(name)s)\nON CONFLICT (id) DO NOTHING\n</code></pre>"},{"location":"query/insert/#do-update","title":"Do Update","text":"<p>Update existing rows when a conflict occurs:</p> <pre><code>async def do_update():\n    db = await get_db([Product])\n\n    # Insert initial product (using on_conflict for idempotency)\n    await db.insert(Product).values(Product(id=101, name=\"Widget\")).on_conflict_do_nothing((\"id\",))\n\n    # Upsert - update name if id already exists\n    await db.insert(Product).values(\n        Product(id=101, name=\"Gadget\")\n    ).on_conflict_do_update((\"id\",), {\"name\": \"Updated Widget\"})\n\nasyncio.run(do_update())\n</code></pre> <p>This generates:</p> <pre><code>INSERT INTO \"product\" (\"id\", \"name\") VALUES (%(id)s, %(name)s)\nON CONFLICT (id) DO UPDATE SET name = %(set_name_0)s\n</code></pre>"},{"location":"query/insert/#with-returning","title":"With Returning","text":"<p>Combine with <code>.returning()</code> to get the result:</p> <pre><code>async def upsert_returning():\n    db = await get_db([Product])\n\n    # Insert initial product (using on_conflict for idempotency)\n    await db.insert(Product).values(Product(id=102, name=\"Widget\")).on_conflict_do_nothing((\"id\",))\n\n    result = await db.insert(Product).values(\n        Product(id=102, name=\"Gadget\")\n    ).on_conflict_do_update((\"id\",), {\"name\": \"Updated\"}).returning()\n\n    assert result[0].id == 102\n\nasyncio.run(upsert_returning())\n</code></pre>"},{"location":"query/joins/","title":"Joins","text":"<p>Joins combine data from multiple tables in a single query. Embar supports all standard SQL join types with full type safety.</p>"},{"location":"query/joins/#basic-join","title":"Basic Join","text":"<p>Use <code>.left_join()</code> to include all rows from the left table and matching rows from the right table:</p> <pre><code>import asyncio\nimport psycopg\nfrom typing import Annotated\nfrom pydantic import BaseModel\n\nfrom embar.column.common import Integer, Text\nfrom embar.db.pg import AsyncPgDb\nfrom embar.query.where import Eq\nfrom embar.table import Table\n\nclass User(Table):\n    id: Integer = Integer(primary=True)\n    email: Text = Text()\n\nclass Message(Table):\n    id: Integer = Integer(primary=True)\n    user_id: Integer = Integer().fk(lambda: User.id)\n    content: Text = Text()\n\nclass UserWithEmail(BaseModel):\n    id: Annotated[int, User.id]\n    email: Annotated[str, User.email]\n\nasync def get_db(tables: list[Table] = None):\n    if tables is None:\n        tables = [User, Message]\n    database_url = \"postgres://pg:pw@localhost:25432/db\"\n    conn = await psycopg.AsyncConnection.connect(database_url)\n    db = AsyncPgDb(conn)\n    await db.migrate(tables)\n    return db\n\nasync def basic():\n    db = await get_db()\n    users = await (\n        db.select(UserWithEmail)\n        .from_(User)\n        .left_join(Message, Eq(User.id, Message.user_id))\n    )\n\nasyncio.run(basic())\n</code></pre> <p>This generates:</p> <pre><code>SELECT \"user\".\"id\" AS \"id\", \"user\".\"email\" AS \"email\"\nFROM \"user\"\nLEFT JOIN \"message\" ON \"user\".\"id\" = \"message\".\"user_id\"\n</code></pre> <p>The join condition uses <code>Eq</code> to match the user's ID with the message's user_id foreign key.</p>"},{"location":"query/joins/#join-types","title":"Join Types","text":""},{"location":"query/joins/#left-join","title":"Left Join","text":"<p>Returns all rows from the left table and matched rows from the right table. If there's no match, right table columns are null.</p> <pre><code>async def left_join():\n    db = await get_db()\n    users = await (\n        db.select(User.all())\n        .from_(User)\n        .left_join(Message, Eq(User.id, Message.user_id))\n    )\n\nasyncio.run(left_join())\n</code></pre> <p>This generates:</p> <pre><code>SELECT \"user\".\"id\", \"user\".\"email\"\nFROM \"user\"\nLEFT JOIN \"message\" ON \"user\".\"id\" = \"message\".\"user_id\"\n</code></pre>"},{"location":"query/joins/#inner-join","title":"Inner Join","text":"<p>Returns only rows where there is a match in both tables:</p> <pre><code>async def inner_join():\n    db = await get_db()\n    users = await (\n        db.select(User.all())\n        .from_(User)\n        .inner_join(Message, Eq(User.id, Message.user_id))\n    )\n\nasyncio.run(inner_join())\n</code></pre> <p>This generates:</p> <pre><code>SELECT \"user\".\"id\", \"user\".\"email\"\nFROM \"user\"\nINNER JOIN \"message\" ON \"user\".\"id\" = \"message\".\"user_id\"\n</code></pre>"},{"location":"query/joins/#right-join","title":"Right Join","text":"<p>Returns all rows from the right table and matched rows from the left table:</p> <pre><code>async def right_join():\n    db = await get_db()\n    users = await (\n        db.select(User.all())\n        .from_(User)\n        .right_join(Message, Eq(User.id, Message.user_id))\n    )\n\nasyncio.run(right_join())\n</code></pre> <p>This generates:</p> <pre><code>SELECT \"user\".\"id\", \"user\".\"email\"\nFROM \"user\"\nRIGHT JOIN \"message\" ON \"user\".\"id\" = \"message\".\"user_id\"\n</code></pre>"},{"location":"query/joins/#full-join","title":"Full Join","text":"<p>Returns all rows from both tables, matching where possible:</p> <pre><code>async def full_join():\n    db = await get_db()\n    users = await (\n        db.select(User.all())\n        .from_(User)\n        .full_join(Message, Eq(User.id, Message.user_id))\n    )\n\nasyncio.run(full_join())\n</code></pre> <p>This generates:</p> <pre><code>SELECT \"user\".\"id\", \"user\".\"email\"\nFROM \"user\"\nFULL OUTER JOIN \"message\" ON \"user\".\"id\" = \"message\".\"user_id\"\n</code></pre>"},{"location":"query/joins/#cross-join","title":"Cross Join","text":"<p>Returns the Cartesian product of both tables. No join condition is needed:</p> <pre><code>async def cross_join():\n    db = await get_db()\n    users = await (\n        db.select(User.all())\n        .from_(User)\n        .cross_join(Message)\n    )\n\nasyncio.run(cross_join())\n</code></pre> <p>This generates:</p> <pre><code>SELECT \"user\".\"id\", \"user\".\"email\"\nFROM \"user\"\nCROSS JOIN \"message\"\n</code></pre>"},{"location":"query/joins/#join-conditions","title":"Join Conditions","text":"<p>Join conditions use the same operators as where clauses. The most common is <code>Eq</code>, but you can use any comparison operator.</p>"},{"location":"query/joins/#basic-equality","title":"Basic Equality","text":"<pre><code>from embar.query.where import Eq\n\nasync def equality():\n    db = await get_db()\n    await (\n        db.select(User.all())\n        .from_(User)\n        .left_join(Message, Eq(User.id, Message.user_id))\n    )\n\nasyncio.run(equality())\n</code></pre>"},{"location":"query/joins/#other-operators","title":"Other Operators","text":"<p>Use any where clause operator for join conditions:</p> <pre><code>from embar.query.where import Gt, Lt, And\n\nasync def operators():\n    db = await get_db()\n    # Greater than\n    await (\n        db.select(User.all())\n        .from_(User)\n        .left_join(Message, Gt(User.id, Message.user_id))\n    )\n\n    # Multiple conditions\n    await (\n        db.select(User.all())\n        .from_(User)\n        .left_join(Message, And(\n            Eq(User.id, Message.user_id),\n            Gt(Message.id, 100)\n        ))\n    )\n\nasyncio.run(operators())\n</code></pre> <p>See Where for all available operators.</p>"},{"location":"query/joins/#selecting-nested-data","title":"Selecting Nested Data","text":"<p>Use <code>.many()</code> to aggregate joined rows into arrays. This requires <code>.group_by()</code> to group results by the parent table.</p>"},{"location":"query/joins/#array-of-values","title":"Array of Values","text":"<p>Select an array of values from the joined table:</p> <pre><code>class UserWithMessages(BaseModel):\n    id: Annotated[int, User.id]\n    messages: Annotated[list[str], Message.content.many()]\n\nasync def arrays():\n    db = await get_db()\n    users = await (\n        db.select(UserWithMessages)\n        .from_(User)\n        .left_join(Message, Eq(User.id, Message.user_id))\n        .group_by(User.id)\n    )\n    # [UserWithMessages(id=1, messages=[\"Hello!\", \"How are you?\"])]\n\nasyncio.run(arrays())\n</code></pre> <p>This generates:</p> <pre><code>SELECT\n    \"user\".\"id\" AS \"id\",\n    json_agg(\"message\".\"content\") AS \"messages\"\nFROM \"user\"\nLEFT JOIN \"message\" ON \"user\".\"id\" = \"message\".\"user_id\"\nGROUP BY \"user\".\"id\"\n</code></pre>"},{"location":"query/joins/#array-of-objects","title":"Array of Objects","text":"<p>Select full nested objects from the joined table:</p> <pre><code>class UserWithFullMessages(BaseModel):\n    id: Annotated[int, User.id]\n    email: Annotated[str, User.email]\n    messages: Annotated[list[Message], Message.many()]\n\nasync def objects():\n    db = await get_db()\n    users = await (\n        db.select(UserWithFullMessages)\n        .from_(User)\n        .left_join(Message, Eq(User.id, Message.user_id))\n        .group_by(User.id)\n    )\n    # [UserWithFullMessages(\n    #     id=1,\n    #     email=\"alice@example.com\",\n    #     messages=[\n    #         Message(id=1, user_id=1, content=\"Hello!\"),\n    #         Message(id=2, user_id=1, content=\"How are you?\")\n    #     ]\n    # )]\n\nasyncio.run(objects())\n</code></pre> <p>This generates:</p> <pre><code>SELECT\n    \"user\".\"id\" AS \"id\",\n    \"user\".\"email\" AS \"email\",\n    json_agg(json_build_object(\n        'id', \"message\".\"id\",\n        'user_id', \"message\".\"user_id\",\n        'content', \"message\".\"content\"\n    )) AS \"messages\"\nFROM \"user\"\nLEFT JOIN \"message\" ON \"user\".\"id\" = \"message\".\"user_id\"\nGROUP BY \"user\".\"id\"\n</code></pre> <p>The <code>.many()</code> suffix tells Embar to aggregate the joined rows into a JSON array. Without <code>.group_by()</code>, you'll get separate rows for each message.</p>"},{"location":"query/joins/#multiple-joins","title":"Multiple Joins","text":"<p>Chain multiple join calls to join more than two tables:</p> <pre><code>class Comment(Table):\n    id: Integer = Integer(primary=True)\n    message_id: Integer = Integer().fk(lambda: Message.id)\n    text: Text = Text()\n\nclass UserWithData(BaseModel):\n    id: Annotated[int, User.id]\n    email: Annotated[str, User.email]\n    messages: Annotated[list[str], Message.content.many()]\n    comments: Annotated[list[str], Comment.text.many()]\n\nasync def multiple():\n    db = await get_db([User, Message, Comment])\n    users = await (\n        db.select(UserWithData)\n        .from_(User)\n        .left_join(Message, Eq(User.id, Message.user_id))\n        .left_join(Comment, Eq(Message.id, Comment.message_id))\n        .group_by(User.id)\n    )\n\nasyncio.run(multiple())\n</code></pre> <p>This generates:</p> <pre><code>SELECT\n    \"user\".\"id\" AS \"id\",\n    \"user\".\"email\" AS \"email\",\n    json_agg(\"message\".\"content\") AS \"messages\",\n    json_agg(\"comment\".\"text\") AS \"comments\"\nFROM \"user\"\nLEFT JOIN \"message\" ON \"user\".\"id\" = \"message\".\"user_id\"\nLEFT JOIN \"comment\" ON \"message\".\"id\" = \"comment\".\"message_id\"\nGROUP BY \"user\".\"id\"\n</code></pre>"},{"location":"query/joins/#joins-with-where-clauses","title":"Joins with Where Clauses","text":"<p>Combine joins with where clauses to filter results:</p> <pre><code>from embar.query.where import Like\n\nclass UserFiltered(BaseModel):\n    id: Annotated[int, User.id]\n    messages: Annotated[list[str], Message.content.many()]\n\nasync def join_where():\n    db = await get_db()\n    users = await (\n        db.select(UserFiltered)\n        .from_(User)\n        .left_join(Message, Eq(User.id, Message.user_id))\n        .where(Like(User.email, \"%@example.com\"))\n        .group_by(User.id)\n    )\n\nasyncio.run(join_where())\n</code></pre> <p>This generates:</p> <pre><code>SELECT\n    \"user\".\"id\" AS \"id\",\n    json_agg(\"message\".\"content\") AS \"messages\"\nFROM \"user\"\nLEFT JOIN \"message\" ON \"user\".\"id\" = \"message\".\"user_id\"\nWHERE \"user\".\"email\" LIKE %(p0)s\nGROUP BY \"user\".\"id\"\n</code></pre> <p>The where clause filters the joined results before aggregation.</p>"},{"location":"query/joins/#single-nested-object","title":"Single Nested Object","text":"<p>Use <code>.one()</code> to select a single nested object instead of an array:</p> <pre><code>class MessageWithUser(BaseModel):\n    content: Annotated[str, Message.content]\n    user: Annotated[User, User.one()]\n\nasync def nested():\n    db = await get_db()\n    messages = await (\n        db.select(MessageWithUser)\n        .from_(Message)\n        .left_join(User, Eq(User.id, Message.user_id))\n    )\n    # [MessageWithUser(\n    #     content=\"Hello!\",\n    #     user=User(id=1, email=\"alice@example.com\")\n    # )]\n\nasyncio.run(nested())\n</code></pre> <p>This generates:</p> <pre><code>SELECT\n    \"message\".\"content\" AS \"content\",\n    json_build_object(\n        'id', \"user\".\"id\",\n        'email', \"user\".\"email\"\n    ) AS \"user\"\nFROM \"message\"\nLEFT JOIN \"user\" ON \"user\".\"id\" = \"message\".\"user_id\"\n</code></pre> <p>Use <code>.one()</code> when the relationship is many-to-one (each message has one user). Use <code>.many()</code> when the relationship is one-to-many (each user has many messages).</p>"},{"location":"query/joins/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Where clauses for join conditions and filtering</li> <li>See Select for more query building options</li> <li>Understand Relations for defining table relationships</li> </ul>"},{"location":"query/raw-sql/","title":"Raw SQL","text":"<p>Sometimes you need to write raw SQL. Embar provides template strings for safe SQL interpolation while maintaining type safety.</p>"},{"location":"query/raw-sql/#template-strings","title":"Template Strings","text":"<p>Use Python's template strings with the <code>t</code> prefix to write raw SQL:</p> <pre><code>import asyncio\nimport psycopg\n\nfrom embar.column.common import Integer, Text\nfrom embar.db.pg import AsyncPgDb\nfrom embar.table import Table\n\nclass User(Table):\n    id: Integer = Integer(primary=True)\n    status: Text = Text()\n    email: Text = Text()\n\nasync def get_db(tables: list[Table] = None):\n    if tables is None:\n        tables = [User]\n    database_url = \"postgres://pg:pw@localhost:25432/db\"\n    conn = await psycopg.AsyncConnection.connect(database_url)\n    db = AsyncPgDb(conn)\n    await db.migrate(tables)\n    return db\n\nasync def example():\n    db = await get_db()\n    await db.sql(t\"DELETE FROM {User}\")\n\nasyncio.run(example())\n</code></pre> <p>This generates:</p> <pre><code>DELETE FROM \"user\"\n</code></pre> <p>The <code>{User}</code> interpolation is replaced with the properly quoted table name.</p> <p>Table names are automatically escaped and quoted according to your database dialect.</p>"},{"location":"query/raw-sql/#column-name-interpolation","title":"Column Name Interpolation","text":"<p>Reference columns directly in your raw SQL:</p> <pre><code>async def col():\n    db = await get_db()\n    await db.sql(t\"SELECT {User.email} FROM {User}\")\n\nasyncio.run(col())\n</code></pre> <p>This generates:</p> <pre><code>SELECT \"user\".\"email\" FROM \"user\"\n</code></pre> <p>Both the table and column are properly escaped and quoted.</p>"},{"location":"query/raw-sql/#queries-without-return-values","title":"Queries Without Return Values","text":"<p>Use <code>db.sql()</code> for queries that don't return data:</p> <pre><code>async def noreturn():\n    db = await get_db()\n    # Delete\n    await db.sql(t\"DELETE FROM {User} WHERE id &gt; 100\")\n\n    # Update\n    await db.sql(t\"UPDATE {User} SET {User.status} = 'inactive' WHERE {User.email} LIKE 'foo.com'\")\n\n    # Truncate\n    await db.sql(t\"TRUNCATE TABLE {User} CASCADE\")\n\nasyncio.run(noreturn())\n</code></pre>"},{"location":"query/raw-sql/#queries-that-return-data","title":"Queries That Return Data","text":"<p>Use <code>.model()</code> to specify a return type for queries that fetch data:</p> <pre><code>from typing import Annotated\nfrom pydantic import BaseModel\n\nclass UserId(BaseModel):\n    id: Annotated[int, int]\n\nasync def returning():\n    db = await get_db()\n\n    users = await db.sql(t\"SELECT id FROM {User} WHERE email LIKE '%@gmail.com'\").model(UserId)\n    # [UserId(id=1), UserId(id=2), UserId(id=3)]\n\nasyncio.run(returning())\n</code></pre> <p>This generates:</p> <pre><code>SELECT id FROM \"user\" WHERE email LIKE '%@gmail.com'\n</code></pre> <p>The returned data is parsed into the model you provide.</p>"},{"location":"query/raw-sql/#complex-return-types","title":"Complex Return Types","text":"<p>Models can have multiple fields:</p> <pre><code>class UserEmail(BaseModel):\n    id: Annotated[int, int]\n    email: Annotated[str, str]\n\nasync def complex():\n    db = await get_db()\n    users = await db.sql(t\"SELECT id, email FROM {User} ORDER BY id DESC LIMIT 10\").model(UserEmail)\n\nasyncio.run(complex())\n</code></pre> <p>Or even nested types:</p> <pre><code>from datetime import datetime\n\nclass MessageWithUser(BaseModel):\n    content: Annotated[str, str]\n    user_email: Annotated[str, str]\n    created_at: Annotated[datetime, datetime]\n\nclass Message(Table):\n    id: Integer = Integer(primary=True)\n    user_id: Integer = Integer().fk(lambda: User.id)\n    content: Text = Text()\n\nasync def nested():\n    db = await get_db([User, Message])\n    messages = await (\n        db.sql(t\"\"\"\n            SELECT m.content, u.email as user_email, CURRENT_TIMESTAMP as created_at\n            FROM {Message} m\n            JOIN {User} u ON m.user_id = u.id\n            WHERE m.content LIKE '%important%'\n        \"\"\")\n        .model(MessageWithUser)\n    )\n\nasyncio.run(nested())\n</code></pre>"},{"location":"query/raw-sql/#raw-sql-in-select-queries","title":"Raw SQL in Select Queries","text":"<p>Use the <code>Sql()</code> class to include raw SQL within select queries:</p> <pre><code>from embar.sql import Sql\nfrom embar.query.where import Eq\n\nclass UserWithCount(BaseModel):\n    id: Annotated[int, User.id]\n    email: Annotated[str, User.email]\n    message_count: Annotated[int, Sql(t\"COUNT({Message.id})\")]\n\nclass Message(Table):\n    id: Integer = Integer(primary=True)\n    user_id: Integer = Integer().fk(lambda: User.id)\n    content: Text = Text()\n\nasync def select():\n    db = await get_db([User, Message])\n    users = await (\n        db.select(UserWithCount)\n        .from_(User)\n        .left_join(Message, Eq(User.id, Message.user_id))\n        .group_by(User.id)\n    )\n\nasyncio.run(select())\n</code></pre> <p>This generates:</p> <pre><code>SELECT\n    \"user\".\"id\" AS \"id\",\n    \"user\".\"email\" AS \"email\",\n    COUNT(\"message\".\"id\") AS \"message_count\"\nFROM \"user\"\nLEFT JOIN \"message\" ON \"user\".\"id\" = \"message\".\"user_id\"\nGROUP BY \"user\".\"id\"\n</code></pre> <p>The raw SQL is inserted directly into the SELECT clause.</p>"},{"location":"query/raw-sql/#database-specific-functions","title":"Database-Specific Functions","text":"<p>Use raw SQL for database-specific functionality:</p> <pre><code>class UserWithTimestamp(BaseModel):\n    email: Annotated[str, User.email]\n    now: Annotated[datetime, Sql(t\"CURRENT_TIMESTAMP\")]\n\nasync def timestamp():\n    db = await get_db()\n    users = await db.select(UserWithTimestamp).from_(User)\n\nasyncio.run(timestamp())\n</code></pre> <p>Or for Postgres-specific features:</p> <pre><code># JSON operations\nclass UserWithJsonField(BaseModel):\n    email: Annotated[str, User.email]\n    metadata: Annotated[dict, Sql(t\"jsonb_build_object('status', 'active')\")]\n\n# Array aggregation\nclass UserWithTags(BaseModel):\n    email: Annotated[str, User.email]\n    tags: Annotated[list[str], Sql(t\"array_agg({Tag.name})\")]\n</code></pre>"},{"location":"query/raw-sql/#mixing-raw-sql-with-query-builders","title":"Mixing Raw SQL with Query Builders","text":"<p>Combine raw SQL with query builders for complex scenarios:</p> <pre><code>from embar.query.where import Gt\n\nclass UserStats(BaseModel):\n    id: Annotated[int, User.id]\n    email: Annotated[str, User.email]\n    score: Annotated[float, Sql(t\"RANDOM() * 100\")]\n\nasync def mix():\n    db = await get_db()\n    users = await (\n        db.select(UserStats)\n        .from_(User)\n        .where(Gt(User.id, 10))\n        .limit(5)\n    )\n\nasyncio.run(mix())\n</code></pre> <p>This lets you use raw SQL where needed while maintaining type safety and parameterization for the rest of the query.</p>"},{"location":"query/raw-sql/#viewing-the-sql","title":"Viewing the SQL","text":"<p>Inspect raw SQL queries before execution:</p> <pre><code>async def raw_sql():\n    db = await get_db()\n    query = db.sql(t\"DELETE FROM {User} WHERE id &gt; 100\").sql()\n\n    print(query)\n    # DELETE FROM \"user\" WHERE id &gt; 100\n\nasyncio.run(raw_sql())\n</code></pre> <p>For queries with models:</p> <pre><code>async def with_models():\n    db = await get_db()\n    query = (\n        db.sql(t\"SELECT id, email FROM {User} WHERE id &lt; 10\")\n        .model(UserEmail)\n        .sql()\n    )\n\n    print(query)\n    # SELECT id, email FROM \"user\" WHERE id &lt; 10\n\nasyncio.run(with_models())\n</code></pre>"},{"location":"query/raw-sql/#next-steps","title":"Next Steps","text":"<ul> <li>See how to build complex queries with Select</li> <li>Learn about parameterized filtering with Where</li> <li>Explore type-safe Joins</li> </ul>"},{"location":"query/select/","title":"Select","text":"<p>Select operations retrieve data from your database. Embar provides a fluent interface for building SELECT queries with full type safety.</p>"},{"location":"query/select/#basic-select","title":"Basic Select","text":"<p>Setup. <pre><code>import asyncio\nimport psycopg\n\nfrom embar.column.common import Integer, Text\nfrom embar.db.pg import AsyncPgDb\nfrom embar.table import Table\n\nclass User(Table):\n    id: Integer = Integer(primary=True)\n    email: Text = Text()\n\nasync def get_db(tables: list[Table] = None):\n    if tables is None:\n        tables = [User]\n    database_url = \"postgres://pg:pw@localhost:25432/db\"\n    conn = await psycopg.AsyncConnection.connect(database_url)\n    db = AsyncPgDb(conn)\n    await db.migrate(tables)\n    return db\n</code></pre></p> <p>Select all columns from a table using <code>.all()</code>:</p> <pre><code>async def basic():\n    db = await get_db()\n    users = await db.select(User.all()).from_(User)\n    # [User(id=1, email=\"alice@example.com\"), User(id=2, email=\"bob@example.com\")]\n\nasyncio.run(basic())\n</code></pre> <p>This generates:</p> <pre><code>SELECT \"user\".\"id\", \"user\".\"email\" FROM \"user\"\n</code></pre>"},{"location":"query/select/#selecting-specific-columns","title":"Selecting Specific Columns","text":"<p>Define a custom model to select only specific columns:</p> <pre><code>from typing import Annotated\nfrom pydantic import BaseModel\n\nclass UserEmail(BaseModel):\n    email: Annotated[str, User.email]\n\nasync def columns():\n    db = await get_db()\n    users = await db.select(UserEmail).from_(User)\n    # [UserEmail(email=\"alice@example.com\"), UserEmail(email=\"bob@example.com\")]\n\nasyncio.run(columns())\n</code></pre> <p>This generates:</p> <pre><code>SELECT \"user\".\"email\" AS \"email\" FROM \"user\"\n</code></pre> <p>The <code>Annotated</code> type tells Embar which table column maps to each field in your result model.</p>"},{"location":"query/select/#where-clauses","title":"Where Clauses","text":"<p>Filter results with <code>.where()</code>:</p> <pre><code>from embar.query.where import Eq\n\nasync def where():\n    db = await get_db()\n    users = await (\n        db.select(User.all())\n        .from_(User)\n        .where(Eq(User.id, 1))\n    )\n\nasyncio.run(where())\n</code></pre> <p>This generates:</p> <pre><code>SELECT \"user\".\"id\", \"user\".\"email\" FROM \"user\" WHERE \"user\".\"id\" = %(p0)s\n</code></pre> <p>Where clauses can be combined with <code>And</code>, <code>Or</code>, and other operators. See Where for details.</p>"},{"location":"query/select/#joins","title":"Joins","text":"<p>Join related tables using <code>.left_join()</code>, <code>.right_join()</code>, <code>.inner_join()</code>, <code>.full_join()</code>, or <code>.cross_join()</code>:</p> <pre><code>from embar.query.where import Eq\n\nclass Message(Table):\n    id: Integer = Integer(primary=True)\n    user_id: Integer = Integer().fk(lambda: User.id)\n    content: Text = Text()\n\nclass UserWithMessages(BaseModel):\n    id: Annotated[int, User.id]\n    email: Annotated[str, User.email]\n\nasync def joins():\n    db = await get_db([User, Message])\n    users = await (\n        db.select(UserWithMessages)\n        .from_(User)\n        .left_join(Message, Eq(User.id, Message.user_id))\n    )\n\nasyncio.run(joins())\n</code></pre> <p>This generates:</p> <pre><code>SELECT \"user\".\"id\" AS \"id\", \"user\".\"email\" AS \"email\"\nFROM \"user\"\nLEFT JOIN \"message\" ON \"user\".\"id\" = \"message\".\"user_id\"\n</code></pre> <p>For more on joins and nested data, see Joins.</p>"},{"location":"query/select/#selecting-nested-arrays","title":"Selecting Nested Arrays","text":"<p>Use <code>.many()</code> to select arrays of values or full nested objects:</p> <pre><code>class UserWithMessages(BaseModel):\n    id: Annotated[int, User.id]\n    messages: Annotated[list[str], Message.content.many()]\n\nasync def arrays():\n    db = await get_db([User, Message])\n    users = await (\n        db.select(UserWithMessages)\n        .from_(User)\n        .left_join(Message, Eq(User.id, Message.user_id))\n        .group_by(User.id)\n    )\n    # [UserWithMessages(id=1, messages=[\"Hello!\", \"How are you?\"])]\n\nasyncio.run(arrays())\n</code></pre> <p>Or select full nested objects:</p> <pre><code>class UserWithFullMessages(BaseModel):\n    id: Annotated[int, User.id]\n    messages: Annotated[list[Message], Message.many()]\n\nasync def nested():\n    db = await get_db([User, Message])\n    users = await (\n        db.select(UserWithFullMessages)\n        .from_(User)\n        .left_join(Message, Eq(User.id, Message.user_id))\n        .group_by(User.id)\n    )\n    # [UserWithFullMessages(\n    #     id=1,\n    #     messages=[\n    #         Message(id=1, user_id=1, content=\"Hello!\"),\n    #         Message(id=2, user_id=1, content=\"How are you?\")\n    #     ]\n    # )]\n\nasyncio.run(nested())\n</code></pre>"},{"location":"query/select/#distinct","title":"Distinct","text":"<p>Select distinct rows using <code>select_distinct()</code>:</p> <pre><code>async def distinct():\n    db = await get_db()\n    users = await db.select_distinct(User.all()).from_(User)\n\nasyncio.run(distinct())\n</code></pre> <p>This generates:</p> <pre><code>SELECT DISTINCT \"user\".\"id\", \"user\".\"email\" FROM \"user\"\n</code></pre>"},{"location":"query/select/#group-by","title":"Group By","text":"<p>Group results with <code>.group_by()</code>:</p> <pre><code>class UserMessageCount(BaseModel):\n    id: Annotated[int, User.id]\n    messages: Annotated[list[str], Message.content.many()]\n\nasync def group_by():\n    db = await get_db([User, Message])\n    users = await (\n        db.select(UserMessageCount)\n        .from_(User)\n        .left_join(Message, Eq(User.id, Message.user_id))\n        .group_by(User.id)\n    )\n\nasyncio.run(group_by())\n</code></pre> <p>This generates:</p> <pre><code>SELECT \"user\".\"id\" AS \"id\", json_agg(\"message\".\"content\") AS \"messages\"\nFROM \"user\"\nLEFT JOIN \"message\" ON \"user\".\"id\" = \"message\".\"user_id\"\nGROUP BY \"user\".\"id\"\n</code></pre>"},{"location":"query/select/#having","title":"Having","text":"<p>Filter grouped results with <code>.having()</code>:</p> <pre><code>from embar.query.where import Gt\nfrom embar.sql import Sql\n\nclass UserWithCount(BaseModel):\n    id: Annotated[int, User.id]\n    message_count: Annotated[int, Sql(t\"COUNT({Message.id})\")]\n\nasync def having():\n    db = await get_db([User, Message])\n    users = await (\n        db.select(UserWithCount)\n        .from_(User)\n        .left_join(Message, Eq(User.id, Message.user_id))\n        .group_by(User.id)\n        .having(Gt(User.id, 2))\n    )\n\nasyncio.run(having())\n</code></pre> <p>This generates:</p> <pre><code>SELECT \"user\".\"id\" AS \"id\", COUNT(\"message\".\"id\") AS \"message_count\"\nFROM \"user\"\nLEFT JOIN \"message\" ON \"user\".\"id\" = \"message\".\"user_id\"\nGROUP BY \"user\".\"id\"\nHAVING COUNT(\"message\".\"id\") &gt; %(p0)s\n</code></pre> <p>The <code>HAVING</code> clause filters groups after aggregation, while <code>WHERE</code> filters rows before grouping.</p>"},{"location":"query/select/#order-by","title":"Order By","text":"<p>Sort results with <code>.order_by()</code>:</p> <pre><code>from embar.query.order_by import Asc, Desc\n\nasync def order_by():\n    db = await get_db()\n    users = await (\n        db.select(User.all())\n        .from_(User)\n        .order_by(Desc(User.id))\n    )\n\nasyncio.run(order_by())\n</code></pre> <p>This generates:</p> <pre><code>SELECT \"user\".\"id\", \"user\".\"email\" FROM \"user\" ORDER BY \"user\".\"id\" DESC\n</code></pre> <p>You can order by multiple columns:</p> <pre><code>async def order_multi():\n    db = await get_db()\n    users = await (\n        db.select(User.all())\n        .from_(User)\n        .order_by(Asc(User.email), Desc(User.id))\n    )\n\nasyncio.run(order_multi())\n</code></pre> <p>Control null ordering:</p> <pre><code>async def nulls():\n    db = await get_db()\n    users = await (\n        db.select(User.all())\n        .from_(User)\n        .order_by(Asc(User.email, nulls=\"last\"))\n    )\n\nasyncio.run(nulls())\n</code></pre> <p>This generates:</p> <pre><code>SELECT \"user\".\"id\", \"user\".\"email\" FROM \"user\" ORDER BY \"user\".\"email\" ASC NULLS LAST\n</code></pre>"},{"location":"query/select/#limit-and-offset","title":"Limit and Offset","text":"<p>Paginate results with <code>.limit()</code> and <code>.offset()</code>:</p> <pre><code>async def limit():\n    db = await get_db()\n    users = await (\n        db.select(User.all())\n        .from_(User)\n        .limit(10)\n        .offset(20)\n    )\n\nasyncio.run(limit())\n</code></pre> <p>This generates:</p> <pre><code>SELECT \"user\".\"id\", \"user\".\"email\" FROM \"user\" LIMIT 10 OFFSET 20\n</code></pre>"},{"location":"query/select/#aggregations","title":"Aggregations","text":"<p>Use raw SQL for aggregations:</p> <pre><code>from embar.sql import Sql\n\nclass UserStats(BaseModel):\n    total: Annotated[int, Sql(t\"COUNT(*)::int\")]\n    avg_id: Annotated[float | None, Sql(t\"AVG({User.id})::float\")]\n\nasync def aggregation():\n    db = await get_db()\n    stats = await db.select(UserStats).from_(User)\n    # [UserStats(total=100, avg_id=50.5)]\n\nasyncio.run(aggregation())\n</code></pre> <p>Common aggregations include <code>COUNT()</code>, <code>SUM()</code>, <code>AVG()</code>, <code>MIN()</code>, and <code>MAX()</code>.</p>"},{"location":"query/select/#viewing-the-sql","title":"Viewing the SQL","text":"<p>Inspect the generated query without executing it:</p> <pre><code>async def raw_sql():\n    db = await get_db()\n    query = (\n        db.select(User.all())\n        .from_(User)\n        .where(Eq(User.id, 1))\n        .sql()\n    )\n\n    print(query.sql)\n    # SELECT \"user\".\"id\", \"user\".\"email\" FROM \"user\" WHERE \"user\".\"id\" = %(p0)s\n\n    print(query.params)\n    # {'p0': 1}\n\nasyncio.run(raw_sql())\n</code></pre>"},{"location":"query/select/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Where clauses for filtering</li> <li>Explore Joins for working with related tables</li> <li>See how to Insert data</li> </ul>"},{"location":"query/transactions/","title":"Transactions","text":"<p>Transactions allow you to group multiple database operations into a single atomic unit. Either all operations succeed and are committed, or any failure causes all changes to be rolled back.</p>"},{"location":"query/transactions/#basic-usage","title":"Basic Usage","text":"<p>Use <code>db.transaction()</code> as a context manager to start a transaction:</p> <pre><code>import asyncio\nimport psycopg\n\nfrom embar.column.common import Integer, Text\nfrom embar.db.pg import AsyncPgDb\nfrom embar.table import Table\n\nclass Account(Table):\n    id: Integer = Integer()\n    name: Text = Text()\n\nclass Transfer(Table):\n    id: Integer = Integer()\n    from_account: Integer = Integer()\n    to_account: Integer = Integer()\n    amount: Integer = Integer()\n\nasync def get_db():\n    database_url = \"postgres://pg:pw@localhost:25432/db\"\n    conn = await psycopg.AsyncConnection.connect(database_url)\n    db = AsyncPgDb(conn)\n    await db.migrate([Account, Transfer])\n    return db\n\nasync def basic():\n    db = await get_db()\n\n    async with db.transaction() as tx:\n        account = Account(id=1, name=\"alice\")\n        await tx.insert(Account).values(account)\n\n    # Changes are committed when the context manager exits successfully\n    accounts = await db.select(Account.all()).from_(Account)\n    assert any(a.id == 1 for a in accounts)\n\nasyncio.run(basic())\n</code></pre> <p>Inside the transaction block, use <code>tx</code> (the transaction database object) for all operations. When the block exits normally, changes are committed automatically.</p>"},{"location":"query/transactions/#automatic-rollback-on-errors","title":"Automatic Rollback on Errors","text":"<p>If an exception occurs inside the transaction block, all changes are automatically rolled back:</p> <pre><code>async def rollback_on_error():\n    db = await get_db()\n\n    try:\n        async with db.transaction() as tx:\n            account = Account(id=100, name=\"bob\")\n            await tx.insert(Account).values(account)\n\n            # This raises an exception\n            raise ValueError(\"Something went wrong\")\n    except ValueError:\n        pass\n\n    # The insert was rolled back\n    accounts = await db.select(Account.all()).from_(Account)\n    assert not any(a.id == 100 for a in accounts)\n\nasyncio.run(rollback_on_error())\n</code></pre>"},{"location":"query/transactions/#multiple-operations","title":"Multiple Operations","text":"<p>Transactions are useful when you need multiple related operations to succeed or fail together:</p> <pre><code>async def transfer_funds():\n    db = await get_db()\n\n    async with db.transaction() as tx:\n        # Create accounts and record transfer atomically\n        await tx.insert(Account).values(Account(id=200, name=\"sender\"))\n        await tx.insert(Account).values(Account(id=201, name=\"receiver\"))\n\n        transfer = Transfer(id=1, from_account=200, to_account=201, amount=100)\n        await tx.insert(Transfer).values(transfer)\n\n    # All operations committed together\n    transfers = await db.select(Transfer.all()).from_(Transfer)\n    assert any(t.from_account == 200 for t in transfers)\n\nasyncio.run(transfer_funds())\n</code></pre>"},{"location":"query/transactions/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Raw SQL for custom queries</li> <li>See how to Insert data</li> <li>Explore Select queries</li> </ul>"},{"location":"query/update/","title":"Update","text":"<p>Update operations modify existing rows in your database. Embar provides a straightforward interface for updating data with full type safety.</p>"},{"location":"query/update/#basic-update","title":"Basic Update","text":"<p>To update rows, use <code>.update()</code> with <code>.set()</code> and typically <code>.where()</code> to specify which rows to modify:</p> <pre><code>import asyncio\nimport psycopg\n\nfrom typing import TypedDict\nfrom embar.column.common import Integer, Text\nfrom embar.db.pg import AsyncPgDb\nfrom embar.query.where import Eq\nfrom embar.table import Table\n\nclass Message(Table):\n    id: Integer = Integer()\n    user_id: Integer = Integer()\n    content: Text = Text()\n\nclass MessageUpdate(TypedDict, total=False):\n    id: int\n    user_id: int\n    content: str\n\nasync def get_db(tables: list[Table] = None):\n    if tables is None:\n        tables = [Message]\n    database_url = \"postgres://pg:pw@localhost:25432/db\"\n    conn = await psycopg.AsyncConnection.connect(database_url)\n    db = AsyncPgDb(conn)\n    await db.migrate(tables)\n    return db\n\nasync def basic():\n    db = await get_db()\n    await (\n        db.update(Message)\n        .set(MessageUpdate(content=\"Updated message\"))\n        .where(Eq(Message.id, 1))\n    )\n\nasyncio.run(basic())\n</code></pre> <p>This generates:</p> <pre><code>UPDATE \"message\" SET \"content\" = %(set_content_0)s\nWHERE \"message\".\"id\" = %(p0)s\n</code></pre> <p>With parameters: <code>{'set_content_0': 'Updated message', 'p0': 1}</code></p>"},{"location":"query/update/#partial-updates-with-typeddict","title":"Partial Updates with TypedDict","text":"<p>Python doesn't have a built-in <code>Partial</code> type, so Embar uses <code>TypedDict</code> with <code>total=False</code> to enable partial updates. This lets you update only specific fields:</p> <pre><code>class MessageUpdate(TypedDict, total=False):\n    id: int\n    user_id: int\n    content: str\n\nasync def partial():\n    db = await get_db()\n    # Update only the content field\n    await (\n        db.update(Message)\n        .set(MessageUpdate(content=\"New content\"))\n        .where(Eq(Message.id, 1))\n    )\n\n    # Update multiple fields\n    await (\n        db.update(Message)\n        .set(MessageUpdate(content=\"New content\", user_id=2))\n        .where(Eq(Message.id, 1))\n    )\n\nasyncio.run(partial())\n</code></pre> <p>The <code>total=False</code> parameter means all fields are optional, allowing you to specify only the fields you want to update.</p>"},{"location":"query/update/#returning-updated-data","title":"Returning Updated Data","text":"<p>Use <code>.returning()</code> to get back the updated rows. This is useful when you need to see the final state of the data:</p> <pre><code>async def returning():\n    db = await get_db()\n\n    message = Message(id=1, user_id=2, content=\"Hello\")\n    await db.insert(Message).values(message)\n\n    updated = await (\n        db.update(Message)\n        .set(MessageUpdate(content=\"Updated message\"))\n        .returning()\n    )\n\n    # updated is a list of Message instances\n    assert updated[0].content == \"Updated message\"\n\nasyncio.run(returning())\n</code></pre> <p>This generates:</p> <pre><code>UPDATE \"message\" SET \"content\" = %(set_content_0)s\nWHERE \"message\".\"id\" = %(p0)s\nRETURNING *\n</code></pre> <p>The <code>RETURNING *</code> clause tells the database to return all columns of the updated rows.</p>"},{"location":"query/update/#where-clauses","title":"Where Clauses","text":"<p>The <code>.where()</code> method limits which rows are updated. Without it, all rows in the table would be modified:</p> <pre><code>from embar.query.where import Eq, Gt, And\n\nasync def where():\n    db = await get_db()\n    # Update a specific row\n    await (\n        db.update(Message)\n        .set(MessageUpdate(content=\"Updated\"))\n        .where(Eq(Message.id, 1))\n    )\n\n    # Update multiple rows matching a condition\n    await (\n        db.update(Message)\n        .set(MessageUpdate(content=\"Archived\"))\n        .where(Gt(Message.id, 100))\n    )\n\n    # Update with multiple conditions\n    await (\n        db.update(Message)\n        .set(MessageUpdate(content=\"Updated by user 5\"))\n        .where(And(\n            Eq(Message.user_id, 5),\n            Gt(Message.id, 10)\n        ))\n    )\n\nasyncio.run(where())\n</code></pre> <p>For more on where clauses, see Where.</p>"},{"location":"query/update/#updating-multiple-fields","title":"Updating Multiple Fields","text":"<p>Update as many fields as needed by including them in your TypedDict:</p> <pre><code>async def multi():\n    db = await get_db()\n    await (\n        db.update(Message)\n        .set(MessageUpdate(\n            content=\"Updated message\",\n            user_id=5\n        ))\n        .where(Eq(Message.id, 1))\n    )\n\nasyncio.run(multi())\n</code></pre> <p>This generates:</p> <pre><code>UPDATE \"message\" SET \"content\" = %(set_content_0)s, \"user_id\" = %(set_user_id_1)s\nWHERE \"message\".\"id\" = %(p0)s\n</code></pre>"},{"location":"query/update/#viewing-the-sql","title":"Viewing the SQL","text":"<p>Inspect the generated query without executing it:</p> <pre><code>async def raw_sql():\n    db = await get_db()\n    query = (\n        db.update(Message)\n        .set(MessageUpdate(content=\"Updated\"))\n        .where(Eq(Message.id, 1))\n        .sql()\n    )\n\n    print(query.sql)\n    # UPDATE \"message\" SET \"content\" = %(set_content_0)s\n    # WHERE \"message\".\"id\" = %(p0)s\n\n    print(query.params)\n    # {'set_content_0': 'Updated', 'p0': 1}\n\nasyncio.run(raw_sql())\n</code></pre>"},{"location":"query/update/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Where clauses for filtering</li> <li>See how to Delete data</li> <li>Explore Select operations</li> </ul>"},{"location":"query/where/","title":"Where","text":"<p>Where clauses filter rows in your queries. Embar provides type-safe operators for comparisons, pattern matching, null checks, and logical combinations.</p>"},{"location":"query/where/#basic-comparison","title":"Basic Comparison","text":"<p>Use <code>Eq</code> to check equality:</p> <pre><code>import asyncio\nimport psycopg\n\nfrom embar.column.common import Integer, Text\nfrom embar.db.pg import AsyncPgDb\nfrom embar.query.where import Eq\nfrom embar.table import Table\n\nclass User(Table):\n    id: Integer = Integer(primary=True)\n    email: Text = Text()\n\nasync def get_db(tables: list[Table] = None):\n    if tables is None:\n        tables = [User]\n    database_url = \"postgres://pg:pw@localhost:25432/db\"\n    conn = await psycopg.AsyncConnection.connect(database_url)\n    db = AsyncPgDb(conn)\n    await db.migrate(tables)\n    return db\n\nasync def basic():\n    db = await get_db()\n    users = await db.select(User.all()).from_(User).where(Eq(User.id, 1))\n\nasyncio.run(basic())\n</code></pre> <p>This generates:</p> <pre><code>SELECT \"user\".\"id\", \"user\".\"email\" FROM \"user\" WHERE \"user\".\"id\" = %(eq_id_0)s\n</code></pre> <p>With parameters: <code>{'eq_id_0': 1}</code></p>"},{"location":"query/where/#comparison-operators","title":"Comparison Operators","text":""},{"location":"query/where/#equality","title":"Equality","text":"<p>Check if values are equal or not equal:</p> <pre><code>from embar.query.where import Eq, Ne\n\nasync def equality():\n    db = await get_db()\n    # Equal\n    await db.select(User.all()).from_(User).where(Eq(User.id, 1))\n\n    # Not equal\n    await db.select(User.all()).from_(User).where(Ne(User.id, 1))\n\nasyncio.run(equality())\n</code></pre>"},{"location":"query/where/#numeric-comparisons","title":"Numeric Comparisons","text":"<p>Compare numeric values:</p> <pre><code>from embar.query.where import Gt, Gte, Lt, Lte\n\nasync def numeric():\n    db = await get_db()\n    # Greater than\n    await db.select(User.all()).from_(User).where(Gt(User.id, 10))\n\n    # Greater than or equal\n    await db.select(User.all()).from_(User).where(Gte(User.id, 10))\n\n    # Less than\n    await db.select(User.all()).from_(User).where(Lt(User.id, 100))\n\n    # Less than or equal\n    await db.select(User.all()).from_(User).where(Lte(User.id, 100))\n\nasyncio.run(numeric())\n</code></pre> <p>This generates:</p> <pre><code>-- Greater than\nWHERE \"user\".\"id\" &gt; %(gt_id_0)s\n\n-- Greater than or equal\nWHERE \"user\".\"id\" &gt;= %(gte_id_0)s\n\n-- Less than\nWHERE \"user\".\"id\" &lt; %(lt_id_0)s\n\n-- Less than or equal\nWHERE \"user\".\"id\" &lt;= %(lte_id_0)s\n</code></pre>"},{"location":"query/where/#pattern-matching","title":"Pattern Matching","text":""},{"location":"query/where/#like","title":"Like","text":"<p>Use <code>Like</code> for case-sensitive pattern matching:</p> <pre><code>from embar.query.where import Like\n\nasync def like():\n    db = await get_db()\n    # Starts with \"alice\"\n    await db.select(User.all()).from_(User).where(Like(User.email, \"alice%\"))\n\n    # Ends with \"@example.com\"\n    await db.select(User.all()).from_(User).where(Like(User.email, \"%@example.com\"))\n\n    # Contains \"test\"\n    await db.select(User.all()).from_(User).where(Like(User.email, \"%test%\"))\n\nasyncio.run(like())\n</code></pre> <p>This generates:</p> <pre><code>WHERE \"user\".\"email\" LIKE %(like_email_0)s\n</code></pre>"},{"location":"query/where/#case-insensitive-like","title":"Case-Insensitive Like","text":"<p>Use <code>Ilike</code> for case-insensitive matching (Postgres only):</p> <pre><code>from embar.query.where import Ilike\n\nasync def insensitive():\n    db = await get_db()\n    await db.select(User.all()).from_(User).where(Ilike(User.email, \"ALICE%\"))\n\nasyncio.run(insensitive())\n</code></pre> <p>This generates:</p> <pre><code>WHERE \"user\".\"email\" ILIKE %(ilike_email_0)s\n</code></pre>"},{"location":"query/where/#not-like","title":"Not Like","text":"<p>Use <code>NotLike</code> to exclude patterns:</p> <pre><code>from embar.query.where import NotLike\n\nasync def notlike():\n    db = await get_db()\n    await db.select(User.all()).from_(User).where(NotLike(User.email, \"%spam%\"))\n\nasyncio.run(notlike())\n</code></pre> <p>This generates:</p> <pre><code>WHERE \"user\".\"email\" NOT LIKE %(notlike_email_0)s\n</code></pre>"},{"location":"query/where/#null-checks","title":"Null Checks","text":"<p>Check for null or non-null values:</p> <pre><code>from embar.query.where import IsNull, IsNotNull\n\nasync def null():\n    db = await get_db()\n    # Is null\n    await db.select(User.all()).from_(User).where(IsNull(User.email))\n\n    # Is not null\n    await db.select(User.all()).from_(User).where(IsNotNull(User.email))\n\nasyncio.run(null())\n</code></pre> <p>This generates:</p> <pre><code>-- Is null\nWHERE \"user\".\"email\" IS NULL\n\n-- Is not null\nWHERE \"user\".\"email\" IS NOT NULL\n</code></pre>"},{"location":"query/where/#array-operations","title":"Array Operations","text":""},{"location":"query/where/#in-array","title":"In Array","text":"<p>Check if a value is in a list:</p> <pre><code>from embar.query.where import InArray\n\nasync def array():\n    db = await get_db()\n    await db.select(User.all()).from_(User).where(InArray(User.id, [1, 2, 3]))\n\nasyncio.run(array())\n</code></pre> <p>This generates:</p> <pre><code>WHERE \"user\".\"id\" = ANY(%(in_id_0)s)\n</code></pre> <p>With parameters: <code>{'in_id_0': [1, 2, 3]}</code></p>"},{"location":"query/where/#not-in-array","title":"Not In Array","text":"<p>Check if a value is not in a list:</p> <pre><code>from embar.query.where import NotInArray\n\nasync def not_in_array():\n    db = await get_db()\n    await db.select(User.all()).from_(User).where(NotInArray(User.id, [5, 10, 15]))\n\nasyncio.run(not_in_array())\n</code></pre> <p>This generates:</p> <pre><code>WHERE \"user\".\"id\" != ALL(%(notin_id_0)s)\n</code></pre>"},{"location":"query/where/#range-operations","title":"Range Operations","text":""},{"location":"query/where/#between","title":"Between","text":"<p>Check if a value falls within a range (inclusive):</p> <pre><code>from embar.query.where import Between\n\nasync def between():\n    db = await get_db()\n    await db.select(User.all()).from_(User).where(Between(User.id, 10, 20))\n\nasyncio.run(between())\n</code></pre> <p>This generates:</p> <pre><code>WHERE \"user\".\"id\" BETWEEN %(between_lower_id_0)s AND %(between_upper_id_0)s\n</code></pre>"},{"location":"query/where/#not-between","title":"Not Between","text":"<p>Check if a value is outside a range:</p> <pre><code>from embar.query.where import NotBetween\n\nasync def not_between():\n    db = await get_db()\n    await db.select(User.all()).from_(User).where(NotBetween(User.id, 10, 20))\n\nasyncio.run(not_between())\n</code></pre> <p>This generates:</p> <pre><code>WHERE \"user\".\"id\" NOT BETWEEN %(notbetween_lower_id_0)s AND %(notbetween_upper_id_0)s\n</code></pre>"},{"location":"query/where/#logical-operators","title":"Logical Operators","text":""},{"location":"query/where/#and","title":"And","text":"<p>Combine multiple conditions where all must be true:</p> <pre><code>from embar.query.where import And, Eq, Gt\n\nasync def op_and():\n    db = await get_db()\n    await (\n        db.select(User.all())\n        .from_(User)\n        .where(And(\n            Gt(User.id, 10),\n            Like(User.email, \"%@example.com\")\n        ))\n    )\n\nasyncio.run(op_and())\n</code></pre> <p>This generates:</p> <pre><code>WHERE \"user\".\"id\" &gt; %(gt_id_0)s AND \"user\".\"email\" LIKE %(like_email_1)s\n</code></pre>"},{"location":"query/where/#or","title":"Or","text":"<p>Combine multiple conditions where at least one must be true:</p> <pre><code>from embar.query.where import Or, Eq\n\nasync def op_or():\n    db = await get_db()\n    await (\n        db.select(User.all())\n        .from_(User)\n        .where(Or(\n            Eq(User.id, 1),\n            Eq(User.id, 2)\n        ))\n    )\n\nasyncio.run(op_or())\n</code></pre> <p>This generates:</p> <pre><code>WHERE \"user\".\"id\" = %(eq_id_0)s OR \"user\".\"id\" = %(eq_id_1)s\n</code></pre>"},{"location":"query/where/#not","title":"Not","text":"<p>Negate a condition:</p> <pre><code>from embar.query.where import Not, Eq\n\nasync def op_not():\n    db = await get_db()\n    await db.select(User.all()).from_(User).where(Not(Eq(User.id, 1)))\n\nasyncio.run(op_not())\n</code></pre> <p>This generates:</p> <pre><code>WHERE NOT (\"user\".\"id\" = %(eq_id_0)s)\n</code></pre>"},{"location":"query/where/#complex-combinations","title":"Complex Combinations","text":"<p>Nest logical operators for complex conditions:</p> <pre><code>async def complex():\n    db = await get_db()\n    await (\n        db.select(User.all())\n        .from_(User)\n        .where(Or(\n            And(\n                Gt(User.id, 10),\n                Lt(User.id, 20)\n            ),\n            And(\n                Gt(User.id, 50),\n                Lt(User.id, 60)\n            )\n        ))\n    )\n\nasyncio.run(complex())\n</code></pre> <p>This generates:</p> <pre><code>WHERE (\"user\".\"id\" &gt; %(gt_id_0)s AND \"user\".\"id\" &lt; %(lt_id_1)s) OR\n      (\"user\".\"id\" &gt; %(gt_id_2)s AND \"user\".\"id\" &lt; %(lt_id_3)s)\n</code></pre>"},{"location":"query/where/#subqueries","title":"Subqueries","text":""},{"location":"query/where/#exists","title":"Exists","text":"<p>Check if a subquery returns any rows:</p> <pre><code>from embar.query.where import Exists\n\nclass Message(Table):\n    id: Integer = Integer(primary=True)\n    user_id: Integer = Integer().fk(lambda: User.id)\n    content: Text = Text()\n\nasync def exists():\n    db = await get_db([User, Message])\n    subquery = db.select(User.all()).from_(Message).where(Eq(Message.user_id, User.id))\n\n    users = await (\n        db.select(User.all())\n        .from_(User)\n        .where(Exists(subquery))\n    )\n\nasyncio.run(exists())\n</code></pre> <p>This generates:</p> <pre><code>SELECT \"user\".\"id\", \"user\".\"email\" FROM \"user\"\nWHERE EXISTS (\n    SELECT \"message\".\"id\", \"message\".\"user_id\", \"message\".\"content\"\n    FROM \"message\"\n    WHERE \"message\".\"user_id\" = \"user\".\"id\"\n)\n</code></pre>"},{"location":"query/where/#not-exists","title":"Not Exists","text":"<p>Check if a subquery returns no rows:</p> <pre><code>from embar.query.where import NotExists\n\nasync def notexists():\n    db = await get_db()\n    subquery = db.select(User.all()).from_(Message).where(Eq(Message.user_id, User.id))\n    users = await (\n        db.select(User.all())\n        .from_(User)\n        .where(NotExists(subquery))\n    )\n\nasyncio.run(notexists())\n</code></pre> <p>This generates:</p> <pre><code>WHERE NOT EXISTS (...)\n</code></pre>"},{"location":"query/where/#comparing-columns","title":"Comparing Columns","text":"<p>Compare two columns instead of a column and a value:</p> <pre><code>class Order(Table):\n    id: Integer = Integer(primary=True)\n    created_at: Integer = Integer()\n    updated_at: Integer = Integer()\n\nasync def compare():\n    db = await get_db([Order])\n    orders = await (\n        db.select(Order.all())\n        .from_(Order)\n        .where(Gt(Order.updated_at, Order.created_at))\n    )\n\nasyncio.run(compare())\n</code></pre> <p>This generates:</p> <pre><code>WHERE \"order\".\"updated_at\" &gt; \"order\".\"created_at\"\n</code></pre> <p>Notice there are no parameter bindings when comparing columns directly.</p>"},{"location":"query/where/#viewing-the-sql","title":"Viewing the SQL","text":"<p>Inspect the generated where clause:</p> <pre><code>async def raw_sql():\n    db = await get_db()\n    query = (\n        db.select(User.all())\n        .from_(User)\n        .where(And(\n            Gt(User.id, 10),\n            Like(User.email, \"%@example.com\")\n        ))\n        .sql()\n    )\n\n    print(query.sql)\n    # SELECT \"user\".\"id\", \"user\".\"email\" FROM \"user\"\n    # WHERE \"user\".\"id\" &gt; %(gt_id_0)s AND \"user\".\"email\" LIKE %(like_email_1)s\n\n    print(query.params)\n    # {'gt_id_0': 10, 'like_email_1': '%@example.com'}\n\nasyncio.run(raw_sql())\n</code></pre>"},{"location":"query/where/#next-steps","title":"Next Steps","text":"<ul> <li>See how where clauses work with Select queries</li> <li>Use where clauses in Update operations</li> <li>Filter rows in Delete operations</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>embar<ul> <li>column<ul> <li>base</li> <li>common</li> <li>pg</li> <li>sqlite</li> </ul> </li> <li>config</li> <li>constraint</li> <li>constraint_base</li> <li>custom_types</li> <li>db<ul> <li>_util</li> <li>base</li> <li>pg</li> <li>sqlite</li> </ul> </li> <li>migration</li> <li>model</li> <li>query<ul> <li>clause_base</li> <li>conflict</li> <li>delete</li> <li>fns</li> <li>group_by</li> <li>having</li> <li>insert</li> <li>join</li> <li>many</li> <li>order_by</li> <li>query</li> <li>select</li> <li>update</li> <li>vector</li> <li>where</li> </ul> </li> <li>sql</li> <li>sql_db</li> <li>table</li> <li>table_base</li> <li>tools<ul> <li>commands</li> <li>fmt</li> <li>llm</li> <li>migrate</li> <li>models</li> <li>utils</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/embar/","title":"Index","text":""},{"location":"reference/embar/config/","title":"config","text":"<p>Configuration for table definitions.</p>"},{"location":"reference/embar/config/#embar.config.EmbarConfig","title":"<code>EmbarConfig</code>","text":"<p>Configuration for table definitions.</p> <p>Holds table name and constraints.</p> Source code in <code>src/embar/config.py</code> <pre><code>class EmbarConfig:\n    \"\"\"\n    Configuration for table definitions.\n\n    Holds table name and constraints.\n    \"\"\"\n\n    table_name: str = Undefined\n    constraints: list[Constraint]\n\n    def __init__(\n        self,\n        table_name: str | None = None,\n        constraints: list[Constraint] | None = None,\n    ):\n        \"\"\"\n        Create a new EmbarConfig instance.\n        \"\"\"\n        if table_name is not None:\n            self.table_name = table_name\n        self.constraints = constraints if constraints is not None else []\n\n    def __set_name__(self, owner: Any, attr_name: str):\n        \"\"\"\n        This runs after __init__ and sets the name (if unset) from containing class.\n        \"\"\"\n        if self.table_name == Undefined:\n            self.table_name = \"\".join(\"_\" + c.lower() if c.isupper() else c for c in owner.__name__).lstrip(\"_\")\n</code></pre>"},{"location":"reference/embar/config/#embar.config.EmbarConfig.__init__","title":"<code>__init__(table_name=None, constraints=None)</code>","text":"<p>Create a new EmbarConfig instance.</p> Source code in <code>src/embar/config.py</code> <pre><code>def __init__(\n    self,\n    table_name: str | None = None,\n    constraints: list[Constraint] | None = None,\n):\n    \"\"\"\n    Create a new EmbarConfig instance.\n    \"\"\"\n    if table_name is not None:\n        self.table_name = table_name\n    self.constraints = constraints if constraints is not None else []\n</code></pre>"},{"location":"reference/embar/config/#embar.config.EmbarConfig.__set_name__","title":"<code>__set_name__(owner, attr_name)</code>","text":"<p>This runs after init and sets the name (if unset) from containing class.</p> Source code in <code>src/embar/config.py</code> <pre><code>def __set_name__(self, owner: Any, attr_name: str):\n    \"\"\"\n    This runs after __init__ and sets the name (if unset) from containing class.\n    \"\"\"\n    if self.table_name == Undefined:\n        self.table_name = \"\".join(\"_\" + c.lower() if c.isupper() else c for c in owner.__name__).lstrip(\"_\")\n</code></pre>"},{"location":"reference/embar/constraint/","title":"constraint","text":"<p>Table constraints like indexes and unique constraints.</p>"},{"location":"reference/embar/constraint/#embar.constraint.Index","title":"<code>Index</code>","text":"<p>Creates a database index on one or more columns.</p> <pre><code>from embar.column.common import Integer\nfrom embar.config import EmbarConfig\nfrom embar.constraint import Index\nfrom embar.table import Table\nclass MyTable(Table):\n    embar_config: EmbarConfig = EmbarConfig(\n        constraints=[Index(\"my_idx\").on(lambda: MyTable.id)]\n    )\n    id: Integer = Integer()\n</code></pre> Source code in <code>src/embar/constraint.py</code> <pre><code>class Index:\n    \"\"\"\n    Creates a database index on one or more columns.\n\n    ```python\n    from embar.column.common import Integer\n    from embar.config import EmbarConfig\n    from embar.constraint import Index\n    from embar.table import Table\n    class MyTable(Table):\n        embar_config: EmbarConfig = EmbarConfig(\n            constraints=[Index(\"my_idx\").on(lambda: MyTable.id)]\n        )\n        id: Integer = Integer()\n    ```\n    \"\"\"\n\n    name: str\n\n    def __init__(self, name: str):\n        \"\"\"\n        Create a new Index instance.\n        \"\"\"\n        self.name = name\n\n    def on(self, *columns: Callable[[], ColumnBase]) -&gt; IndexReady:\n        \"\"\"\n        Specify the columns this index should be created on.\n        \"\"\"\n        return IndexReady(self.name, False, *columns)\n</code></pre>"},{"location":"reference/embar/constraint/#embar.constraint.Index.__init__","title":"<code>__init__(name)</code>","text":"<p>Create a new Index instance.</p> Source code in <code>src/embar/constraint.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"\n    Create a new Index instance.\n    \"\"\"\n    self.name = name\n</code></pre>"},{"location":"reference/embar/constraint/#embar.constraint.Index.on","title":"<code>on(*columns)</code>","text":"<p>Specify the columns this index should be created on.</p> Source code in <code>src/embar/constraint.py</code> <pre><code>def on(self, *columns: Callable[[], ColumnBase]) -&gt; IndexReady:\n    \"\"\"\n    Specify the columns this index should be created on.\n    \"\"\"\n    return IndexReady(self.name, False, *columns)\n</code></pre>"},{"location":"reference/embar/constraint/#embar.constraint.IndexReady","title":"<code>IndexReady</code>","text":"<p>               Bases: <code>Constraint</code></p> <p>A fully configured index ready to generate SQL.</p> Source code in <code>src/embar/constraint.py</code> <pre><code>class IndexReady(Constraint):\n    \"\"\"\n    A fully configured index ready to generate SQL.\n    \"\"\"\n\n    unique: bool\n    name: str\n    columns: tuple[Callable[[], ColumnBase], ...]\n    _where_clause: Callable[[], ClauseBase] | None = None\n\n    def __init__(self, name: str, unique: bool, *columns: Callable[[], ColumnBase]):\n        \"\"\"\n        Create a new IndexReady instance.\n        \"\"\"\n        self.name = name\n        self.unique = unique\n        self.columns = columns\n\n    def where(self, where_clause: Callable[[], ClauseBase]) -&gt; Self:\n        \"\"\"\n        Add a WHERE clause to create a partial index.\n        \"\"\"\n        self._where_clause = where_clause\n        return self\n\n    @override\n    def sql(self) -&gt; QuerySingle:\n        \"\"\"\n        Generate the CREATE INDEX SQL statement.\n        \"\"\"\n        # Not so sure about this, seems a bit brittle to just get the name as a string?\n        table_names = [c().info.table_name for c in self.columns]\n        if len(set(table_names)) &gt; 1:\n            raise ValueError(f\"Index {self.name}: all columns must be in the same table\")\n        table_name = table_names[0]\n\n        cols = \", \".join(f'\"{c().info.name}\"' for c in self.columns)\n        unique = \" UNIQUE \" if self.unique else \"\"\n        params: dict[str, PyType] = {}\n\n        where_sql = \"\"\n        if self._where_clause:\n            count = -1\n\n            def get_count() -&gt; int:\n                nonlocal count\n                count += 1\n                return count\n\n            where = self._where_clause().sql(get_count)\n            where_sql = f\" WHERE {where.sql}\"\n            params = {**params, **where.params}\n\n        query = f'CREATE {unique} INDEX \"{self.name}\" ON \"{table_name}\"({cols}){where_sql};'\n\n        return QuerySingle(query, params)\n</code></pre>"},{"location":"reference/embar/constraint/#embar.constraint.IndexReady.__init__","title":"<code>__init__(name, unique, *columns)</code>","text":"<p>Create a new IndexReady instance.</p> Source code in <code>src/embar/constraint.py</code> <pre><code>def __init__(self, name: str, unique: bool, *columns: Callable[[], ColumnBase]):\n    \"\"\"\n    Create a new IndexReady instance.\n    \"\"\"\n    self.name = name\n    self.unique = unique\n    self.columns = columns\n</code></pre>"},{"location":"reference/embar/constraint/#embar.constraint.IndexReady.sql","title":"<code>sql()</code>","text":"<p>Generate the CREATE INDEX SQL statement.</p> Source code in <code>src/embar/constraint.py</code> <pre><code>@override\ndef sql(self) -&gt; QuerySingle:\n    \"\"\"\n    Generate the CREATE INDEX SQL statement.\n    \"\"\"\n    # Not so sure about this, seems a bit brittle to just get the name as a string?\n    table_names = [c().info.table_name for c in self.columns]\n    if len(set(table_names)) &gt; 1:\n        raise ValueError(f\"Index {self.name}: all columns must be in the same table\")\n    table_name = table_names[0]\n\n    cols = \", \".join(f'\"{c().info.name}\"' for c in self.columns)\n    unique = \" UNIQUE \" if self.unique else \"\"\n    params: dict[str, PyType] = {}\n\n    where_sql = \"\"\n    if self._where_clause:\n        count = -1\n\n        def get_count() -&gt; int:\n            nonlocal count\n            count += 1\n            return count\n\n        where = self._where_clause().sql(get_count)\n        where_sql = f\" WHERE {where.sql}\"\n        params = {**params, **where.params}\n\n    query = f'CREATE {unique} INDEX \"{self.name}\" ON \"{table_name}\"({cols}){where_sql};'\n\n    return QuerySingle(query, params)\n</code></pre>"},{"location":"reference/embar/constraint/#embar.constraint.IndexReady.where","title":"<code>where(where_clause)</code>","text":"<p>Add a WHERE clause to create a partial index.</p> Source code in <code>src/embar/constraint.py</code> <pre><code>def where(self, where_clause: Callable[[], ClauseBase]) -&gt; Self:\n    \"\"\"\n    Add a WHERE clause to create a partial index.\n    \"\"\"\n    self._where_clause = where_clause\n    return self\n</code></pre>"},{"location":"reference/embar/constraint/#embar.constraint.UniqueIndex","title":"<code>UniqueIndex</code>","text":"<p>Creates a unique database index on one or more columns.</p> Source code in <code>src/embar/constraint.py</code> <pre><code>class UniqueIndex:\n    \"\"\"\n    Creates a unique database index on one or more columns.\n    \"\"\"\n\n    name: str\n\n    def __init__(self, name: str):\n        \"\"\"\n        Create a new UniqueIndex instance.\n        \"\"\"\n        self.name = name\n\n    def on(self, *columns: Callable[[], ColumnBase]) -&gt; IndexReady:\n        \"\"\"\n        Specify the columns this unique index should be created on.\n        \"\"\"\n        return IndexReady(self.name, True, *columns)\n</code></pre>"},{"location":"reference/embar/constraint/#embar.constraint.UniqueIndex.__init__","title":"<code>__init__(name)</code>","text":"<p>Create a new UniqueIndex instance.</p> Source code in <code>src/embar/constraint.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"\n    Create a new UniqueIndex instance.\n    \"\"\"\n    self.name = name\n</code></pre>"},{"location":"reference/embar/constraint/#embar.constraint.UniqueIndex.on","title":"<code>on(*columns)</code>","text":"<p>Specify the columns this unique index should be created on.</p> Source code in <code>src/embar/constraint.py</code> <pre><code>def on(self, *columns: Callable[[], ColumnBase]) -&gt; IndexReady:\n    \"\"\"\n    Specify the columns this unique index should be created on.\n    \"\"\"\n    return IndexReady(self.name, True, *columns)\n</code></pre>"},{"location":"reference/embar/constraint_base/","title":"constraint_base","text":"<p>Base class for table constraints.</p>"},{"location":"reference/embar/constraint_base/#embar.constraint_base.Constraint","title":"<code>Constraint</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for all table constraints like indexes and unique constraints.</p> Source code in <code>src/embar/constraint_base.py</code> <pre><code>class Constraint(ABC):\n    \"\"\"\n    Base class for all table constraints like indexes and unique constraints.\n    \"\"\"\n\n    @abstractmethod\n    def sql(self) -&gt; QuerySingle: ...\n</code></pre>"},{"location":"reference/embar/custom_types/","title":"custom_types","text":"<p>Custom types used throughout embar.</p>"},{"location":"reference/embar/migration/","title":"migration","text":"<p>Migration classes for creating and running database migrations.</p>"},{"location":"reference/embar/migration/#embar.migration.Ddl","title":"<code>Ddl</code>","text":"<p>Represents a DDL statement with optional constraints.</p> Source code in <code>src/embar/migration.py</code> <pre><code>class Ddl:\n    \"\"\"\n    Represents a DDL statement with optional constraints.\n    \"\"\"\n\n    name: str\n    ddl: str\n    constraints: list[str]\n\n    def __init__(self, name: str, ddl: str, constraints: list[str] | None = None):\n        \"\"\"\n        Create a new Ddl instance.\n        \"\"\"\n        self.name = name\n        self.ddl = ddl\n        self.constraints = constraints if constraints is not None else []\n</code></pre>"},{"location":"reference/embar/migration/#embar.migration.Ddl.__init__","title":"<code>__init__(name, ddl, constraints=None)</code>","text":"<p>Create a new Ddl instance.</p> Source code in <code>src/embar/migration.py</code> <pre><code>def __init__(self, name: str, ddl: str, constraints: list[str] | None = None):\n    \"\"\"\n    Create a new Ddl instance.\n    \"\"\"\n    self.name = name\n    self.ddl = ddl\n    self.constraints = constraints if constraints is not None else []\n</code></pre>"},{"location":"reference/embar/migration/#embar.migration.Migration","title":"<code>Migration</code>","text":"<p>Represents a migration that can be run against a database.</p> Source code in <code>src/embar/migration.py</code> <pre><code>class Migration[Db: AllDbBase]:\n    \"\"\"\n    Represents a migration that can be run against a database.\n    \"\"\"\n\n    ddls: list[Ddl]\n    _db: Db\n\n    def __init__(self, ddls: list[Ddl], db: Db):\n        \"\"\"\n        Create a new Migration instance.\n        \"\"\"\n        self.ddls = ddls\n        self._db = db\n\n    @property\n    def merged(self) -&gt; str:\n        \"\"\"\n        Get all DDL statements merged into a single string.\n        \"\"\"\n        query = \"\"\n        for table in self.ddls:\n            query += \"\\n\\n\" + table.ddl\n            for constraint in table.constraints:\n                query += \"\\n\" + constraint\n\n        return query\n\n    def __await__(self) -&gt; Generator[Any, None, None]:\n        \"\"\"\n        Run the migration asynchronously.\n        \"\"\"\n\n        async def awaitable():\n            db = self._db\n            if isinstance(db, AsyncDbBase):\n                for ddl in self.ddls:\n                    await db.execute(QuerySingle(ddl.ddl))\n                    for constraint in ddl.constraints:\n                        await db.execute(QuerySingle(constraint))\n\n            else:\n                db = cast(DbBase, self._db)\n                for ddl in self.ddls:\n                    db.execute(QuerySingle(ddl.ddl))\n                    for constraint in ddl.constraints:\n                        db.execute(QuerySingle(constraint))\n\n        return awaitable().__await__()\n\n    @overload\n    def run(self: Migration[DbBase]) -&gt; None: ...\n    @overload\n    def run(self: Migration[AsyncDbBase]) -&gt; Migration[Db]: ...\n    def run(self) -&gt; None | Migration[Db]:\n        \"\"\"\n        Run the migration synchronously.\n        \"\"\"\n        if isinstance(self._db, DbBase):\n            for ddl in self.ddls:\n                self._db.execute(QuerySingle(ddl.ddl))\n                for constraint in ddl.constraints:\n                    self._db.execute(QuerySingle(constraint))\n            return\n        return self\n</code></pre>"},{"location":"reference/embar/migration/#embar.migration.Migration.merged","title":"<code>merged</code>  <code>property</code>","text":"<p>Get all DDL statements merged into a single string.</p>"},{"location":"reference/embar/migration/#embar.migration.Migration.__await__","title":"<code>__await__()</code>","text":"<p>Run the migration asynchronously.</p> Source code in <code>src/embar/migration.py</code> <pre><code>def __await__(self) -&gt; Generator[Any, None, None]:\n    \"\"\"\n    Run the migration asynchronously.\n    \"\"\"\n\n    async def awaitable():\n        db = self._db\n        if isinstance(db, AsyncDbBase):\n            for ddl in self.ddls:\n                await db.execute(QuerySingle(ddl.ddl))\n                for constraint in ddl.constraints:\n                    await db.execute(QuerySingle(constraint))\n\n        else:\n            db = cast(DbBase, self._db)\n            for ddl in self.ddls:\n                db.execute(QuerySingle(ddl.ddl))\n                for constraint in ddl.constraints:\n                    db.execute(QuerySingle(constraint))\n\n    return awaitable().__await__()\n</code></pre>"},{"location":"reference/embar/migration/#embar.migration.Migration.__init__","title":"<code>__init__(ddls, db)</code>","text":"<p>Create a new Migration instance.</p> Source code in <code>src/embar/migration.py</code> <pre><code>def __init__(self, ddls: list[Ddl], db: Db):\n    \"\"\"\n    Create a new Migration instance.\n    \"\"\"\n    self.ddls = ddls\n    self._db = db\n</code></pre>"},{"location":"reference/embar/migration/#embar.migration.Migration.run","title":"<code>run()</code>","text":"<pre><code>run() -&gt; None\n</code></pre><pre><code>run() -&gt; Migration[Db]\n</code></pre> <p>Run the migration synchronously.</p> Source code in <code>src/embar/migration.py</code> <pre><code>def run(self) -&gt; None | Migration[Db]:\n    \"\"\"\n    Run the migration synchronously.\n    \"\"\"\n    if isinstance(self._db, DbBase):\n        for ddl in self.ddls:\n            self._db.execute(QuerySingle(ddl.ddl))\n            for constraint in ddl.constraints:\n                self._db.execute(QuerySingle(constraint))\n        return\n    return self\n</code></pre>"},{"location":"reference/embar/migration/#embar.migration.MigrationDefs","title":"<code>MigrationDefs</code>","text":"<p>Holds table and enum definitions for migrations.</p> Source code in <code>src/embar/migration.py</code> <pre><code>class MigrationDefs:\n    \"\"\"\n    Holds table and enum definitions for migrations.\n    \"\"\"\n\n    tables: list[type[Table]]\n    enums: list[type[EnumBase]]\n\n    def __init__(self, tables: Sequence[type[Table]], enums: Sequence[type[EnumBase]] | None = None):\n        \"\"\"\n        Create a new MigrationDefs instance.\n        \"\"\"\n        self.tables = list(tables)\n        self.enums = list(enums) if enums is not None else []\n</code></pre>"},{"location":"reference/embar/migration/#embar.migration.MigrationDefs.__init__","title":"<code>__init__(tables, enums=None)</code>","text":"<p>Create a new MigrationDefs instance.</p> Source code in <code>src/embar/migration.py</code> <pre><code>def __init__(self, tables: Sequence[type[Table]], enums: Sequence[type[EnumBase]] | None = None):\n    \"\"\"\n    Create a new MigrationDefs instance.\n    \"\"\"\n    self.tables = list(tables)\n    self.enums = list(enums) if enums is not None else []\n</code></pre>"},{"location":"reference/embar/model/","title":"model","text":""},{"location":"reference/embar/model/#embar.model.SelectAll","title":"<code>SelectAll</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p><code>SelectAll</code> tells the query engine to get all fields from the <code>from()</code> table ONLY.</p> <p>Ideally it could get fields from joined tables too, but no way for that to work (from a typing POV) Not recommended for public use, users should rather use their table's <code>all()</code> method.</p> Source code in <code>src/embar/model.py</code> <pre><code>class SelectAll(BaseModel):\n    \"\"\"\n    `SelectAll` tells the query engine to get all fields from the `from()` table ONLY.\n\n    Ideally it could get fields from joined tables too, but no way for that to work (from a typing POV)\n    Not recommended for public use, users should rather use their table's `all()` method.\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/embar/model/#embar.model.generate_model","title":"<code>generate_model(cls)</code>","text":"<p>Create a model based on a <code>Table</code>.</p> <p>Note the new table has the same exact name, maybe something to revisit.</p> <pre><code>from embar.table import Table\nfrom embar.model import generate_model\nclass MyTable(Table): ...\ngenerate_model(MyTable)\n</code></pre> Source code in <code>src/embar/model.py</code> <pre><code>def generate_model(cls: type[TableBase]) -&gt; type[BaseModel]:\n    \"\"\"\n    Create a model based on a `Table`.\n\n    Note the new table has the same exact name, maybe something to revisit.\n\n    ```python\n    from embar.table import Table\n    from embar.model import generate_model\n    class MyTable(Table): ...\n    generate_model(MyTable)\n    ```\n    \"\"\"\n\n    fields_dict: dict[str, Any] = {}\n    for field_name, column in cls._fields.items():  # pyright:ignore[reportPrivateUsage]\n        field_type = column.info.py_type\n\n        if column.info.col_type == \"VECTOR\":\n            field_type = Annotated[field_type, BeforeValidator(_parse_json_list)]\n\n        fields_dict[field_name] = (\n            Annotated[field_type, column],\n            Field(default_factory=lambda a=column: column.info.fqn()),\n        )\n\n    model = create_model(cls.__name__, **fields_dict)\n    model.model_rebuild()\n    return model\n</code></pre>"},{"location":"reference/embar/sql/","title":"sql","text":""},{"location":"reference/embar/sql/#embar.sql.Sql","title":"<code>Sql</code>","text":"<p>Used to run raw SQL queries.</p> <p>On creation, nothing actually happens. Only later inside the select query class is the <code>execute()</code> method called.</p> <pre><code>from embar.table import Table\nfrom embar.sql import Sql\nclass MyTable(Table): ...\nsql = Sql(t\"DELETE FROM {MyTable}\").sql()\nassert sql == 'DELETE FROM \"my_table\"'\n</code></pre> Source code in <code>src/embar/sql.py</code> <pre><code>class Sql:\n    \"\"\"\n    Used to run raw SQL queries.\n\n    On creation, nothing actually happens. Only later inside the select query\n    class is the `execute()` method called.\n\n    ```python\n    from embar.table import Table\n    from embar.sql import Sql\n    class MyTable(Table): ...\n    sql = Sql(t\"DELETE FROM {MyTable}\").sql()\n    assert sql == 'DELETE FROM \"my_table\"'\n    ```\n    \"\"\"\n\n    template_obj: Template\n\n    def __init__(self, template: Template):\n        self.template_obj = template\n\n    def sql(self) -&gt; str:\n        \"\"\"\n        Actually generate the SQL output.\n        \"\"\"\n        query_parts: list[str] = []\n\n        # Some types of queries we _don't_ want the table name prefixed to the column name\n        # UPDATE \"user\" SET \"name\" = 'foo'\n        # Using \"user\".\"name\" is an error\n        # TODO: This is a very terrible heuristic and will probably break\n        strings = self.template_obj.strings\n        first_word = strings[0].strip() if len(strings) &gt; 0 else None\n        omit_table_name = first_word is not None and first_word in [\"CREATE\", \"UPDATE\"]\n\n        # Iterate over template components\n        for item in self.template_obj:\n            if isinstance(item, str):\n                query_parts.append(item)\n            else:\n                value = item.value\n\n                if isinstance(value, type) and issubclass(value, TableBase):\n                    query_parts.append(value.fqn())\n                elif isinstance(value, ColumnBase):\n                    quoted = f'\"{value.info.name}\"' if omit_table_name else value.info.fqn()\n                    query_parts.append(quoted)\n                else:\n                    raise Exception(f\"Unexpected interpolation type: {type(cast(Any, value))}\")\n\n        result = \"\".join(query_parts)\n        escaped = escape_placeholder(result)\n        return escaped\n</code></pre>"},{"location":"reference/embar/sql/#embar.sql.Sql.sql","title":"<code>sql()</code>","text":"<p>Actually generate the SQL output.</p> Source code in <code>src/embar/sql.py</code> <pre><code>def sql(self) -&gt; str:\n    \"\"\"\n    Actually generate the SQL output.\n    \"\"\"\n    query_parts: list[str] = []\n\n    # Some types of queries we _don't_ want the table name prefixed to the column name\n    # UPDATE \"user\" SET \"name\" = 'foo'\n    # Using \"user\".\"name\" is an error\n    # TODO: This is a very terrible heuristic and will probably break\n    strings = self.template_obj.strings\n    first_word = strings[0].strip() if len(strings) &gt; 0 else None\n    omit_table_name = first_word is not None and first_word in [\"CREATE\", \"UPDATE\"]\n\n    # Iterate over template components\n    for item in self.template_obj:\n        if isinstance(item, str):\n            query_parts.append(item)\n        else:\n            value = item.value\n\n            if isinstance(value, type) and issubclass(value, TableBase):\n                query_parts.append(value.fqn())\n            elif isinstance(value, ColumnBase):\n                quoted = f'\"{value.info.name}\"' if omit_table_name else value.info.fqn()\n                query_parts.append(quoted)\n            else:\n                raise Exception(f\"Unexpected interpolation type: {type(cast(Any, value))}\")\n\n    result = \"\".join(query_parts)\n    escaped = escape_placeholder(result)\n    return escaped\n</code></pre>"},{"location":"reference/embar/sql_db/","title":"sql_db","text":"<p>Raw SQL query execution with optional result parsing.</p>"},{"location":"reference/embar/sql_db/#embar.sql_db.DbSql","title":"<code>DbSql</code>","text":"<p>Used to run raw SQL queries.</p> Source code in <code>src/embar/sql_db.py</code> <pre><code>class DbSql[Db: AllDbBase]:\n    \"\"\"\n    Used to run raw SQL queries.\n    \"\"\"\n\n    _sql: Sql\n    _db: Db\n\n    def __init__(self, template: Template, db: Db):\n        \"\"\"\n        Create a new DbSql instance.\n        \"\"\"\n        self._sql = Sql(template)\n        self._db = db\n\n    def model[M: BaseModel](self, model: type[M]) -&gt; DbSqlReturning[M, Db]:\n        \"\"\"\n        Specify a model for parsing results.\n        \"\"\"\n        return DbSqlReturning(self._sql, model, self._db)\n\n    def sql(self) -&gt; str:\n        return self._sql.sql()\n\n    def __await__(self):\n        \"\"\"\n        Run the query asynchronously without returning results.\n        \"\"\"\n        sql = self._sql.sql()\n        query = QuerySingle(sql)\n\n        async def awaitable():\n            db = self._db\n\n            if isinstance(db, AsyncDbBase):\n                await db.execute(query)\n            else:\n                db = cast(DbBase, self._db)\n                db.execute(query)\n\n        return awaitable().__await__()\n\n    @overload\n    def run(self: DbSql[DbBase]) -&gt; None: ...\n    @overload\n    def run(self: DbSql[AsyncDbBase]) -&gt; DbSql[Db]: ...\n\n    def run(self) -&gt; None | DbSql[Db]:\n        \"\"\"\n        Run the query synchronously without returning results.\n        \"\"\"\n        if isinstance(self._db, DbBase):\n            sql = self._sql.sql()\n            query = QuerySingle(sql)\n            self._db.execute(query)\n        return self\n</code></pre>"},{"location":"reference/embar/sql_db/#embar.sql_db.DbSql.__await__","title":"<code>__await__()</code>","text":"<p>Run the query asynchronously without returning results.</p> Source code in <code>src/embar/sql_db.py</code> <pre><code>def __await__(self):\n    \"\"\"\n    Run the query asynchronously without returning results.\n    \"\"\"\n    sql = self._sql.sql()\n    query = QuerySingle(sql)\n\n    async def awaitable():\n        db = self._db\n\n        if isinstance(db, AsyncDbBase):\n            await db.execute(query)\n        else:\n            db = cast(DbBase, self._db)\n            db.execute(query)\n\n    return awaitable().__await__()\n</code></pre>"},{"location":"reference/embar/sql_db/#embar.sql_db.DbSql.__init__","title":"<code>__init__(template, db)</code>","text":"<p>Create a new DbSql instance.</p> Source code in <code>src/embar/sql_db.py</code> <pre><code>def __init__(self, template: Template, db: Db):\n    \"\"\"\n    Create a new DbSql instance.\n    \"\"\"\n    self._sql = Sql(template)\n    self._db = db\n</code></pre>"},{"location":"reference/embar/sql_db/#embar.sql_db.DbSql.model","title":"<code>model(model)</code>","text":"<p>Specify a model for parsing results.</p> Source code in <code>src/embar/sql_db.py</code> <pre><code>def model[M: BaseModel](self, model: type[M]) -&gt; DbSqlReturning[M, Db]:\n    \"\"\"\n    Specify a model for parsing results.\n    \"\"\"\n    return DbSqlReturning(self._sql, model, self._db)\n</code></pre>"},{"location":"reference/embar/sql_db/#embar.sql_db.DbSql.run","title":"<code>run()</code>","text":"<pre><code>run() -&gt; None\n</code></pre><pre><code>run() -&gt; DbSql[Db]\n</code></pre> <p>Run the query synchronously without returning results.</p> Source code in <code>src/embar/sql_db.py</code> <pre><code>def run(self) -&gt; None | DbSql[Db]:\n    \"\"\"\n    Run the query synchronously without returning results.\n    \"\"\"\n    if isinstance(self._db, DbBase):\n        sql = self._sql.sql()\n        query = QuerySingle(sql)\n        self._db.execute(query)\n    return self\n</code></pre>"},{"location":"reference/embar/sql_db/#embar.sql_db.DbSqlReturning","title":"<code>DbSqlReturning</code>","text":"<p>Used to run raw SQL queries and return a value.</p> Source code in <code>src/embar/sql_db.py</code> <pre><code>class DbSqlReturning[M: BaseModel, Db: AllDbBase]:\n    \"\"\"\n    Used to run raw SQL queries and return a value.\n    \"\"\"\n\n    _sql: Sql\n    model: type[M]\n    _db: Db\n\n    def __init__(self, sql: Sql, model: type[M], db: Db):\n        \"\"\"\n        Create a new DbSqlReturning instance.\n        \"\"\"\n        self._sql = sql\n        self.model = model\n        self._db = db\n\n    def sql(self) -&gt; str:\n        return self._sql.sql()\n\n    def __await__(self) -&gt; Generator[Any, None, Sequence[M]]:\n        \"\"\"\n        Run the query asynchronously and return parsed results.\n        \"\"\"\n        sql = self._sql.sql()\n        query = QuerySingle(sql)\n        model = self._get_model()\n        adapter = TypeAdapter(list[model])\n\n        async def awaitable():\n            db = self._db\n\n            if isinstance(db, AsyncDbBase):\n                data = await db.fetch(query)\n            else:\n                db = cast(DbBase, self._db)\n                data = db.fetch(query)\n            results = adapter.validate_python(data)\n            return results\n\n        return awaitable().__await__()\n\n    @overload\n    def run(self: DbSqlReturning[M, DbBase]) -&gt; Sequence[M]: ...\n    @overload\n    def run(self: DbSqlReturning[M, AsyncDbBase]) -&gt; DbSqlReturning[M, Db]: ...\n\n    def run(self) -&gt; Sequence[M] | DbSqlReturning[M, Db]:\n        \"\"\"\n        Run the query synchronously and return parsed results.\n        \"\"\"\n        if isinstance(self._db, DbBase):\n            sql = self._sql.sql()\n            query = QuerySingle(sql)\n            data = self._db.fetch(query)\n            model = self._get_model()\n            adapter = TypeAdapter(list[model])\n            self.model.__init_subclass__()\n            results = adapter.validate_python(data)\n            return results\n        return self\n\n    def _get_model(self) -&gt; type[M]:\n        \"\"\"\n        Generate the dataclass that will be used to deserialize (and validate) the query results.\n        \"\"\"\n        return upgrade_model_nested_fields(self.model)\n</code></pre>"},{"location":"reference/embar/sql_db/#embar.sql_db.DbSqlReturning.__await__","title":"<code>__await__()</code>","text":"<p>Run the query asynchronously and return parsed results.</p> Source code in <code>src/embar/sql_db.py</code> <pre><code>def __await__(self) -&gt; Generator[Any, None, Sequence[M]]:\n    \"\"\"\n    Run the query asynchronously and return parsed results.\n    \"\"\"\n    sql = self._sql.sql()\n    query = QuerySingle(sql)\n    model = self._get_model()\n    adapter = TypeAdapter(list[model])\n\n    async def awaitable():\n        db = self._db\n\n        if isinstance(db, AsyncDbBase):\n            data = await db.fetch(query)\n        else:\n            db = cast(DbBase, self._db)\n            data = db.fetch(query)\n        results = adapter.validate_python(data)\n        return results\n\n    return awaitable().__await__()\n</code></pre>"},{"location":"reference/embar/sql_db/#embar.sql_db.DbSqlReturning.__init__","title":"<code>__init__(sql, model, db)</code>","text":"<p>Create a new DbSqlReturning instance.</p> Source code in <code>src/embar/sql_db.py</code> <pre><code>def __init__(self, sql: Sql, model: type[M], db: Db):\n    \"\"\"\n    Create a new DbSqlReturning instance.\n    \"\"\"\n    self._sql = sql\n    self.model = model\n    self._db = db\n</code></pre>"},{"location":"reference/embar/sql_db/#embar.sql_db.DbSqlReturning.run","title":"<code>run()</code>","text":"<pre><code>run() -&gt; Sequence[M]\n</code></pre><pre><code>run() -&gt; DbSqlReturning[M, Db]\n</code></pre> <p>Run the query synchronously and return parsed results.</p> Source code in <code>src/embar/sql_db.py</code> <pre><code>def run(self) -&gt; Sequence[M] | DbSqlReturning[M, Db]:\n    \"\"\"\n    Run the query synchronously and return parsed results.\n    \"\"\"\n    if isinstance(self._db, DbBase):\n        sql = self._sql.sql()\n        query = QuerySingle(sql)\n        data = self._db.fetch(query)\n        model = self._get_model()\n        adapter = TypeAdapter(list[model])\n        self.model.__init_subclass__()\n        results = adapter.validate_python(data)\n        return results\n    return self\n</code></pre>"},{"location":"reference/embar/table/","title":"table","text":"<p>Ideally table.py would be in a table/ module but then it's impossible to import table_base.py without triggering table.py, causing a circular loop by the Many stuff (that's the reason the two were separated in the first place).</p>"},{"location":"reference/embar/table/#embar.table.Table","title":"<code>Table</code>","text":"<p>               Bases: <code>TableBase</code></p> <p>All table definitions inherit from <code>Table</code>.</p> <p>Table is used extensively as both a class/type and as objects. - Tables/schemas are created as <code>class MyTable(Table): ...</code> - Table references (in where clauses, joins, FKs) refer to these types - New rows to insert into a table are created as objects</p> Source code in <code>src/embar/table.py</code> <pre><code>@dataclass_transform(kw_only_default=True, field_specifiers=(Integer, Text, Integer.fk))\nclass Table(TableBase):\n    \"\"\"\n    All table definitions inherit from `Table`.\n\n    Table is used extensively as both a class/type and as objects.\n    - Tables/schemas are created as `class MyTable(Table): ...`\n    - Table references (in where clauses, joins, FKs) refer to these types\n    - New rows to insert into a table are created as objects\n    \"\"\"\n\n    def __init_subclass__(cls, **kwargs: Any):\n        \"\"\"\n        Populate `_fields` and the `embar_config` if not provided.\n        \"\"\"\n        cls._fields = {name: attr for name, attr in cls.__dict__.items() if isinstance(attr, ColumnBase)}  # pyright:ignore[reportUnannotatedClassAttribute]\n\n        if cls.embar_config == Undefined:\n            cls.embar_config: EmbarConfig = EmbarConfig()\n            cls.embar_config.__set_name__(cls, \"embar_config\")\n\n        super().__init_subclass__(**kwargs)\n\n    def __init__(self, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Minimal replication of `dataclass` behaviour.\n        \"\"\"\n        columns: dict[str, type[Column[Any]]] = {  # pyright:ignore[reportAssignmentType]\n            name: attr for name, attr in type(self).__dict__.items() if isinstance(attr, ColumnBase)\n        }\n\n        for name, value in kwargs.items():\n            if name not in columns:\n                raise TypeError(f\"Unknown field: {name}\")\n            setattr(self, name, value)\n\n        # Handle defaults for missing fields\n        missing = set(columns.keys()) - set(kwargs.keys())\n        for name in list(missing):\n            if columns[name].default is not None:  # pyright:ignore[reportGeneralTypeIssues]\n                setattr(self, name, columns[name].default)  # pyright:ignore[reportGeneralTypeIssues]\n                missing.remove(name)\n\n        if missing:\n            raise TypeError(f\"Missing required fields: {missing}\")\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls,\n        source_type: Any,\n        handler: Any,\n    ) -&gt; core_schema.CoreSchema:\n        return core_schema.any_schema()\n\n    @classmethod\n    def many(cls) -&gt; ManyTable[type[Self]]:\n        \"\"\"\n        Used to nest many of another table in a column in a model\n\n        ```python\n        from typing import Annotated\n        from pydantic import BaseModel\n        from embar.table import Table\n        class MyTable(Table): ...\n        class MyModel(BaseModel):\n            messages: Annotated[list[MyTable], MyTable.many()]\n        ```\n        \"\"\"\n        return ManyTable[type[Self]](cls)\n\n    @classmethod\n    def one(cls) -&gt; OneTable[type[Self]]:\n        \"\"\"\n        Used to nest one of another table in a column in a model\n        \"\"\"\n        return OneTable[type[Self]](cls)\n\n    @classmethod\n    def ddl(cls) -&gt; str:\n        \"\"\"\n        Generate a full DDL for the table.\n        \"\"\"\n        columns: list[str] = []\n        for attr_name, attr in cls.__dict__.items():\n            if attr_name.startswith(\"_\"):\n                continue\n            if isinstance(attr, ColumnBase):\n                columns.append(attr.info.ddl())\n        columns_str = \",\\n\".join(columns)\n        columns_str = indent(columns_str, \"    \")\n\n        sql = f\"\"\"\nCREATE TABLE IF NOT EXISTS {cls.fqn()} (\n{columns_str}\n);\"\"\"\n\n        sql = dedent(sql).strip()\n\n        return sql\n\n    @classmethod\n    def all(cls) -&gt; type[SelectAll]:\n        \"\"\"\n        Generate a Select query model that returns all the table's fields.\n\n        ```python\n        from embar.model import SelectAll\n        from embar.table import Table\n        class MyTable(Table): ...\n        model = MyTable.all()\n        assert model == SelectAll\n        ```\n        \"\"\"\n        return SelectAll\n\n    def value_dict(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Result is keyed to DB column names, _not_ field names.\n        \"\"\"\n        result: dict[str, Any] = {}\n        for attr_name, attr in self.__class__.__dict__.items():\n            if attr_name.startswith(\"_\"):\n                continue\n            if isinstance(attr, ColumnBase):\n                result[attr.info.name] = getattr(self, attr_name)\n        return result\n</code></pre>"},{"location":"reference/embar/table/#embar.table.Table.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Minimal replication of <code>dataclass</code> behaviour.</p> Source code in <code>src/embar/table.py</code> <pre><code>def __init__(self, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Minimal replication of `dataclass` behaviour.\n    \"\"\"\n    columns: dict[str, type[Column[Any]]] = {  # pyright:ignore[reportAssignmentType]\n        name: attr for name, attr in type(self).__dict__.items() if isinstance(attr, ColumnBase)\n    }\n\n    for name, value in kwargs.items():\n        if name not in columns:\n            raise TypeError(f\"Unknown field: {name}\")\n        setattr(self, name, value)\n\n    # Handle defaults for missing fields\n    missing = set(columns.keys()) - set(kwargs.keys())\n    for name in list(missing):\n        if columns[name].default is not None:  # pyright:ignore[reportGeneralTypeIssues]\n            setattr(self, name, columns[name].default)  # pyright:ignore[reportGeneralTypeIssues]\n            missing.remove(name)\n\n    if missing:\n        raise TypeError(f\"Missing required fields: {missing}\")\n</code></pre>"},{"location":"reference/embar/table/#embar.table.Table.__init_subclass__","title":"<code>__init_subclass__(**kwargs)</code>","text":"<p>Populate <code>_fields</code> and the <code>embar_config</code> if not provided.</p> Source code in <code>src/embar/table.py</code> <pre><code>def __init_subclass__(cls, **kwargs: Any):\n    \"\"\"\n    Populate `_fields` and the `embar_config` if not provided.\n    \"\"\"\n    cls._fields = {name: attr for name, attr in cls.__dict__.items() if isinstance(attr, ColumnBase)}  # pyright:ignore[reportUnannotatedClassAttribute]\n\n    if cls.embar_config == Undefined:\n        cls.embar_config: EmbarConfig = EmbarConfig()\n        cls.embar_config.__set_name__(cls, \"embar_config\")\n\n    super().__init_subclass__(**kwargs)\n</code></pre>"},{"location":"reference/embar/table/#embar.table.Table.all","title":"<code>all()</code>  <code>classmethod</code>","text":"<p>Generate a Select query model that returns all the table's fields.</p> <pre><code>from embar.model import SelectAll\nfrom embar.table import Table\nclass MyTable(Table): ...\nmodel = MyTable.all()\nassert model == SelectAll\n</code></pre> Source code in <code>src/embar/table.py</code> <pre><code>@classmethod\ndef all(cls) -&gt; type[SelectAll]:\n    \"\"\"\n    Generate a Select query model that returns all the table's fields.\n\n    ```python\n    from embar.model import SelectAll\n    from embar.table import Table\n    class MyTable(Table): ...\n    model = MyTable.all()\n    assert model == SelectAll\n    ```\n    \"\"\"\n    return SelectAll\n</code></pre>"},{"location":"reference/embar/table/#embar.table.Table.ddl","title":"<code>ddl()</code>  <code>classmethod</code>","text":"<p>Generate a full DDL for the table.</p> Source code in <code>src/embar/table.py</code> <pre><code>    @classmethod\n    def ddl(cls) -&gt; str:\n        \"\"\"\n        Generate a full DDL for the table.\n        \"\"\"\n        columns: list[str] = []\n        for attr_name, attr in cls.__dict__.items():\n            if attr_name.startswith(\"_\"):\n                continue\n            if isinstance(attr, ColumnBase):\n                columns.append(attr.info.ddl())\n        columns_str = \",\\n\".join(columns)\n        columns_str = indent(columns_str, \"    \")\n\n        sql = f\"\"\"\nCREATE TABLE IF NOT EXISTS {cls.fqn()} (\n{columns_str}\n);\"\"\"\n\n        sql = dedent(sql).strip()\n\n        return sql\n</code></pre>"},{"location":"reference/embar/table/#embar.table.Table.many","title":"<code>many()</code>  <code>classmethod</code>","text":"<p>Used to nest many of another table in a column in a model</p> <pre><code>from typing import Annotated\nfrom pydantic import BaseModel\nfrom embar.table import Table\nclass MyTable(Table): ...\nclass MyModel(BaseModel):\n    messages: Annotated[list[MyTable], MyTable.many()]\n</code></pre> Source code in <code>src/embar/table.py</code> <pre><code>@classmethod\ndef many(cls) -&gt; ManyTable[type[Self]]:\n    \"\"\"\n    Used to nest many of another table in a column in a model\n\n    ```python\n    from typing import Annotated\n    from pydantic import BaseModel\n    from embar.table import Table\n    class MyTable(Table): ...\n    class MyModel(BaseModel):\n        messages: Annotated[list[MyTable], MyTable.many()]\n    ```\n    \"\"\"\n    return ManyTable[type[Self]](cls)\n</code></pre>"},{"location":"reference/embar/table/#embar.table.Table.one","title":"<code>one()</code>  <code>classmethod</code>","text":"<p>Used to nest one of another table in a column in a model</p> Source code in <code>src/embar/table.py</code> <pre><code>@classmethod\ndef one(cls) -&gt; OneTable[type[Self]]:\n    \"\"\"\n    Used to nest one of another table in a column in a model\n    \"\"\"\n    return OneTable[type[Self]](cls)\n</code></pre>"},{"location":"reference/embar/table/#embar.table.Table.value_dict","title":"<code>value_dict()</code>","text":"<p>Result is keyed to DB column names, not field names.</p> Source code in <code>src/embar/table.py</code> <pre><code>def value_dict(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Result is keyed to DB column names, _not_ field names.\n    \"\"\"\n    result: dict[str, Any] = {}\n    for attr_name, attr in self.__class__.__dict__.items():\n        if attr_name.startswith(\"_\"):\n            continue\n        if isinstance(attr, ColumnBase):\n            result[attr.info.name] = getattr(self, attr_name)\n    return result\n</code></pre>"},{"location":"reference/embar/table_base/","title":"table_base","text":"<p>Base class for table definitions.</p>"},{"location":"reference/embar/table_base/#embar.table_base.TableBase","title":"<code>TableBase</code>","text":"<p>Base class for <code>Table</code> classes.</p> <p>The split between <code>Table</code> and <code>TableBase</code> is a bit arbitrary, mostly dictated by preventing circular imports.</p> Source code in <code>src/embar/table_base.py</code> <pre><code>class TableBase:\n    \"\"\"\n    Base class for `Table` classes.\n\n    The split between `Table` and `TableBase` is a bit arbitrary, mostly\n    dictated by preventing circular imports.\n    \"\"\"\n\n    embar_config: EmbarConfig = Undefined\n    _fields: ClassVar[dict[str, ColumnBase]]\n\n    @classmethod\n    def get_name(cls) -&gt; str:\n        \"\"\"\n        Get the table's _database_ name.\n        \"\"\"\n        return cls.embar_config.table_name\n\n    @classmethod\n    def fqn(cls) -&gt; str:\n        \"\"\"\n        Get the \"Fully Qualified Name\" of the table (i.e. with quotes).\n        \"\"\"\n        return f'\"{cls.embar_config.table_name}\"'\n\n    @classmethod\n    def column_names(cls) -&gt; dict[str, str]:\n        \"\"\"\n        Mapping of field names to _unquoted_ column names.\n\n        Column names are allowed to be different to field names, so in queries\n        we always need to map one to/from the other.\n        \"\"\"\n        cols = {name: col.info.name for name, col in cls._fields.items()}\n        return cols\n</code></pre>"},{"location":"reference/embar/table_base/#embar.table_base.TableBase.column_names","title":"<code>column_names()</code>  <code>classmethod</code>","text":"<p>Mapping of field names to unquoted column names.</p> <p>Column names are allowed to be different to field names, so in queries we always need to map one to/from the other.</p> Source code in <code>src/embar/table_base.py</code> <pre><code>@classmethod\ndef column_names(cls) -&gt; dict[str, str]:\n    \"\"\"\n    Mapping of field names to _unquoted_ column names.\n\n    Column names are allowed to be different to field names, so in queries\n    we always need to map one to/from the other.\n    \"\"\"\n    cols = {name: col.info.name for name, col in cls._fields.items()}\n    return cols\n</code></pre>"},{"location":"reference/embar/table_base/#embar.table_base.TableBase.fqn","title":"<code>fqn()</code>  <code>classmethod</code>","text":"<p>Get the \"Fully Qualified Name\" of the table (i.e. with quotes).</p> Source code in <code>src/embar/table_base.py</code> <pre><code>@classmethod\ndef fqn(cls) -&gt; str:\n    \"\"\"\n    Get the \"Fully Qualified Name\" of the table (i.e. with quotes).\n    \"\"\"\n    return f'\"{cls.embar_config.table_name}\"'\n</code></pre>"},{"location":"reference/embar/table_base/#embar.table_base.TableBase.get_name","title":"<code>get_name()</code>  <code>classmethod</code>","text":"<p>Get the table's database name.</p> Source code in <code>src/embar/table_base.py</code> <pre><code>@classmethod\ndef get_name(cls) -&gt; str:\n    \"\"\"\n    Get the table's _database_ name.\n    \"\"\"\n    return cls.embar_config.table_name\n</code></pre>"},{"location":"reference/embar/column/","title":"Index","text":"<p>Column types and definitions for embar ORM.</p>"},{"location":"reference/embar/column/base/","title":"base","text":""},{"location":"reference/embar/column/base/#embar.column.base.ColumnBase","title":"<code>ColumnBase</code>","text":"<p>Base class for all <code>Column</code> classes.</p> <p>Mostly here to avoid circular dependencies with modules that need to know about the fields below.</p> Source code in <code>src/embar/column/base.py</code> <pre><code>class ColumnBase:\n    \"\"\"\n    Base class for all [`Column`][embar.column.common.Column] classes.\n\n    Mostly here to avoid circular dependencies with modules that need to know about the fields below.\n    \"\"\"\n\n    info: ColumnInfo  # pyright:ignore[reportUninitializedInstanceVariable]\n\n    # These must always be assigned by children, type-checker won't catch it\n    _sql_type: str  # pyright:ignore[reportUninitializedInstanceVariable]\n    _py_type: Type  # pyright:ignore[reportUninitializedInstanceVariable]\n</code></pre>"},{"location":"reference/embar/column/base/#embar.column.base.ColumnInfo","title":"<code>ColumnInfo</code>  <code>dataclass</code>","text":"<p><code>ColumnInfo</code> is the type that ultimately holds all the db column info.</p> <p>It knows nothing about the python field: its name, what type it should deserialize to etc.</p> Source code in <code>src/embar/column/base.py</code> <pre><code>@dataclass\nclass ColumnInfo:\n    \"\"\"\n    `ColumnInfo` is the type that ultimately holds all the db column info.\n\n    It knows nothing about the python field: its name, what type it should deserialize to etc.\n    \"\"\"\n\n    # _table_name is callable as generally the `Table` won't yet have a name\n    # at the time the Column is created.\n    _table_name: Callable[[], str]\n\n    name: str\n    col_type: str\n    py_type: Type\n    primary: bool\n    not_null: bool\n    default: Any | None = None\n\n    ref: ColumnInfo | None = None\n    on_delete: OnDelete | None = None\n\n    args: str | None = None\n\n    @property\n    def table_name(self) -&gt; str:\n        return self._table_name()\n\n    def fqn(self) -&gt; str:\n        \"\"\"\n        Return the Fully Qualified Name (table and column both in quotes).\n\n        ```python\n        from embar.column.base import ColumnInfo\n        col = ColumnInfo(\n           _table_name=lambda: \"foo\", name=\"bar\", col_type=\"TEXT\", py_type=str, primary=False, not_null=False\n        )\n        fqn = col.fqn()\n        assert fqn == '\"foo\".\"bar\"'\n        ```\n        \"\"\"\n        return f'\"{self._table_name()}\".\"{self.name}\"'\n\n    def ddl(self) -&gt; str:\n        \"\"\"\n        Generate the DDL just for this column.\n\n        Used by the [`Table.ddl()`][embar.table.Table.ddl] method to generate the full DDL.\n\n        ```python\n        from embar.column.base import ColumnInfo\n        col = ColumnInfo(\n           _table_name=lambda: \"foo\", name=\"bar\", col_type=\"TEXT\", py_type=str, primary=True, not_null=True\n        )\n        ddl = col.ddl()\n        assert ddl == '\"bar\" TEXT NOT NULL PRIMARY KEY'\n        ```\n        \"\"\"\n        args = self.args if self.args is not None else \"\"\n        default = f\"DEFAULT '{self.default}'\" if self.default is not None else \"\"\n        nullable = \"NOT NULL\" if self.not_null else \"\"\n        primary = \"PRIMARY KEY\" if self.primary else \"\"\n        reference = f'REFERENCES \"{self.ref.table_name}\"(\"{self.ref.name}\")' if self.ref is not None else \"\"\n        on_delete = f\"ON DELETE {self.on_delete}\" if self.on_delete is not None else \"\"\n        text = f'\"{self.name}\" {self.col_type}{args} {default} {nullable} {primary} {reference} {on_delete}'\n        clean = \" \".join(text.split()).strip()\n        return clean\n</code></pre>"},{"location":"reference/embar/column/base/#embar.column.base.ColumnInfo.ddl","title":"<code>ddl()</code>","text":"<p>Generate the DDL just for this column.</p> <p>Used by the <code>Table.ddl()</code> method to generate the full DDL.</p> <pre><code>from embar.column.base import ColumnInfo\ncol = ColumnInfo(\n   _table_name=lambda: \"foo\", name=\"bar\", col_type=\"TEXT\", py_type=str, primary=True, not_null=True\n)\nddl = col.ddl()\nassert ddl == '\"bar\" TEXT NOT NULL PRIMARY KEY'\n</code></pre> Source code in <code>src/embar/column/base.py</code> <pre><code>def ddl(self) -&gt; str:\n    \"\"\"\n    Generate the DDL just for this column.\n\n    Used by the [`Table.ddl()`][embar.table.Table.ddl] method to generate the full DDL.\n\n    ```python\n    from embar.column.base import ColumnInfo\n    col = ColumnInfo(\n       _table_name=lambda: \"foo\", name=\"bar\", col_type=\"TEXT\", py_type=str, primary=True, not_null=True\n    )\n    ddl = col.ddl()\n    assert ddl == '\"bar\" TEXT NOT NULL PRIMARY KEY'\n    ```\n    \"\"\"\n    args = self.args if self.args is not None else \"\"\n    default = f\"DEFAULT '{self.default}'\" if self.default is not None else \"\"\n    nullable = \"NOT NULL\" if self.not_null else \"\"\n    primary = \"PRIMARY KEY\" if self.primary else \"\"\n    reference = f'REFERENCES \"{self.ref.table_name}\"(\"{self.ref.name}\")' if self.ref is not None else \"\"\n    on_delete = f\"ON DELETE {self.on_delete}\" if self.on_delete is not None else \"\"\n    text = f'\"{self.name}\" {self.col_type}{args} {default} {nullable} {primary} {reference} {on_delete}'\n    clean = \" \".join(text.split()).strip()\n    return clean\n</code></pre>"},{"location":"reference/embar/column/base/#embar.column.base.ColumnInfo.fqn","title":"<code>fqn()</code>","text":"<p>Return the Fully Qualified Name (table and column both in quotes).</p> <pre><code>from embar.column.base import ColumnInfo\ncol = ColumnInfo(\n   _table_name=lambda: \"foo\", name=\"bar\", col_type=\"TEXT\", py_type=str, primary=False, not_null=False\n)\nfqn = col.fqn()\nassert fqn == '\"foo\".\"bar\"'\n</code></pre> Source code in <code>src/embar/column/base.py</code> <pre><code>def fqn(self) -&gt; str:\n    \"\"\"\n    Return the Fully Qualified Name (table and column both in quotes).\n\n    ```python\n    from embar.column.base import ColumnInfo\n    col = ColumnInfo(\n       _table_name=lambda: \"foo\", name=\"bar\", col_type=\"TEXT\", py_type=str, primary=False, not_null=False\n    )\n    fqn = col.fqn()\n    assert fqn == '\"foo\".\"bar\"'\n    ```\n    \"\"\"\n    return f'\"{self._table_name()}\".\"{self.name}\"'\n</code></pre>"},{"location":"reference/embar/column/common/","title":"common","text":"<p>Common column types like Text, Integer, and Float.</p>"},{"location":"reference/embar/column/common/#embar.column.common.Column","title":"<code>Column</code>","text":"<p>               Bases: <code>ColumnBase</code></p> <p>The main parent class for creating columns, generic over the Python type.</p> Source code in <code>src/embar/column/common.py</code> <pre><code>class Column[T: PyType](ColumnBase):\n    \"\"\"\n    The main parent class for creating columns, generic over the Python type.\n    \"\"\"\n\n    # This is a tuple of the two values needed to generate a foreign key:\n    # - the table referred to (as a lambda as it will not be defined yet)\n    # - any on_delete option\n    _fk: tuple[Callable[[], Column[T]], OnDelete | None] | None = None\n\n    _explicit_name: str | None\n    _name: str | None\n    default: T | None  # not protected because used by Table\n    _primary: bool\n    _not_null: bool\n\n    # This is to support eg VARCHAR(100) and also NUMERIC(10, 2)\n    _extra_args: tuple[int] | tuple[int, int] | None = None\n\n    def __init__(\n        self,\n        name: str | None = None,\n        default: T | None = None,\n        primary: bool = False,\n        not_null: bool = False,\n    ):\n        \"\"\"\n        Create a new Column instance.\n        \"\"\"\n        self._name = name\n        # if no _explicit_name, one is created automatically (see __set_name__)\n        self._explicit_name = name\n        self.default = default\n        self._primary = primary\n        self._not_null = not_null\n\n    @overload\n    def __get__(self, obj: None, owner: type) -&gt; Self: ...\n    @overload\n    def __get__(self, obj: object, owner: type) -&gt; T: ...\n\n    def __get__(self, obj: object | None, owner: type) -&gt; Self | T:\n        \"\"\"\n        This allows this class to be typed as itself in Table definitions\n        but as `T` in object instances. The overloads ensure this works for typechecking too.\n\n        ```python\n        from embar.table import Table\n        from embar.column.common import Text\n        class MyTable(Table):\n            my_col: Text = Text()      # typechecked as `Text`\n        my_row = MyTable(my_col=\"foo\") # typechecked as `str`\n        assert isinstance(MyTable.my_col, Text)\n        assert isinstance(my_row.my_col, str)\n        ```\n        \"\"\"\n        if obj is None:\n            return self  # Class access returns descriptor\n        return getattr(obj, f\"_{self._name}\")  # Instance access returns str\n\n    def __set__(self, obj: object, value: T) -&gt; None:\n        \"\"\"\n        Allows values of type T (rather than `Column[T]`) to be assigned to this class when it's a field of an object.\n        \"\"\"\n        setattr(obj, f\"_{self._name}\", value)\n\n    def __set_name__(self, owner: Any, attr_name: str) -&gt; None:\n        \"\"\"\n        Called after the class body has executed, when the owning `Table` is being created.\n\n        This is needed so that each `Column` can be told what the owning table's name is.\n        \"\"\"\n        self._name = self._explicit_name if self._explicit_name is not None else attr_name\n        self.info: ColumnInfo = ColumnInfo(\n            name=self._name,\n            col_type=self._sql_type,\n            py_type=self._py_type,\n            primary=self._primary,\n            not_null=self._not_null,\n            default=self.default,\n            # This is passed a function, not a value.\n            # Becuase in cases where the Table doesn't have an explicit name set, its name still\n            # won't be known yet.\n            _table_name=owner.get_name,\n        )\n        if self._fk is not None:\n            ref, on_delete = self._fk\n            self.info.ref = ref().info\n            self.info.on_delete = on_delete\n\n        if self._sql_type in SQL_TYPES_WITH_ARGS and self._extra_args is not None:\n            args = \", \".join(str(x) for x in self._extra_args)\n            self.info.args = f\"({args})\"\n\n    def fk(\n        self,\n        ref: Callable[[], Column[T]],\n        on_delete: OnDelete | None = None,\n    ) -&gt; Self:\n        \"\"\"\n        Create a foreign key reference to another table.\n        \"\"\"\n        self._fk = (ref, on_delete)\n        return self\n\n    def many(self) -&gt; ManyColumn[Self]:\n        \"\"\"\n        Used to nest many values of this column in a model.\n\n        ```python\n        from typing import Annotated\n        from pydantic import BaseModel\n        from embar.column.common import Text\n        from embar.table import Table\n        class MyTable(Table):\n            my_col: Text = Text()\n        class MyModel(BaseModel):\n            values: Annotated[list[str], MyTable.my_col.many()]\n        ```\n        \"\"\"\n        return ManyColumn[Self](self)\n</code></pre>"},{"location":"reference/embar/column/common/#embar.column.common.Column.__get__","title":"<code>__get__(obj, owner)</code>","text":"<pre><code>__get__(obj: None, owner: type) -&gt; Self\n</code></pre><pre><code>__get__(obj: object, owner: type) -&gt; T\n</code></pre> <p>This allows this class to be typed as itself in Table definitions but as <code>T</code> in object instances. The overloads ensure this works for typechecking too.</p> <pre><code>from embar.table import Table\nfrom embar.column.common import Text\nclass MyTable(Table):\n    my_col: Text = Text()      # typechecked as `Text`\nmy_row = MyTable(my_col=\"foo\") # typechecked as `str`\nassert isinstance(MyTable.my_col, Text)\nassert isinstance(my_row.my_col, str)\n</code></pre> Source code in <code>src/embar/column/common.py</code> <pre><code>def __get__(self, obj: object | None, owner: type) -&gt; Self | T:\n    \"\"\"\n    This allows this class to be typed as itself in Table definitions\n    but as `T` in object instances. The overloads ensure this works for typechecking too.\n\n    ```python\n    from embar.table import Table\n    from embar.column.common import Text\n    class MyTable(Table):\n        my_col: Text = Text()      # typechecked as `Text`\n    my_row = MyTable(my_col=\"foo\") # typechecked as `str`\n    assert isinstance(MyTable.my_col, Text)\n    assert isinstance(my_row.my_col, str)\n    ```\n    \"\"\"\n    if obj is None:\n        return self  # Class access returns descriptor\n    return getattr(obj, f\"_{self._name}\")  # Instance access returns str\n</code></pre>"},{"location":"reference/embar/column/common/#embar.column.common.Column.__init__","title":"<code>__init__(name=None, default=None, primary=False, not_null=False)</code>","text":"<p>Create a new Column instance.</p> Source code in <code>src/embar/column/common.py</code> <pre><code>def __init__(\n    self,\n    name: str | None = None,\n    default: T | None = None,\n    primary: bool = False,\n    not_null: bool = False,\n):\n    \"\"\"\n    Create a new Column instance.\n    \"\"\"\n    self._name = name\n    # if no _explicit_name, one is created automatically (see __set_name__)\n    self._explicit_name = name\n    self.default = default\n    self._primary = primary\n    self._not_null = not_null\n</code></pre>"},{"location":"reference/embar/column/common/#embar.column.common.Column.__set__","title":"<code>__set__(obj, value)</code>","text":"<p>Allows values of type T (rather than <code>Column[T]</code>) to be assigned to this class when it's a field of an object.</p> Source code in <code>src/embar/column/common.py</code> <pre><code>def __set__(self, obj: object, value: T) -&gt; None:\n    \"\"\"\n    Allows values of type T (rather than `Column[T]`) to be assigned to this class when it's a field of an object.\n    \"\"\"\n    setattr(obj, f\"_{self._name}\", value)\n</code></pre>"},{"location":"reference/embar/column/common/#embar.column.common.Column.__set_name__","title":"<code>__set_name__(owner, attr_name)</code>","text":"<p>Called after the class body has executed, when the owning <code>Table</code> is being created.</p> <p>This is needed so that each <code>Column</code> can be told what the owning table's name is.</p> Source code in <code>src/embar/column/common.py</code> <pre><code>def __set_name__(self, owner: Any, attr_name: str) -&gt; None:\n    \"\"\"\n    Called after the class body has executed, when the owning `Table` is being created.\n\n    This is needed so that each `Column` can be told what the owning table's name is.\n    \"\"\"\n    self._name = self._explicit_name if self._explicit_name is not None else attr_name\n    self.info: ColumnInfo = ColumnInfo(\n        name=self._name,\n        col_type=self._sql_type,\n        py_type=self._py_type,\n        primary=self._primary,\n        not_null=self._not_null,\n        default=self.default,\n        # This is passed a function, not a value.\n        # Becuase in cases where the Table doesn't have an explicit name set, its name still\n        # won't be known yet.\n        _table_name=owner.get_name,\n    )\n    if self._fk is not None:\n        ref, on_delete = self._fk\n        self.info.ref = ref().info\n        self.info.on_delete = on_delete\n\n    if self._sql_type in SQL_TYPES_WITH_ARGS and self._extra_args is not None:\n        args = \", \".join(str(x) for x in self._extra_args)\n        self.info.args = f\"({args})\"\n</code></pre>"},{"location":"reference/embar/column/common/#embar.column.common.Column.fk","title":"<code>fk(ref, on_delete=None)</code>","text":"<p>Create a foreign key reference to another table.</p> Source code in <code>src/embar/column/common.py</code> <pre><code>def fk(\n    self,\n    ref: Callable[[], Column[T]],\n    on_delete: OnDelete | None = None,\n) -&gt; Self:\n    \"\"\"\n    Create a foreign key reference to another table.\n    \"\"\"\n    self._fk = (ref, on_delete)\n    return self\n</code></pre>"},{"location":"reference/embar/column/common/#embar.column.common.Column.many","title":"<code>many()</code>","text":"<p>Used to nest many values of this column in a model.</p> <pre><code>from typing import Annotated\nfrom pydantic import BaseModel\nfrom embar.column.common import Text\nfrom embar.table import Table\nclass MyTable(Table):\n    my_col: Text = Text()\nclass MyModel(BaseModel):\n    values: Annotated[list[str], MyTable.my_col.many()]\n</code></pre> Source code in <code>src/embar/column/common.py</code> <pre><code>def many(self) -&gt; ManyColumn[Self]:\n    \"\"\"\n    Used to nest many values of this column in a model.\n\n    ```python\n    from typing import Annotated\n    from pydantic import BaseModel\n    from embar.column.common import Text\n    from embar.table import Table\n    class MyTable(Table):\n        my_col: Text = Text()\n    class MyModel(BaseModel):\n        values: Annotated[list[str], MyTable.my_col.many()]\n    ```\n    \"\"\"\n    return ManyColumn[Self](self)\n</code></pre>"},{"location":"reference/embar/column/common/#embar.column.common.Float","title":"<code>Float</code>","text":"<p>               Bases: <code>Column[float]</code></p> <p>A floating point column type.</p> Source code in <code>src/embar/column/common.py</code> <pre><code>class Float(Column[float]):\n    \"\"\"\n    A floating point column type.\n    \"\"\"\n\n    _sql_type: str = \"REAL\"\n    _py_type: Type = float\n</code></pre>"},{"location":"reference/embar/column/common/#embar.column.common.Integer","title":"<code>Integer</code>","text":"<p>               Bases: <code>Column[int]</code></p> <p>An integer column type.</p> Source code in <code>src/embar/column/common.py</code> <pre><code>class Integer(Column[int]):\n    \"\"\"\n    An integer column type.\n    \"\"\"\n\n    _sql_type: str = \"INTEGER\"\n    _py_type: Type = int\n</code></pre>"},{"location":"reference/embar/column/common/#embar.column.common.Text","title":"<code>Text</code>","text":"<p>               Bases: <code>Column[str]</code></p> <p>A text column type.</p> Source code in <code>src/embar/column/common.py</code> <pre><code>class Text(Column[str]):\n    \"\"\"\n    A text column type.\n    \"\"\"\n\n    _sql_type: str = \"TEXT\"\n    _py_type: Type = str\n</code></pre>"},{"location":"reference/embar/column/pg/","title":"pg","text":"<p>Postgres-specific column types.</p>"},{"location":"reference/embar/column/pg/#embar.column.pg.BigInt","title":"<code>BigInt</code>","text":"<p>               Bases: <code>Column[int]</code></p> <p>Big integer column type.</p> Source code in <code>src/embar/column/pg.py</code> <pre><code>class BigInt(Column[int]):\n    \"\"\"\n    Big integer column type.\n    \"\"\"\n\n    _sql_type: str = \"BIGINT\"\n    _py_type: Type = int\n</code></pre>"},{"location":"reference/embar/column/pg/#embar.column.pg.BigSerial","title":"<code>BigSerial</code>","text":"<p>               Bases: <code>Column[int]</code></p> <p>Auto-incrementing big integer column.</p> Source code in <code>src/embar/column/pg.py</code> <pre><code>class BigSerial(Column[int]):\n    \"\"\"\n    Auto-incrementing big integer column.\n    \"\"\"\n\n    _sql_type: str = \"BIGSERIAL\"\n    _py_type: Type = int\n</code></pre>"},{"location":"reference/embar/column/pg/#embar.column.pg.Boolean","title":"<code>Boolean</code>","text":"<p>               Bases: <code>Column[bool]</code></p> <p>Boolean column type.</p> Source code in <code>src/embar/column/pg.py</code> <pre><code>class Boolean(Column[bool]):\n    \"\"\"\n    Boolean column type.\n    \"\"\"\n\n    _sql_type: str = \"BOOLEAN\"\n    _py_type: Type = bool\n</code></pre>"},{"location":"reference/embar/column/pg/#embar.column.pg.Char","title":"<code>Char</code>","text":"<p>               Bases: <code>Column[str]</code></p> <p>Fixed-length character column type.</p> Source code in <code>src/embar/column/pg.py</code> <pre><code>class Char(Column[str]):\n    \"\"\"\n    Fixed-length character column type.\n    \"\"\"\n\n    _sql_type: str = \"CHAR\"\n    _py_type: Type = str\n\n    def __init__(\n        self,\n        name: str | None = None,\n        default: str | None = None,\n        primary: bool = False,\n        not_null: bool = False,\n        length: int | None = None,\n    ):\n        \"\"\"\n        Create a new Char instance.\n        \"\"\"\n        self._extra_args: tuple[int] | tuple[int, int] | None = (length,) if length is not None else None\n        super().__init__(name=name, default=default, primary=primary, not_null=not_null)\n</code></pre>"},{"location":"reference/embar/column/pg/#embar.column.pg.Char.__init__","title":"<code>__init__(name=None, default=None, primary=False, not_null=False, length=None)</code>","text":"<p>Create a new Char instance.</p> Source code in <code>src/embar/column/pg.py</code> <pre><code>def __init__(\n    self,\n    name: str | None = None,\n    default: str | None = None,\n    primary: bool = False,\n    not_null: bool = False,\n    length: int | None = None,\n):\n    \"\"\"\n    Create a new Char instance.\n    \"\"\"\n    self._extra_args: tuple[int] | tuple[int, int] | None = (length,) if length is not None else None\n    super().__init__(name=name, default=default, primary=primary, not_null=not_null)\n</code></pre>"},{"location":"reference/embar/column/pg/#embar.column.pg.Date","title":"<code>Date</code>","text":"<p>               Bases: <code>Column[date]</code></p> <p>Date column type.</p> Source code in <code>src/embar/column/pg.py</code> <pre><code>class Date(Column[date]):\n    \"\"\"\n    Date column type.\n    \"\"\"\n\n    _sql_type: str = \"DATE\"\n    _py_type: Type = date\n</code></pre>"},{"location":"reference/embar/column/pg/#embar.column.pg.DoublePrecision","title":"<code>DoublePrecision</code>","text":"<p>               Bases: <code>Column[float]</code></p> <p>Double precision floating point column type.</p> Source code in <code>src/embar/column/pg.py</code> <pre><code>class DoublePrecision(Column[float]):\n    \"\"\"\n    Double precision floating point column type.\n    \"\"\"\n\n    _sql_type: str = \"DOUBLE PRECISION\"\n    _py_type: Type = float\n</code></pre>"},{"location":"reference/embar/column/pg/#embar.column.pg.EmbarEnum","title":"<code>EmbarEnum</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p><code>EmbarEnum</code> is just a regular Enum but without having to set the right side.</p> <pre><code>from enum import auto\nfrom embar.column.pg import EmbarEnum\nclass StatusEnum(EmbarEnum):\n   PENDING = auto()\n   DONE = auto()\n</code></pre> Source code in <code>src/embar/column/pg.py</code> <pre><code>class EmbarEnum(str, Enum):\n    \"\"\"\n    `EmbarEnum` is just a regular Enum but without having to set the right side.\n\n    ```python\n    from enum import auto\n    from embar.column.pg import EmbarEnum\n    class StatusEnum(EmbarEnum):\n       PENDING = auto()\n       DONE = auto()\n    ```\n    \"\"\"\n\n    @staticmethod\n    @override\n    def _generate_next_value_(name: str, start: int, count: int, last_values: list[Any]) -&gt; str:\n        return name\n</code></pre>"},{"location":"reference/embar/column/pg/#embar.column.pg.EnumCol","title":"<code>EnumCol</code>","text":"<p>               Bases: <code>Column[str]</code></p> <p>Column type for Postgres enum values.</p> Source code in <code>src/embar/column/pg.py</code> <pre><code>class EnumCol[E: EmbarEnum](Column[str]):\n    \"\"\"\n    Column type for Postgres enum values.\n    \"\"\"\n\n    _sql_type: str\n    _py_type: Type = str\n\n    def __init__(\n        self,\n        pg_enum: type[PgEnum[E]],\n        name: str | None = None,\n        default: E | None = None,\n        primary: bool = False,\n        not_null: bool = False,\n    ):\n        \"\"\"\n        Create a new EnumCol instance.\n        \"\"\"\n        self._sql_type = pg_enum.name\n\n        super().__init__(name=name, default=default, primary=primary, not_null=not_null)\n</code></pre>"},{"location":"reference/embar/column/pg/#embar.column.pg.EnumCol.__init__","title":"<code>__init__(pg_enum, name=None, default=None, primary=False, not_null=False)</code>","text":"<p>Create a new EnumCol instance.</p> Source code in <code>src/embar/column/pg.py</code> <pre><code>def __init__(\n    self,\n    pg_enum: type[PgEnum[E]],\n    name: str | None = None,\n    default: E | None = None,\n    primary: bool = False,\n    not_null: bool = False,\n):\n    \"\"\"\n    Create a new EnumCol instance.\n    \"\"\"\n    self._sql_type = pg_enum.name\n\n    super().__init__(name=name, default=default, primary=primary, not_null=not_null)\n</code></pre>"},{"location":"reference/embar/column/pg/#embar.column.pg.Float","title":"<code>Float</code>","text":"<p>               Bases: <code>Column[float]</code></p> <p>A floating point column type.</p> Source code in <code>src/embar/column/common.py</code> <pre><code>class Float(Column[float]):\n    \"\"\"\n    A floating point column type.\n    \"\"\"\n\n    _sql_type: str = \"REAL\"\n    _py_type: Type = float\n</code></pre>"},{"location":"reference/embar/column/pg/#embar.column.pg.Integer","title":"<code>Integer</code>","text":"<p>               Bases: <code>Column[int]</code></p> <p>An integer column type.</p> Source code in <code>src/embar/column/common.py</code> <pre><code>class Integer(Column[int]):\n    \"\"\"\n    An integer column type.\n    \"\"\"\n\n    _sql_type: str = \"INTEGER\"\n    _py_type: Type = int\n</code></pre>"},{"location":"reference/embar/column/pg/#embar.column.pg.Interval","title":"<code>Interval</code>","text":"<p>               Bases: <code>Column[timedelta]</code></p> <p>Interval column type for storing time intervals.</p> Source code in <code>src/embar/column/pg.py</code> <pre><code>class Interval(Column[timedelta]):\n    \"\"\"\n    Interval column type for storing time intervals.\n    \"\"\"\n\n    _sql_type: str = \"INTERVAL\"\n    _py_type: Type = timedelta\n</code></pre>"},{"location":"reference/embar/column/pg/#embar.column.pg.Json","title":"<code>Json</code>","text":"<p>               Bases: <code>Column[dict[str, Any]]</code></p> <p>JSON column type for storing JSON data.</p> Source code in <code>src/embar/column/pg.py</code> <pre><code>class Json(Column[dict[str, Any]]):\n    \"\"\"\n    JSON column type for storing JSON data.\n    \"\"\"\n\n    _sql_type: str = \"JSON\"\n    _py_type: Type = dict[str, Any]\n</code></pre>"},{"location":"reference/embar/column/pg/#embar.column.pg.Jsonb","title":"<code>Jsonb</code>","text":"<p>               Bases: <code>Column[dict[str, Any]]</code></p> <p>JSONB column type for storing JSON data.</p> Source code in <code>src/embar/column/pg.py</code> <pre><code>class Jsonb(Column[dict[str, Any]]):\n    \"\"\"\n    JSONB column type for storing JSON data.\n    \"\"\"\n\n    _sql_type: str = \"JSONB\"\n    _py_type: Type = dict[str, Any]\n</code></pre>"},{"location":"reference/embar/column/pg/#embar.column.pg.Numeric","title":"<code>Numeric</code>","text":"<p>               Bases: <code>Column[Decimal]</code></p> <p>Numeric column type with configurable precision and scale.</p> Source code in <code>src/embar/column/pg.py</code> <pre><code>class Numeric(Column[Decimal]):\n    \"\"\"\n    Numeric column type with configurable precision and scale.\n    \"\"\"\n\n    _sql_type: str = \"NUMERIC\"\n    _py_type: Type = Decimal\n\n    _extra_args: tuple[int] | tuple[int, int] | None\n\n    def __init__(\n        self,\n        name: str | None = None,\n        default: Decimal | None = None,\n        primary: bool = False,\n        not_null: bool = False,\n        precision: int | None = None,\n        scale: int | None = None,\n    ):\n        \"\"\"\n        Create a new Numeric instance.\n        \"\"\"\n        if precision is None:\n            if scale is not None:\n                raise Exception(\"Numeric: 'precision' cannot be None if scale is set\")\n        elif scale is None:\n            self._extra_args = (precision,)\n        else:\n            self._extra_args = (precision, scale)\n        super().__init__(name=name, default=default, primary=primary, not_null=not_null)\n</code></pre>"},{"location":"reference/embar/column/pg/#embar.column.pg.Numeric.__init__","title":"<code>__init__(name=None, default=None, primary=False, not_null=False, precision=None, scale=None)</code>","text":"<p>Create a new Numeric instance.</p> Source code in <code>src/embar/column/pg.py</code> <pre><code>def __init__(\n    self,\n    name: str | None = None,\n    default: Decimal | None = None,\n    primary: bool = False,\n    not_null: bool = False,\n    precision: int | None = None,\n    scale: int | None = None,\n):\n    \"\"\"\n    Create a new Numeric instance.\n    \"\"\"\n    if precision is None:\n        if scale is not None:\n            raise Exception(\"Numeric: 'precision' cannot be None if scale is set\")\n    elif scale is None:\n        self._extra_args = (precision,)\n    else:\n        self._extra_args = (precision, scale)\n    super().__init__(name=name, default=default, primary=primary, not_null=not_null)\n</code></pre>"},{"location":"reference/embar/column/pg/#embar.column.pg.PgDecimal","title":"<code>PgDecimal</code>","text":"<p>               Bases: <code>Column[Decimal]</code></p> <p>Decimal column type with configurable precision and scale.</p> Source code in <code>src/embar/column/pg.py</code> <pre><code>class PgDecimal(Column[Decimal]):\n    \"\"\"\n    Decimal column type with configurable precision and scale.\n    \"\"\"\n\n    # Note: DECIMAL is an alias for NUMERIC in PostgreSQL\n    _sql_type: str = \"DECIMAL\"\n    _py_type: Type = Decimal\n\n    _extra_args: tuple[int] | tuple[int, int] | None\n\n    def __init__(\n        self,\n        name: str | None = None,\n        default: Decimal | None = None,\n        primary: bool = False,\n        not_null: bool = False,\n        precision: int | None = None,\n        scale: int | None = None,\n    ):\n        \"\"\"\n        Create a new PgDecimal instance.\n        \"\"\"\n        if precision is None:\n            if scale is not None:\n                raise Exception(\"Numeric: 'precision' cannot be None if scale is set\")\n        elif scale is None:\n            self._extra_args = (precision,)\n        else:\n            self._extra_args = (precision, scale)\n        super().__init__(name=name, default=default, primary=primary, not_null=not_null)\n</code></pre>"},{"location":"reference/embar/column/pg/#embar.column.pg.PgDecimal.__init__","title":"<code>__init__(name=None, default=None, primary=False, not_null=False, precision=None, scale=None)</code>","text":"<p>Create a new PgDecimal instance.</p> Source code in <code>src/embar/column/pg.py</code> <pre><code>def __init__(\n    self,\n    name: str | None = None,\n    default: Decimal | None = None,\n    primary: bool = False,\n    not_null: bool = False,\n    precision: int | None = None,\n    scale: int | None = None,\n):\n    \"\"\"\n    Create a new PgDecimal instance.\n    \"\"\"\n    if precision is None:\n        if scale is not None:\n            raise Exception(\"Numeric: 'precision' cannot be None if scale is set\")\n    elif scale is None:\n        self._extra_args = (precision,)\n    else:\n        self._extra_args = (precision, scale)\n    super().__init__(name=name, default=default, primary=primary, not_null=not_null)\n</code></pre>"},{"location":"reference/embar/column/pg/#embar.column.pg.PgEnum","title":"<code>PgEnum</code>","text":"<p>               Bases: <code>EnumBase</code></p> <p>`PgEnum is used to create Postgres enum types.</p> <p>Subclasses must always assign values to the two class variables!</p> <pre><code>from enum import auto\nfrom embar.table import Table\nfrom embar.column.pg import EmbarEnum, EnumCol, PgEnum\nclass StatusEnum(EmbarEnum):\n   PENDING = auto()\n   DONE = auto()\nclass StatusPgEnum(PgEnum[StatusEnum]):\n    name: str = \"status_enum\"\n    enum: type[StatusEnum] = StatusEnum\nclass TableWithStatus(Table):\n    status: EnumCol[StatusEnum] = EnumCol(StatusPgEnum)\n</code></pre> Source code in <code>src/embar/column/pg.py</code> <pre><code>class PgEnum[E: EmbarEnum](EnumBase):\n    \"\"\"\n    `PgEnum is used to create Postgres enum types.\n\n    Subclasses must always assign values to the two class variables!\n\n    ```python\n    from enum import auto\n    from embar.table import Table\n    from embar.column.pg import EmbarEnum, EnumCol, PgEnum\n    class StatusEnum(EmbarEnum):\n       PENDING = auto()\n       DONE = auto()\n    class StatusPgEnum(PgEnum[StatusEnum]):\n        name: str = \"status_enum\"\n        enum: type[StatusEnum] = StatusEnum\n    class TableWithStatus(Table):\n        status: EnumCol[StatusEnum] = EnumCol(StatusPgEnum)\n    ```\n    \"\"\"\n\n    name: str\n    enum: type[E]\n\n    @override\n    @classmethod\n    def ddl(cls) -&gt; str:\n        quoted = [f\"'{e.name}'\" for e in cls.enum]\n        values = \", \".join(quoted)\n        sql = f\"CREATE TYPE {cls.name} AS ENUM ({values});\"\n        return sql\n</code></pre>"},{"location":"reference/embar/column/pg/#embar.column.pg.Serial","title":"<code>Serial</code>","text":"<p>               Bases: <code>Column[int]</code></p> <p>Auto-incrementing integer column.</p> Source code in <code>src/embar/column/pg.py</code> <pre><code>class Serial(Column[int]):\n    \"\"\"\n    Auto-incrementing integer column.\n    \"\"\"\n\n    _sql_type: str = \"SERIAL\"\n    _py_type: Type = int\n</code></pre>"},{"location":"reference/embar/column/pg/#embar.column.pg.SmallInt","title":"<code>SmallInt</code>","text":"<p>               Bases: <code>Column[int]</code></p> <p>Small integer column type.</p> Source code in <code>src/embar/column/pg.py</code> <pre><code>class SmallInt(Column[int]):\n    \"\"\"\n    Small integer column type.\n    \"\"\"\n\n    _sql_type: str = \"SMALLINT\"\n    _py_type: Type = int\n</code></pre>"},{"location":"reference/embar/column/pg/#embar.column.pg.SmallSerial","title":"<code>SmallSerial</code>","text":"<p>               Bases: <code>Column[int]</code></p> <p>Auto-incrementing small integer column.</p> Source code in <code>src/embar/column/pg.py</code> <pre><code>class SmallSerial(Column[int]):\n    \"\"\"\n    Auto-incrementing small integer column.\n    \"\"\"\n\n    _sql_type: str = \"SMALLSERIAL\"\n    _py_type: Type = int\n</code></pre>"},{"location":"reference/embar/column/pg/#embar.column.pg.Text","title":"<code>Text</code>","text":"<p>               Bases: <code>Column[str]</code></p> <p>A text column type.</p> Source code in <code>src/embar/column/common.py</code> <pre><code>class Text(Column[str]):\n    \"\"\"\n    A text column type.\n    \"\"\"\n\n    _sql_type: str = \"TEXT\"\n    _py_type: Type = str\n</code></pre>"},{"location":"reference/embar/column/pg/#embar.column.pg.Time","title":"<code>Time</code>","text":"<p>               Bases: <code>Column[time]</code></p> <p>Time column type.</p> Source code in <code>src/embar/column/pg.py</code> <pre><code>class Time(Column[time]):\n    \"\"\"\n    Time column type.\n    \"\"\"\n\n    _sql_type: str = \"TIME\"\n    _py_type: Type = time\n</code></pre>"},{"location":"reference/embar/column/pg/#embar.column.pg.Timestamp","title":"<code>Timestamp</code>","text":"<p>               Bases: <code>Column[datetime]</code></p> <p>Timestamp column type.</p> Source code in <code>src/embar/column/pg.py</code> <pre><code>class Timestamp(Column[datetime]):\n    \"\"\"\n    Timestamp column type.\n    \"\"\"\n\n    _sql_type: str = \"TIMESTAMP\"\n    _py_type: Type = str\n</code></pre>"},{"location":"reference/embar/column/pg/#embar.column.pg.Varchar","title":"<code>Varchar</code>","text":"<p>               Bases: <code>Column[str]</code></p> <p>Variable-length character column type.</p> Source code in <code>src/embar/column/pg.py</code> <pre><code>class Varchar(Column[str]):\n    \"\"\"\n    Variable-length character column type.\n    \"\"\"\n\n    _sql_type: str = \"VARCHAR\"\n    _py_type: Type = str\n\n    def __init__(\n        self,\n        name: str | None = None,\n        default: str | None = None,\n        primary: bool = False,\n        not_null: bool = False,\n        length: int | None = None,\n    ):\n        \"\"\"\n        Create a new Varchar instance.\n        \"\"\"\n        self._extra_args: tuple[int] | tuple[int, int] | None = (length,) if length is not None else None\n        super().__init__(name=name, default=default, primary=primary, not_null=not_null)\n</code></pre>"},{"location":"reference/embar/column/pg/#embar.column.pg.Varchar.__init__","title":"<code>__init__(name=None, default=None, primary=False, not_null=False, length=None)</code>","text":"<p>Create a new Varchar instance.</p> Source code in <code>src/embar/column/pg.py</code> <pre><code>def __init__(\n    self,\n    name: str | None = None,\n    default: str | None = None,\n    primary: bool = False,\n    not_null: bool = False,\n    length: int | None = None,\n):\n    \"\"\"\n    Create a new Varchar instance.\n    \"\"\"\n    self._extra_args: tuple[int] | tuple[int, int] | None = (length,) if length is not None else None\n    super().__init__(name=name, default=default, primary=primary, not_null=not_null)\n</code></pre>"},{"location":"reference/embar/column/pg/#embar.column.pg.Vector","title":"<code>Vector</code>","text":"<p>               Bases: <code>Column[list[float]]</code></p> <p>Vector column using pgvector.</p> <p>This assumes the extension is already installed and activated with CREATE EXTENSION vector;</p> Source code in <code>src/embar/column/pg.py</code> <pre><code>class Vector(Column[list[float]]):\n    \"\"\"\n    Vector column using [pgvector](https://github.com/pgvector/pgvector).\n\n    This assumes the extension is already installed and activated with\n    CREATE EXTENSION vector;\n    \"\"\"\n\n    _sql_type: str = \"VECTOR\"\n    _py_type: Type = list[float]\n\n    def __init__(\n        self,\n        length: int,\n        name: str | None = None,\n        default: list[float] | None = None,\n        primary: bool = False,\n        not_null: bool = False,\n    ):\n        \"\"\"\n        Create a new Vector instance.\n        \"\"\"\n        self._extra_args: tuple[int] | tuple[int, int] | None = (length,)\n        super().__init__(name=name, default=default, primary=primary, not_null=not_null)\n</code></pre>"},{"location":"reference/embar/column/pg/#embar.column.pg.Vector.__init__","title":"<code>__init__(length, name=None, default=None, primary=False, not_null=False)</code>","text":"<p>Create a new Vector instance.</p> Source code in <code>src/embar/column/pg.py</code> <pre><code>def __init__(\n    self,\n    length: int,\n    name: str | None = None,\n    default: list[float] | None = None,\n    primary: bool = False,\n    not_null: bool = False,\n):\n    \"\"\"\n    Create a new Vector instance.\n    \"\"\"\n    self._extra_args: tuple[int] | tuple[int, int] | None = (length,)\n    super().__init__(name=name, default=default, primary=primary, not_null=not_null)\n</code></pre>"},{"location":"reference/embar/column/sqlite/","title":"sqlite","text":"<p>SQLite-specific column types.</p>"},{"location":"reference/embar/column/sqlite/#embar.column.sqlite.Blob","title":"<code>Blob</code>","text":"<p>               Bases: <code>Column[bytes]</code></p> <p>Blob column type for storing binary data.</p> Source code in <code>src/embar/column/sqlite.py</code> <pre><code>class Blob(Column[bytes]):\n    \"\"\"\n    Blob column type for storing binary data.\n    \"\"\"\n\n    _sql_type: str = \"BLOB\"\n    _py_type: Type = bytes\n</code></pre>"},{"location":"reference/embar/column/sqlite/#embar.column.sqlite.Float","title":"<code>Float</code>","text":"<p>               Bases: <code>Column[float]</code></p> <p>A floating point column type.</p> Source code in <code>src/embar/column/common.py</code> <pre><code>class Float(Column[float]):\n    \"\"\"\n    A floating point column type.\n    \"\"\"\n\n    _sql_type: str = \"REAL\"\n    _py_type: Type = float\n</code></pre>"},{"location":"reference/embar/column/sqlite/#embar.column.sqlite.Integer","title":"<code>Integer</code>","text":"<p>               Bases: <code>Column[int]</code></p> <p>An integer column type.</p> Source code in <code>src/embar/column/common.py</code> <pre><code>class Integer(Column[int]):\n    \"\"\"\n    An integer column type.\n    \"\"\"\n\n    _sql_type: str = \"INTEGER\"\n    _py_type: Type = int\n</code></pre>"},{"location":"reference/embar/column/sqlite/#embar.column.sqlite.Text","title":"<code>Text</code>","text":"<p>               Bases: <code>Column[str]</code></p> <p>A text column type.</p> Source code in <code>src/embar/column/common.py</code> <pre><code>class Text(Column[str]):\n    \"\"\"\n    A text column type.\n    \"\"\"\n\n    _sql_type: str = \"TEXT\"\n    _py_type: Type = str\n</code></pre>"},{"location":"reference/embar/db/","title":"Index","text":""},{"location":"reference/embar/db/_util/","title":"_util","text":"<p>Utilities for database migrations.</p>"},{"location":"reference/embar/db/_util/#embar.db._util.get_migration_defs","title":"<code>get_migration_defs(schema)</code>","text":"<p>Extract all table and enum definitions from a schema module.</p> Source code in <code>src/embar/db/_util.py</code> <pre><code>def get_migration_defs(schema: ModuleType) -&gt; MigrationDefs:\n    \"\"\"\n    Extract all table and enum definitions from a schema module.\n    \"\"\"\n    enums: list[type[EnumBase]] = []\n    tables: list[type[Table]] = []\n    for name in dir(schema):\n        obj = getattr(schema, name)\n        # Check if it's a class and inherits from Table\n        if isinstance(obj, type) and issubclass(obj, Table) and obj is not Table:\n            tables.append(obj)\n        if isinstance(obj, type) and issubclass(obj, EnumBase) and obj is not EnumBase:\n            enums.append(obj)\n    return MigrationDefs(enums=enums, tables=tables)\n</code></pre>"},{"location":"reference/embar/db/_util/#embar.db._util.merge_ddls","title":"<code>merge_ddls(defs)</code>","text":"<p>Convert migration definitions to DDL statements in dependency order.</p> Source code in <code>src/embar/db/_util.py</code> <pre><code>def merge_ddls(defs: MigrationDefs) -&gt; list[Ddl]:\n    \"\"\"\n    Convert migration definitions to DDL statements in dependency order.\n    \"\"\"\n    queries: list[Ddl] = []\n    for enum in defs.enums:\n        queries.append(Ddl(name=enum.name, ddl=enum.ddl()))\n\n    tables = _topological_sort_tables(defs.tables)\n    for table in tables:\n        constraints: list[str] = []\n        for constraint in table.embar_config.constraints:\n            constraints.append(constraint.sql().merged())\n        queries.append(Ddl(name=table.get_name(), ddl=table.ddl(), constraints=constraints))\n\n    return queries\n</code></pre>"},{"location":"reference/embar/db/base/","title":"base","text":"<p>Base classes for database clients.</p>"},{"location":"reference/embar/db/base/#embar.db.base.AllDbBase","title":"<code>AllDbBase</code>","text":"<p>Base class (not an ABC, but could be) for all Db clients.</p> Source code in <code>src/embar/db/base.py</code> <pre><code>class AllDbBase:\n    \"\"\"\n    Base class (not an ABC, but could be) for all Db clients.\n    \"\"\"\n\n    db_type: DbType = Undefined\n</code></pre>"},{"location":"reference/embar/db/base/#embar.db.base.AsyncDbBase","title":"<code>AsyncDbBase</code>","text":"<p>               Bases: <code>ABC</code>, <code>AllDbBase</code></p> <p>Base class for async Db clients.</p> Source code in <code>src/embar/db/base.py</code> <pre><code>class AsyncDbBase(ABC, AllDbBase):\n    \"\"\"\n    Base class for async Db clients.\n    \"\"\"\n\n    @abstractmethod\n    async def execute(self, query: QuerySingle):\n        \"\"\"\n        Execute a query without returning results.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    async def executemany(self, query: QueryMany):\n        \"\"\"\n        Execute a query with multiple parameter sets.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    async def fetch(self, query: QuerySingle | QueryMany) -&gt; list[dict[str, Any]]:\n        \"\"\"\n        Execute a query and return results as a list of dicts.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    async def truncate(self, schema: str | None = None) -&gt; None:\n        \"\"\"\n        Truncate all tables in the schema.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    async def drop_tables(self, schema: str | None = None) -&gt; None:\n        \"\"\"\n        Drop all tables in the schema.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"reference/embar/db/base/#embar.db.base.AsyncDbBase.drop_tables","title":"<code>drop_tables(schema=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Drop all tables in the schema.</p> Source code in <code>src/embar/db/base.py</code> <pre><code>@abstractmethod\nasync def drop_tables(self, schema: str | None = None) -&gt; None:\n    \"\"\"\n    Drop all tables in the schema.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/embar/db/base/#embar.db.base.AsyncDbBase.execute","title":"<code>execute(query)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Execute a query without returning results.</p> Source code in <code>src/embar/db/base.py</code> <pre><code>@abstractmethod\nasync def execute(self, query: QuerySingle):\n    \"\"\"\n    Execute a query without returning results.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/embar/db/base/#embar.db.base.AsyncDbBase.executemany","title":"<code>executemany(query)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Execute a query with multiple parameter sets.</p> Source code in <code>src/embar/db/base.py</code> <pre><code>@abstractmethod\nasync def executemany(self, query: QueryMany):\n    \"\"\"\n    Execute a query with multiple parameter sets.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/embar/db/base/#embar.db.base.AsyncDbBase.fetch","title":"<code>fetch(query)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Execute a query and return results as a list of dicts.</p> Source code in <code>src/embar/db/base.py</code> <pre><code>@abstractmethod\nasync def fetch(self, query: QuerySingle | QueryMany) -&gt; list[dict[str, Any]]:\n    \"\"\"\n    Execute a query and return results as a list of dicts.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/embar/db/base/#embar.db.base.AsyncDbBase.truncate","title":"<code>truncate(schema=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Truncate all tables in the schema.</p> Source code in <code>src/embar/db/base.py</code> <pre><code>@abstractmethod\nasync def truncate(self, schema: str | None = None) -&gt; None:\n    \"\"\"\n    Truncate all tables in the schema.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/embar/db/base/#embar.db.base.DbBase","title":"<code>DbBase</code>","text":"<p>               Bases: <code>ABC</code>, <code>AllDbBase</code></p> <p>Base class for sync Db clients.</p> Source code in <code>src/embar/db/base.py</code> <pre><code>class DbBase(ABC, AllDbBase):\n    \"\"\"\n    Base class for _sync_ Db clients.\n    \"\"\"\n\n    @abstractmethod\n    def execute(self, query: QuerySingle):\n        \"\"\"\n        Execute a query without returning results.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def executemany(self, query: QueryMany):\n        \"\"\"\n        Execute a query with multiple parameter sets.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def fetch(self, query: QuerySingle | QueryMany) -&gt; list[dict[str, Any]]:\n        \"\"\"\n        Execute a query and return results as a list of dicts.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def truncate(self, schema: str | None = None) -&gt; None:\n        \"\"\"\n        Truncate all tables in the schema.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def drop_tables(self, schema: str | None = None) -&gt; None:\n        \"\"\"\n        Drop all tables in the schema.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"reference/embar/db/base/#embar.db.base.DbBase.drop_tables","title":"<code>drop_tables(schema=None)</code>  <code>abstractmethod</code>","text":"<p>Drop all tables in the schema.</p> Source code in <code>src/embar/db/base.py</code> <pre><code>@abstractmethod\ndef drop_tables(self, schema: str | None = None) -&gt; None:\n    \"\"\"\n    Drop all tables in the schema.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/embar/db/base/#embar.db.base.DbBase.execute","title":"<code>execute(query)</code>  <code>abstractmethod</code>","text":"<p>Execute a query without returning results.</p> Source code in <code>src/embar/db/base.py</code> <pre><code>@abstractmethod\ndef execute(self, query: QuerySingle):\n    \"\"\"\n    Execute a query without returning results.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/embar/db/base/#embar.db.base.DbBase.executemany","title":"<code>executemany(query)</code>  <code>abstractmethod</code>","text":"<p>Execute a query with multiple parameter sets.</p> Source code in <code>src/embar/db/base.py</code> <pre><code>@abstractmethod\ndef executemany(self, query: QueryMany):\n    \"\"\"\n    Execute a query with multiple parameter sets.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/embar/db/base/#embar.db.base.DbBase.fetch","title":"<code>fetch(query)</code>  <code>abstractmethod</code>","text":"<p>Execute a query and return results as a list of dicts.</p> Source code in <code>src/embar/db/base.py</code> <pre><code>@abstractmethod\ndef fetch(self, query: QuerySingle | QueryMany) -&gt; list[dict[str, Any]]:\n    \"\"\"\n    Execute a query and return results as a list of dicts.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/embar/db/base/#embar.db.base.DbBase.truncate","title":"<code>truncate(schema=None)</code>  <code>abstractmethod</code>","text":"<p>Truncate all tables in the schema.</p> Source code in <code>src/embar/db/base.py</code> <pre><code>@abstractmethod\ndef truncate(self, schema: str | None = None) -&gt; None:\n    \"\"\"\n    Truncate all tables in the schema.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/embar/db/pg/","title":"pg","text":"<p>Postgres database clients for sync and async operations.</p>"},{"location":"reference/embar/db/pg/#embar.db.pg.AsyncPgDb","title":"<code>AsyncPgDb</code>","text":"<p>               Bases: <code>AsyncDbBase</code></p> <p>Postgres database client for async operations.</p> Source code in <code>src/embar/db/pg.py</code> <pre><code>@final\nclass AsyncPgDb(AsyncDbBase):\n    \"\"\"\n    Postgres database client for async operations.\n    \"\"\"\n\n    db_type = \"postgres\"\n    conn_wrapper: AsyncConnectionWrapper[AsyncConnection | AsyncConnectionPool]\n    _commit_after_execute: bool = True\n\n    def __init__(self, connection_or_pool: AsyncConnection | AsyncConnectionPool):\n        \"\"\"\n        Create a new AsyncPgDb instance.\n        \"\"\"\n        self.conn_wrapper = AsyncConnectionWrapper(connection_or_pool)\n\n    async def close(self):\n        \"\"\"\n        Close the database connection.\n        \"\"\"\n        if self.conn_wrapper:\n            await self.conn_wrapper.close()\n\n    def transaction(self) -&gt; AsyncPgDbTransaction:\n        \"\"\"\n        Start an isolated transaction.\n\n        ```python notest\n        from embar.db.pg import AsyncPgDb\n        db = AsyncPgDb(None)\n\n        async with db.transaction() as tx:\n            ...\n        ```\n        \"\"\"\n        return AsyncPgDbTransaction(self)\n\n    def select[M: BaseModel](self, model: type[M]) -&gt; SelectQuery[M, Self]:\n        \"\"\"\n        Create a SELECT query.\n        \"\"\"\n        return SelectQuery[M, Self](db=self, model=model)\n\n    def select_distinct[M: BaseModel](self, model: type[M]) -&gt; SelectDistinctQuery[M, Self]:\n        \"\"\"\n        Create a SELECT query.\n        \"\"\"\n        return SelectDistinctQuery[M, Self](db=self, model=model)\n\n    def insert[T: Table](self, table: type[T]) -&gt; InsertQuery[T, Self]:\n        \"\"\"\n        Create an INSERT query.\n        \"\"\"\n        return InsertQuery[T, Self](table=table, db=self)\n\n    def update[T: Table](self, table: type[T]) -&gt; UpdateQuery[T, Self]:\n        \"\"\"\n        Create an UPDATE query.\n        \"\"\"\n        return UpdateQuery[T, Self](table=table, db=self)\n\n    def delete[T: Table](self, table: type[T]) -&gt; DeleteQueryReady[T, Self]:\n        \"\"\"\n        Create an UPDATE query.\n        \"\"\"\n        return DeleteQueryReady[T, Self](table=table, db=self)\n\n    def sql(self, template: Template) -&gt; DbSql[Self]:\n        \"\"\"\n        Execute a raw SQL query using template strings.\n        \"\"\"\n        return DbSql(template, self)\n\n    def migrate(self, tables: Sequence[type[Table]], enums: Sequence[type[EnumBase]] | None = None) -&gt; Migration[Self]:\n        \"\"\"\n        Create a migration from a list of tables.\n        \"\"\"\n        ddls = merge_ddls(MigrationDefs(tables, enums))\n        return Migration(ddls, self)\n\n    def migrates(self, schema: types.ModuleType) -&gt; Migration[Self]:\n        \"\"\"\n        Create a migration from a schema module.\n        \"\"\"\n        defs = get_migration_defs(schema)\n        return self.migrate(defs.tables, defs.enums)\n\n    @override\n    async def execute(self, query: QuerySingle) -&gt; None:\n        \"\"\"\n        Execute a query without returning results.\n        \"\"\"\n        async with self.conn_wrapper as conn:\n            await conn.execute(query.sql, query.params)  # pyright:ignore[reportArgumentType]\n            if self._commit_after_execute:\n                await conn.commit()\n\n    @override\n    async def executemany(self, query: QueryMany):\n        \"\"\"\n        Execute a query with multiple parameter sets.\n        \"\"\"\n        params = _jsonify_dicts(query.many_params)\n        async with self.conn_wrapper as conn:\n            async with conn.cursor() as cur:\n                await cur.executemany(query.sql, params)  # pyright:ignore[reportArgumentType]\n            if self._commit_after_execute:\n                await conn.commit()\n\n    @override\n    async def fetch(self, query: QuerySingle | QueryMany) -&gt; list[dict[str, Any]]:\n        \"\"\"\n        Execute a query and return results as a list of dicts.\n        \"\"\"\n        async with self.conn_wrapper as conn:\n            async with conn.cursor() as cur:\n                if isinstance(query, QuerySingle):\n                    await cur.execute(query.sql, query.params)  # pyright:ignore[reportArgumentType]\n                else:\n                    await cur.executemany(query.sql, query.many_params, returning=True)  # pyright:ignore[reportArgumentType]\n\n                if cur.description is None:\n                    return []\n                columns: list[str] = [desc[0] for desc in cur.description]\n                results: list[dict[str, Any]] = []\n\n                for row in await cur.fetchall():\n                    data = dict(zip(columns, row))\n                    results.append(data)\n            if self._commit_after_execute:\n                await conn.commit()\n            return results\n\n    @override\n    async def truncate(self, schema: str | None = None):\n        \"\"\"\n        Truncate all tables in the schema.\n        \"\"\"\n        schema = schema if schema is not None else \"public\"\n        tables = await self._get_live_table_names(schema)\n        if tables is None:\n            return\n        table_names = \", \".join(tables)\n        async with self.conn_wrapper as conn:\n            async with conn.cursor() as cursor:\n                await cursor.execute(f\"TRUNCATE TABLE {table_names} CASCADE\")  # pyright:ignore[reportArgumentType]\n                if self._commit_after_execute:\n                    await conn.commit()\n\n    @override\n    async def drop_tables(self, schema: str | None = None):\n        \"\"\"\n        Drop all tables in the schema.\n        \"\"\"\n        schema = schema if schema is not None else \"public\"\n        tables = await self._get_live_table_names(schema)\n        if tables is None:\n            return\n        table_names = \", \".join(tables)\n        async with self.conn_wrapper as conn:\n            async with conn.cursor() as cursor:\n                await cursor.execute(f\"DROP TABLE {table_names} CASCADE\")  # pyright:ignore[reportArgumentType]\n                if self._commit_after_execute:\n                    await conn.commit()\n\n    async def _get_live_table_names(self, schema: str) -&gt; list[str] | None:\n        async with self.conn_wrapper as conn:\n            async with conn.cursor() as cursor:\n                # Get all table names from public schema\n                await cursor.execute(f\"SELECT tablename FROM pg_tables WHERE schemaname = '{schema}'\")  # pyright:ignore[reportArgumentType]\n                tables = await cursor.fetchall()\n                if not tables:\n                    return None\n                table_names = [f'\"{table[0]}\"' for table in tables]\n            return table_names\n</code></pre>"},{"location":"reference/embar/db/pg/#embar.db.pg.AsyncPgDb.__init__","title":"<code>__init__(connection_or_pool)</code>","text":"<p>Create a new AsyncPgDb instance.</p> Source code in <code>src/embar/db/pg.py</code> <pre><code>def __init__(self, connection_or_pool: AsyncConnection | AsyncConnectionPool):\n    \"\"\"\n    Create a new AsyncPgDb instance.\n    \"\"\"\n    self.conn_wrapper = AsyncConnectionWrapper(connection_or_pool)\n</code></pre>"},{"location":"reference/embar/db/pg/#embar.db.pg.AsyncPgDb.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Close the database connection.</p> Source code in <code>src/embar/db/pg.py</code> <pre><code>async def close(self):\n    \"\"\"\n    Close the database connection.\n    \"\"\"\n    if self.conn_wrapper:\n        await self.conn_wrapper.close()\n</code></pre>"},{"location":"reference/embar/db/pg/#embar.db.pg.AsyncPgDb.delete","title":"<code>delete(table)</code>","text":"<p>Create an UPDATE query.</p> Source code in <code>src/embar/db/pg.py</code> <pre><code>def delete[T: Table](self, table: type[T]) -&gt; DeleteQueryReady[T, Self]:\n    \"\"\"\n    Create an UPDATE query.\n    \"\"\"\n    return DeleteQueryReady[T, Self](table=table, db=self)\n</code></pre>"},{"location":"reference/embar/db/pg/#embar.db.pg.AsyncPgDb.drop_tables","title":"<code>drop_tables(schema=None)</code>  <code>async</code>","text":"<p>Drop all tables in the schema.</p> Source code in <code>src/embar/db/pg.py</code> <pre><code>@override\nasync def drop_tables(self, schema: str | None = None):\n    \"\"\"\n    Drop all tables in the schema.\n    \"\"\"\n    schema = schema if schema is not None else \"public\"\n    tables = await self._get_live_table_names(schema)\n    if tables is None:\n        return\n    table_names = \", \".join(tables)\n    async with self.conn_wrapper as conn:\n        async with conn.cursor() as cursor:\n            await cursor.execute(f\"DROP TABLE {table_names} CASCADE\")  # pyright:ignore[reportArgumentType]\n            if self._commit_after_execute:\n                await conn.commit()\n</code></pre>"},{"location":"reference/embar/db/pg/#embar.db.pg.AsyncPgDb.execute","title":"<code>execute(query)</code>  <code>async</code>","text":"<p>Execute a query without returning results.</p> Source code in <code>src/embar/db/pg.py</code> <pre><code>@override\nasync def execute(self, query: QuerySingle) -&gt; None:\n    \"\"\"\n    Execute a query without returning results.\n    \"\"\"\n    async with self.conn_wrapper as conn:\n        await conn.execute(query.sql, query.params)  # pyright:ignore[reportArgumentType]\n        if self._commit_after_execute:\n            await conn.commit()\n</code></pre>"},{"location":"reference/embar/db/pg/#embar.db.pg.AsyncPgDb.executemany","title":"<code>executemany(query)</code>  <code>async</code>","text":"<p>Execute a query with multiple parameter sets.</p> Source code in <code>src/embar/db/pg.py</code> <pre><code>@override\nasync def executemany(self, query: QueryMany):\n    \"\"\"\n    Execute a query with multiple parameter sets.\n    \"\"\"\n    params = _jsonify_dicts(query.many_params)\n    async with self.conn_wrapper as conn:\n        async with conn.cursor() as cur:\n            await cur.executemany(query.sql, params)  # pyright:ignore[reportArgumentType]\n        if self._commit_after_execute:\n            await conn.commit()\n</code></pre>"},{"location":"reference/embar/db/pg/#embar.db.pg.AsyncPgDb.fetch","title":"<code>fetch(query)</code>  <code>async</code>","text":"<p>Execute a query and return results as a list of dicts.</p> Source code in <code>src/embar/db/pg.py</code> <pre><code>@override\nasync def fetch(self, query: QuerySingle | QueryMany) -&gt; list[dict[str, Any]]:\n    \"\"\"\n    Execute a query and return results as a list of dicts.\n    \"\"\"\n    async with self.conn_wrapper as conn:\n        async with conn.cursor() as cur:\n            if isinstance(query, QuerySingle):\n                await cur.execute(query.sql, query.params)  # pyright:ignore[reportArgumentType]\n            else:\n                await cur.executemany(query.sql, query.many_params, returning=True)  # pyright:ignore[reportArgumentType]\n\n            if cur.description is None:\n                return []\n            columns: list[str] = [desc[0] for desc in cur.description]\n            results: list[dict[str, Any]] = []\n\n            for row in await cur.fetchall():\n                data = dict(zip(columns, row))\n                results.append(data)\n        if self._commit_after_execute:\n            await conn.commit()\n        return results\n</code></pre>"},{"location":"reference/embar/db/pg/#embar.db.pg.AsyncPgDb.insert","title":"<code>insert(table)</code>","text":"<p>Create an INSERT query.</p> Source code in <code>src/embar/db/pg.py</code> <pre><code>def insert[T: Table](self, table: type[T]) -&gt; InsertQuery[T, Self]:\n    \"\"\"\n    Create an INSERT query.\n    \"\"\"\n    return InsertQuery[T, Self](table=table, db=self)\n</code></pre>"},{"location":"reference/embar/db/pg/#embar.db.pg.AsyncPgDb.migrate","title":"<code>migrate(tables, enums=None)</code>","text":"<p>Create a migration from a list of tables.</p> Source code in <code>src/embar/db/pg.py</code> <pre><code>def migrate(self, tables: Sequence[type[Table]], enums: Sequence[type[EnumBase]] | None = None) -&gt; Migration[Self]:\n    \"\"\"\n    Create a migration from a list of tables.\n    \"\"\"\n    ddls = merge_ddls(MigrationDefs(tables, enums))\n    return Migration(ddls, self)\n</code></pre>"},{"location":"reference/embar/db/pg/#embar.db.pg.AsyncPgDb.migrates","title":"<code>migrates(schema)</code>","text":"<p>Create a migration from a schema module.</p> Source code in <code>src/embar/db/pg.py</code> <pre><code>def migrates(self, schema: types.ModuleType) -&gt; Migration[Self]:\n    \"\"\"\n    Create a migration from a schema module.\n    \"\"\"\n    defs = get_migration_defs(schema)\n    return self.migrate(defs.tables, defs.enums)\n</code></pre>"},{"location":"reference/embar/db/pg/#embar.db.pg.AsyncPgDb.select","title":"<code>select(model)</code>","text":"<p>Create a SELECT query.</p> Source code in <code>src/embar/db/pg.py</code> <pre><code>def select[M: BaseModel](self, model: type[M]) -&gt; SelectQuery[M, Self]:\n    \"\"\"\n    Create a SELECT query.\n    \"\"\"\n    return SelectQuery[M, Self](db=self, model=model)\n</code></pre>"},{"location":"reference/embar/db/pg/#embar.db.pg.AsyncPgDb.select_distinct","title":"<code>select_distinct(model)</code>","text":"<p>Create a SELECT query.</p> Source code in <code>src/embar/db/pg.py</code> <pre><code>def select_distinct[M: BaseModel](self, model: type[M]) -&gt; SelectDistinctQuery[M, Self]:\n    \"\"\"\n    Create a SELECT query.\n    \"\"\"\n    return SelectDistinctQuery[M, Self](db=self, model=model)\n</code></pre>"},{"location":"reference/embar/db/pg/#embar.db.pg.AsyncPgDb.sql","title":"<code>sql(template)</code>","text":"<p>Execute a raw SQL query using template strings.</p> Source code in <code>src/embar/db/pg.py</code> <pre><code>def sql(self, template: Template) -&gt; DbSql[Self]:\n    \"\"\"\n    Execute a raw SQL query using template strings.\n    \"\"\"\n    return DbSql(template, self)\n</code></pre>"},{"location":"reference/embar/db/pg/#embar.db.pg.AsyncPgDb.transaction","title":"<code>transaction()</code>","text":"<p>Start an isolated transaction.</p> <p>```python notest from embar.db.pg import AsyncPgDb db = AsyncPgDb(None)</p> <p>async with db.transaction() as tx:     ... ```</p> Source code in <code>src/embar/db/pg.py</code> <pre><code>def transaction(self) -&gt; AsyncPgDbTransaction:\n    \"\"\"\n    Start an isolated transaction.\n\n    ```python notest\n    from embar.db.pg import AsyncPgDb\n    db = AsyncPgDb(None)\n\n    async with db.transaction() as tx:\n        ...\n    ```\n    \"\"\"\n    return AsyncPgDbTransaction(self)\n</code></pre>"},{"location":"reference/embar/db/pg/#embar.db.pg.AsyncPgDb.truncate","title":"<code>truncate(schema=None)</code>  <code>async</code>","text":"<p>Truncate all tables in the schema.</p> Source code in <code>src/embar/db/pg.py</code> <pre><code>@override\nasync def truncate(self, schema: str | None = None):\n    \"\"\"\n    Truncate all tables in the schema.\n    \"\"\"\n    schema = schema if schema is not None else \"public\"\n    tables = await self._get_live_table_names(schema)\n    if tables is None:\n        return\n    table_names = \", \".join(tables)\n    async with self.conn_wrapper as conn:\n        async with conn.cursor() as cursor:\n            await cursor.execute(f\"TRUNCATE TABLE {table_names} CASCADE\")  # pyright:ignore[reportArgumentType]\n            if self._commit_after_execute:\n                await conn.commit()\n</code></pre>"},{"location":"reference/embar/db/pg/#embar.db.pg.AsyncPgDb.update","title":"<code>update(table)</code>","text":"<p>Create an UPDATE query.</p> Source code in <code>src/embar/db/pg.py</code> <pre><code>def update[T: Table](self, table: type[T]) -&gt; UpdateQuery[T, Self]:\n    \"\"\"\n    Create an UPDATE query.\n    \"\"\"\n    return UpdateQuery[T, Self](table=table, db=self)\n</code></pre>"},{"location":"reference/embar/db/pg/#embar.db.pg.AsyncPgDbTransaction","title":"<code>AsyncPgDbTransaction</code>","text":"<p>Transaction context manager for AsyncPgDb.</p> Source code in <code>src/embar/db/pg.py</code> <pre><code>class AsyncPgDbTransaction:\n    \"\"\"\n    Transaction context manager for AsyncPgDb.\n    \"\"\"\n\n    _db: AsyncPgDb\n    _conn_cm: AbstractAsyncContextManager[AsyncConnection] | None = None\n    _tx: AbstractAsyncContextManager[AsyncTransaction] | None = None\n\n    def __init__(self, db: AsyncPgDb):\n        self._db = db\n\n    async def __aenter__(self) -&gt; AsyncPgDb:\n        pool_or_conn = self._db.conn_wrapper.conn_or_pool\n\n        if isinstance(pool_or_conn, AsyncConnectionPool):\n            # Ensure pool is open\n            await pool_or_conn.open()\n\n            # Check out a dedicated connection for the transaction\n            self._conn_cm = pool_or_conn.connection()\n            conn = await self._conn_cm.__aenter__()\n        else:\n            conn = pool_or_conn\n\n        # Create an AsyncPgDb that uses this single connection (no auto-commit)\n        tx_db = AsyncPgDb(conn)\n        tx_db._commit_after_execute = False  # pyright: ignore[reportPrivateUsage]\n        self._db = tx_db\n\n        self._tx = conn.transaction()\n        await self._tx.__aenter__()\n        return tx_db\n\n    async def __aexit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: types.TracebackType | None,\n    ):\n        result = None\n        if self._tx is not None:\n            result = await self._tx.__aexit__(exc_type, exc_val, exc_tb)\n        if self._conn_cm is not None:\n            await self._conn_cm.__aexit__(exc_type, exc_val, exc_tb)\n        return result\n</code></pre>"},{"location":"reference/embar/db/pg/#embar.db.pg.PgDb","title":"<code>PgDb</code>","text":"<p>               Bases: <code>DbBase</code></p> <p>Postgres database client for synchronous operations.</p> Source code in <code>src/embar/db/pg.py</code> <pre><code>@final\nclass PgDb(DbBase):\n    \"\"\"\n    Postgres database client for synchronous operations.\n    \"\"\"\n\n    db_type = \"postgres\"\n    conn_wrapper: ConnectionWrapper[Connection | ConnectionPool]\n    _commit_after_execute: bool = True\n\n    def __init__(self, connection_or_pool: Connection | ConnectionPool):\n        \"\"\"\n        Create a new PgDb instance.\n        \"\"\"\n        self.conn_wrapper = ConnectionWrapper(connection_or_pool)\n\n    def close(self):\n        \"\"\"\n        Close the database connection.\n        \"\"\"\n        if self.conn_wrapper:\n            self.conn_wrapper.close()\n\n    def transaction(self) -&gt; PgDbTransaction:\n        \"\"\"\n        Start an isolated transaction.\n\n        ```python notest\n        from embar.db.pg import PgDb\n        db = PgDb(None)\n\n        with db.transaction() as tx:\n            ...\n        ```\n        \"\"\"\n        return PgDbTransaction(self)\n\n    def select[M: BaseModel](self, model: type[M]) -&gt; SelectQuery[M, Self]:\n        \"\"\"\n        Create a SELECT query.\n        \"\"\"\n        return SelectQuery[M, Self](db=self, model=model)\n\n    def select_distinct[M: BaseModel](self, model: type[M]) -&gt; SelectDistinctQuery[M, Self]:\n        \"\"\"\n        Create a SELECT query.\n        \"\"\"\n        return SelectDistinctQuery[M, Self](db=self, model=model)\n\n    def insert[T: Table](self, table: type[T]) -&gt; InsertQuery[T, Self]:\n        \"\"\"\n        Create an INSERT query.\n        \"\"\"\n        return InsertQuery[T, Self](table=table, db=self)\n\n    def update[T: Table](self, table: type[T]) -&gt; UpdateQuery[T, Self]:\n        \"\"\"\n        Create an UPDATE query.\n        \"\"\"\n        return UpdateQuery[T, Self](table=table, db=self)\n\n    def delete[T: Table](self, table: type[T]) -&gt; DeleteQueryReady[T, Self]:\n        \"\"\"\n        Create an UPDATE query.\n        \"\"\"\n        return DeleteQueryReady[T, Self](table=table, db=self)\n\n    def sql(self, template: Template) -&gt; DbSql[Self]:\n        \"\"\"\n        Execute a raw SQL query using template strings.\n        \"\"\"\n        return DbSql(template, self)\n\n    def migrate(self, tables: Sequence[type[Table]], enums: Sequence[type[EnumBase]] | None = None) -&gt; Migration[Self]:\n        \"\"\"\n        Create a migration from a list of tables.\n        \"\"\"\n        ddls = merge_ddls(MigrationDefs(tables, enums))\n        return Migration(ddls, self)\n\n    def migrates(self, schema: types.ModuleType) -&gt; Migration[Self]:\n        \"\"\"\n        Create a migration from a schema module.\n        \"\"\"\n        defs = get_migration_defs(schema)\n        return self.migrate(defs.tables, defs.enums)\n\n    @override\n    def execute(self, query: QuerySingle) -&gt; None:\n        \"\"\"\n        Execute a query without returning results.\n        \"\"\"\n        with self.conn_wrapper as conn:\n            conn.execute(query.sql, query.params)  # pyright:ignore[reportArgumentType]\n            if self._commit_after_execute:\n                conn.commit()\n\n    @override\n    def executemany(self, query: QueryMany):\n        \"\"\"\n        Execute a query with multiple parameter sets.\n        \"\"\"\n        params = _jsonify_dicts(query.many_params)\n        with self.conn_wrapper as conn:\n            with conn.cursor() as cur:\n                cur.executemany(query.sql, params)  # pyright:ignore[reportArgumentType]\n            if self._commit_after_execute:\n                conn.commit()\n\n    @override\n    def fetch(self, query: QuerySingle | QueryMany) -&gt; list[dict[str, Any]]:\n        \"\"\"\n        Execute a query and return results as a list of dicts.\n        \"\"\"\n        with self.conn_wrapper as conn:\n            with conn.cursor() as cur:\n                if isinstance(query, QuerySingle):\n                    cur.execute(query.sql, query.params)  # pyright:ignore[reportArgumentType]\n                else:\n                    cur.executemany(query.sql, query.many_params, returning=True)  # pyright:ignore[reportArgumentType]\n\n                if cur.description is None:\n                    return []\n                columns: list[str] = [desc[0] for desc in cur.description]\n                results: list[dict[str, Any]] = []\n                for row in cur.fetchall():\n                    data = dict(zip(columns, row))\n                    results.append(data)\n            if self._commit_after_execute:\n                conn.commit()  # Commit after SELECT\n            return results\n\n    @override\n    def truncate(self, schema: str | None = None):\n        \"\"\"\n        Truncate all tables in the schema.\n        \"\"\"\n        schema = schema if schema is not None else \"public\"\n        tables = self._get_live_table_names(schema)\n        if tables is None:\n            return\n        table_names = \", \".join(tables)\n        with self.conn_wrapper as conn:\n            with conn.cursor() as cursor:\n                cursor.execute(f\"TRUNCATE TABLE {table_names} CASCADE\")  # pyright:ignore[reportArgumentType]\n                if self._commit_after_execute:\n                    conn.commit()\n\n    @override\n    def drop_tables(self, schema: str | None = None):\n        \"\"\"\n        Drop all tables in the schema.\n        \"\"\"\n        schema = schema if schema is not None else \"public\"\n        tables = self._get_live_table_names(schema)\n        if tables is None:\n            return\n        table_names = \", \".join(tables)\n        with self.conn_wrapper as conn:\n            with conn.cursor() as cursor:\n                cursor.execute(f\"DROP TABLE {table_names} CASCADE\")  # pyright:ignore[reportArgumentType]\n                if self._commit_after_execute:\n                    conn.commit()\n\n    def _get_live_table_names(self, schema: str) -&gt; list[str] | None:\n        with self.conn_wrapper as conn:\n            with conn.cursor() as cursor:\n                # Get all table names from public schema\n                cursor.execute(f\"SELECT tablename FROM pg_tables WHERE schemaname = '{schema}'\")  # pyright:ignore[reportArgumentType]\n                tables = cursor.fetchall()\n                if not tables:\n                    return None\n                table_names = [f'\"{table[0]}\"' for table in tables]\n            return table_names\n</code></pre>"},{"location":"reference/embar/db/pg/#embar.db.pg.PgDb.__init__","title":"<code>__init__(connection_or_pool)</code>","text":"<p>Create a new PgDb instance.</p> Source code in <code>src/embar/db/pg.py</code> <pre><code>def __init__(self, connection_or_pool: Connection | ConnectionPool):\n    \"\"\"\n    Create a new PgDb instance.\n    \"\"\"\n    self.conn_wrapper = ConnectionWrapper(connection_or_pool)\n</code></pre>"},{"location":"reference/embar/db/pg/#embar.db.pg.PgDb.close","title":"<code>close()</code>","text":"<p>Close the database connection.</p> Source code in <code>src/embar/db/pg.py</code> <pre><code>def close(self):\n    \"\"\"\n    Close the database connection.\n    \"\"\"\n    if self.conn_wrapper:\n        self.conn_wrapper.close()\n</code></pre>"},{"location":"reference/embar/db/pg/#embar.db.pg.PgDb.delete","title":"<code>delete(table)</code>","text":"<p>Create an UPDATE query.</p> Source code in <code>src/embar/db/pg.py</code> <pre><code>def delete[T: Table](self, table: type[T]) -&gt; DeleteQueryReady[T, Self]:\n    \"\"\"\n    Create an UPDATE query.\n    \"\"\"\n    return DeleteQueryReady[T, Self](table=table, db=self)\n</code></pre>"},{"location":"reference/embar/db/pg/#embar.db.pg.PgDb.drop_tables","title":"<code>drop_tables(schema=None)</code>","text":"<p>Drop all tables in the schema.</p> Source code in <code>src/embar/db/pg.py</code> <pre><code>@override\ndef drop_tables(self, schema: str | None = None):\n    \"\"\"\n    Drop all tables in the schema.\n    \"\"\"\n    schema = schema if schema is not None else \"public\"\n    tables = self._get_live_table_names(schema)\n    if tables is None:\n        return\n    table_names = \", \".join(tables)\n    with self.conn_wrapper as conn:\n        with conn.cursor() as cursor:\n            cursor.execute(f\"DROP TABLE {table_names} CASCADE\")  # pyright:ignore[reportArgumentType]\n            if self._commit_after_execute:\n                conn.commit()\n</code></pre>"},{"location":"reference/embar/db/pg/#embar.db.pg.PgDb.execute","title":"<code>execute(query)</code>","text":"<p>Execute a query without returning results.</p> Source code in <code>src/embar/db/pg.py</code> <pre><code>@override\ndef execute(self, query: QuerySingle) -&gt; None:\n    \"\"\"\n    Execute a query without returning results.\n    \"\"\"\n    with self.conn_wrapper as conn:\n        conn.execute(query.sql, query.params)  # pyright:ignore[reportArgumentType]\n        if self._commit_after_execute:\n            conn.commit()\n</code></pre>"},{"location":"reference/embar/db/pg/#embar.db.pg.PgDb.executemany","title":"<code>executemany(query)</code>","text":"<p>Execute a query with multiple parameter sets.</p> Source code in <code>src/embar/db/pg.py</code> <pre><code>@override\ndef executemany(self, query: QueryMany):\n    \"\"\"\n    Execute a query with multiple parameter sets.\n    \"\"\"\n    params = _jsonify_dicts(query.many_params)\n    with self.conn_wrapper as conn:\n        with conn.cursor() as cur:\n            cur.executemany(query.sql, params)  # pyright:ignore[reportArgumentType]\n        if self._commit_after_execute:\n            conn.commit()\n</code></pre>"},{"location":"reference/embar/db/pg/#embar.db.pg.PgDb.fetch","title":"<code>fetch(query)</code>","text":"<p>Execute a query and return results as a list of dicts.</p> Source code in <code>src/embar/db/pg.py</code> <pre><code>@override\ndef fetch(self, query: QuerySingle | QueryMany) -&gt; list[dict[str, Any]]:\n    \"\"\"\n    Execute a query and return results as a list of dicts.\n    \"\"\"\n    with self.conn_wrapper as conn:\n        with conn.cursor() as cur:\n            if isinstance(query, QuerySingle):\n                cur.execute(query.sql, query.params)  # pyright:ignore[reportArgumentType]\n            else:\n                cur.executemany(query.sql, query.many_params, returning=True)  # pyright:ignore[reportArgumentType]\n\n            if cur.description is None:\n                return []\n            columns: list[str] = [desc[0] for desc in cur.description]\n            results: list[dict[str, Any]] = []\n            for row in cur.fetchall():\n                data = dict(zip(columns, row))\n                results.append(data)\n        if self._commit_after_execute:\n            conn.commit()  # Commit after SELECT\n        return results\n</code></pre>"},{"location":"reference/embar/db/pg/#embar.db.pg.PgDb.insert","title":"<code>insert(table)</code>","text":"<p>Create an INSERT query.</p> Source code in <code>src/embar/db/pg.py</code> <pre><code>def insert[T: Table](self, table: type[T]) -&gt; InsertQuery[T, Self]:\n    \"\"\"\n    Create an INSERT query.\n    \"\"\"\n    return InsertQuery[T, Self](table=table, db=self)\n</code></pre>"},{"location":"reference/embar/db/pg/#embar.db.pg.PgDb.migrate","title":"<code>migrate(tables, enums=None)</code>","text":"<p>Create a migration from a list of tables.</p> Source code in <code>src/embar/db/pg.py</code> <pre><code>def migrate(self, tables: Sequence[type[Table]], enums: Sequence[type[EnumBase]] | None = None) -&gt; Migration[Self]:\n    \"\"\"\n    Create a migration from a list of tables.\n    \"\"\"\n    ddls = merge_ddls(MigrationDefs(tables, enums))\n    return Migration(ddls, self)\n</code></pre>"},{"location":"reference/embar/db/pg/#embar.db.pg.PgDb.migrates","title":"<code>migrates(schema)</code>","text":"<p>Create a migration from a schema module.</p> Source code in <code>src/embar/db/pg.py</code> <pre><code>def migrates(self, schema: types.ModuleType) -&gt; Migration[Self]:\n    \"\"\"\n    Create a migration from a schema module.\n    \"\"\"\n    defs = get_migration_defs(schema)\n    return self.migrate(defs.tables, defs.enums)\n</code></pre>"},{"location":"reference/embar/db/pg/#embar.db.pg.PgDb.select","title":"<code>select(model)</code>","text":"<p>Create a SELECT query.</p> Source code in <code>src/embar/db/pg.py</code> <pre><code>def select[M: BaseModel](self, model: type[M]) -&gt; SelectQuery[M, Self]:\n    \"\"\"\n    Create a SELECT query.\n    \"\"\"\n    return SelectQuery[M, Self](db=self, model=model)\n</code></pre>"},{"location":"reference/embar/db/pg/#embar.db.pg.PgDb.select_distinct","title":"<code>select_distinct(model)</code>","text":"<p>Create a SELECT query.</p> Source code in <code>src/embar/db/pg.py</code> <pre><code>def select_distinct[M: BaseModel](self, model: type[M]) -&gt; SelectDistinctQuery[M, Self]:\n    \"\"\"\n    Create a SELECT query.\n    \"\"\"\n    return SelectDistinctQuery[M, Self](db=self, model=model)\n</code></pre>"},{"location":"reference/embar/db/pg/#embar.db.pg.PgDb.sql","title":"<code>sql(template)</code>","text":"<p>Execute a raw SQL query using template strings.</p> Source code in <code>src/embar/db/pg.py</code> <pre><code>def sql(self, template: Template) -&gt; DbSql[Self]:\n    \"\"\"\n    Execute a raw SQL query using template strings.\n    \"\"\"\n    return DbSql(template, self)\n</code></pre>"},{"location":"reference/embar/db/pg/#embar.db.pg.PgDb.transaction","title":"<code>transaction()</code>","text":"<p>Start an isolated transaction.</p> <p>```python notest from embar.db.pg import PgDb db = PgDb(None)</p> <p>with db.transaction() as tx:     ... ```</p> Source code in <code>src/embar/db/pg.py</code> <pre><code>def transaction(self) -&gt; PgDbTransaction:\n    \"\"\"\n    Start an isolated transaction.\n\n    ```python notest\n    from embar.db.pg import PgDb\n    db = PgDb(None)\n\n    with db.transaction() as tx:\n        ...\n    ```\n    \"\"\"\n    return PgDbTransaction(self)\n</code></pre>"},{"location":"reference/embar/db/pg/#embar.db.pg.PgDb.truncate","title":"<code>truncate(schema=None)</code>","text":"<p>Truncate all tables in the schema.</p> Source code in <code>src/embar/db/pg.py</code> <pre><code>@override\ndef truncate(self, schema: str | None = None):\n    \"\"\"\n    Truncate all tables in the schema.\n    \"\"\"\n    schema = schema if schema is not None else \"public\"\n    tables = self._get_live_table_names(schema)\n    if tables is None:\n        return\n    table_names = \", \".join(tables)\n    with self.conn_wrapper as conn:\n        with conn.cursor() as cursor:\n            cursor.execute(f\"TRUNCATE TABLE {table_names} CASCADE\")  # pyright:ignore[reportArgumentType]\n            if self._commit_after_execute:\n                conn.commit()\n</code></pre>"},{"location":"reference/embar/db/pg/#embar.db.pg.PgDb.update","title":"<code>update(table)</code>","text":"<p>Create an UPDATE query.</p> Source code in <code>src/embar/db/pg.py</code> <pre><code>def update[T: Table](self, table: type[T]) -&gt; UpdateQuery[T, Self]:\n    \"\"\"\n    Create an UPDATE query.\n    \"\"\"\n    return UpdateQuery[T, Self](table=table, db=self)\n</code></pre>"},{"location":"reference/embar/db/pg/#embar.db.pg.PgDbTransaction","title":"<code>PgDbTransaction</code>","text":"<p>Transaction context manager for PgDb.</p> Source code in <code>src/embar/db/pg.py</code> <pre><code>class PgDbTransaction:\n    \"\"\"\n    Transaction context manager for PgDb.\n    \"\"\"\n\n    _db: PgDb\n    _conn_cm: AbstractContextManager[Connection] | None = None\n    _tx: AbstractContextManager[Transaction] | None = None\n\n    def __init__(self, db: PgDb):\n        self._db = db\n\n    def __enter__(self) -&gt; PgDb:\n        pool_or_conn = self._db.conn_wrapper.conn_or_pool\n\n        if isinstance(pool_or_conn, ConnectionPool):\n            # Ensure pool is open (idempotent if already open)\n            pool_or_conn.open()\n\n            # Check out a dedicated connection for the transaction\n            self._conn_cm = pool_or_conn.connection()\n            conn = self._conn_cm.__enter__()\n        else:\n            conn = pool_or_conn\n\n        # Create a PgDb that uses this single connection (no auto-commit)\n        tx_db = PgDb(conn)\n        tx_db._commit_after_execute = False  # pyright: ignore[reportPrivateUsage]\n        self._db = tx_db\n\n        self._tx = conn.transaction()\n        self._tx.__enter__()\n        return tx_db\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: types.TracebackType | None,\n    ):\n        result = None\n        if self._tx is not None:\n            result = self._tx.__exit__(exc_type, exc_val, exc_tb)\n        if self._conn_cm is not None:\n            self._conn_cm.__exit__(exc_type, exc_val, exc_tb)\n        return result\n</code></pre>"},{"location":"reference/embar/db/sqlite/","title":"sqlite","text":"<p>SQLite database client.</p>"},{"location":"reference/embar/db/sqlite/#embar.db.sqlite.SqliteDb","title":"<code>SqliteDb</code>","text":"<p>               Bases: <code>DbBase</code></p> <p>SQLite database client for synchronous operations.</p> Source code in <code>src/embar/db/sqlite.py</code> <pre><code>@final\nclass SqliteDb(DbBase):\n    \"\"\"\n    SQLite database client for synchronous operations.\n    \"\"\"\n\n    db_type = \"sqlite\"\n    conn: sqlite3.Connection\n    _commit_after_execute: bool = True\n\n    def __init__(self, connection: sqlite3.Connection):\n        \"\"\"\n        Create a new SqliteDb instance.\n        \"\"\"\n        self.conn = connection\n        self.conn.row_factory = sqlite3.Row\n\n    def close(self):\n        \"\"\"\n        Close the database connection.\n        \"\"\"\n        if self.conn:\n            self.conn.close()\n\n    def transaction(self) -&gt; SqliteDbTransaction:\n        \"\"\"\n        Start an isolated transaction.\n        \"\"\"\n        db_copy = SqliteDb(self.conn)\n        db_copy._commit_after_execute = False\n        return SqliteDbTransaction(db_copy)\n\n    def select[M: BaseModel](self, model: type[M]) -&gt; SelectQuery[M, Self]:\n        \"\"\"\n        Create a SELECT query.\n        \"\"\"\n        return SelectQuery[M, Self](db=self, model=model)\n\n    def select_distinct[M: BaseModel](self, model: type[M]) -&gt; SelectDistinctQuery[M, Self]:\n        \"\"\"\n        Create a SELECT query.\n        \"\"\"\n        return SelectDistinctQuery[M, Self](db=self, model=model)\n\n    def insert[T: Table](self, table: type[T]) -&gt; InsertQuery[T, Self]:\n        \"\"\"\n        Create an INSERT query.\n        \"\"\"\n        return InsertQuery[T, Self](table=table, db=self)\n\n    def update[T: Table](self, table: type[T]) -&gt; UpdateQuery[T, Self]:\n        \"\"\"\n        Create an UPDATE query.\n        \"\"\"\n        return UpdateQuery[T, Self](table=table, db=self)\n\n    def delete[T: Table](self, table: type[T]) -&gt; DeleteQueryReady[T, Self]:\n        \"\"\"\n        Create an UPDATE query.\n        \"\"\"\n        return DeleteQueryReady[T, Self](table=table, db=self)\n\n    def sql(self, template: Template) -&gt; DbSql[Self]:\n        \"\"\"\n        Execute a raw SQL query using template strings.\n        \"\"\"\n        return DbSql(template, self)\n\n    def migrate(self, tables: Sequence[type[Table]], enums: Sequence[type[EnumBase]] | None = None) -&gt; Migration[Self]:\n        \"\"\"\n        Create a migration from a list of tables.\n        \"\"\"\n        ddls = merge_ddls(MigrationDefs(tables, enums))\n        return Migration(ddls, self)\n\n    def migrates(self, schema: types.ModuleType) -&gt; Migration[Self]:\n        \"\"\"\n        Create a migration from a schema module.\n        \"\"\"\n        defs = get_migration_defs(schema)\n        return self.migrate(defs.tables, defs.enums)\n\n    @override\n    def execute(self, query: QuerySingle) -&gt; None:\n        \"\"\"\n        Execute a query without returning results.\n        \"\"\"\n        sql = _convert_params(query.sql)\n        self.conn.execute(sql, query.params)\n        if self._commit_after_execute:\n            self.conn.commit()\n\n    @override\n    def executemany(self, query: QueryMany):\n        \"\"\"\n        Execute a query with multiple parameter sets.\n        \"\"\"\n        sql = _convert_params(query.sql)\n        self.conn.executemany(sql, query.many_params)\n        if self._commit_after_execute:\n            self.conn.commit()\n\n    @override\n    def fetch(self, query: QuerySingle | QueryMany) -&gt; list[dict[str, Any]]:\n        \"\"\"\n        Fetch all rows returned by a SELECT query.\n\n        sqlite returns json/arrays as string, so need to parse them.\n        \"\"\"\n        sql = _convert_params(query.sql)\n        if isinstance(query, QuerySingle):\n            cur = self.conn.execute(sql, query.params)\n        else:\n            cur = self.conn.executemany(sql, query.many_params)\n\n        if cur.description is None:\n            return []\n\n        results: list[dict[str, Any]] = []\n        for row in cur.fetchall():\n            row_dict = dict(row)\n            for key, value in row_dict.items():\n                if isinstance(value, str):\n                    try:\n                        row_dict[key] = json.loads(value)\n                    except (json.JSONDecodeError, ValueError):\n                        try:\n                            row_dict[key] = datetime.strptime(value, \"%Y-%m-%d %H:%M:%S\")\n                        except ValueError:\n                            pass  # Keep as string\n            results.append(row_dict)\n        return results\n\n    @override\n    def truncate(self, schema: str | None = None):\n        \"\"\"\n        Truncate all tables in the database.\n        \"\"\"\n        cursor = self.conn.cursor()\n        tables = self._get_live_table_names()\n        for (table_name,) in tables:\n            cursor.execute(f\"DELETE FROM {table_name}\")\n        if self._commit_after_execute:\n            self.conn.commit()\n\n    @override\n    def drop_tables(self, schema: str | None = None):\n        \"\"\"\n        Drop all tables in the database.\n        \"\"\"\n        cursor = self.conn.cursor()\n        tables = self._get_live_table_names()\n        for (table_name,) in tables:\n            cursor.execute(f\"DROP TABLE {table_name}\")\n        if self._commit_after_execute:\n            self.conn.commit()\n\n    def _get_live_table_names(self) -&gt; list[str]:\n        cursor = self.conn.cursor()\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%'\")\n        tables: list[str] = cursor.fetchall()\n        return tables\n</code></pre>"},{"location":"reference/embar/db/sqlite/#embar.db.sqlite.SqliteDb.__init__","title":"<code>__init__(connection)</code>","text":"<p>Create a new SqliteDb instance.</p> Source code in <code>src/embar/db/sqlite.py</code> <pre><code>def __init__(self, connection: sqlite3.Connection):\n    \"\"\"\n    Create a new SqliteDb instance.\n    \"\"\"\n    self.conn = connection\n    self.conn.row_factory = sqlite3.Row\n</code></pre>"},{"location":"reference/embar/db/sqlite/#embar.db.sqlite.SqliteDb.close","title":"<code>close()</code>","text":"<p>Close the database connection.</p> Source code in <code>src/embar/db/sqlite.py</code> <pre><code>def close(self):\n    \"\"\"\n    Close the database connection.\n    \"\"\"\n    if self.conn:\n        self.conn.close()\n</code></pre>"},{"location":"reference/embar/db/sqlite/#embar.db.sqlite.SqliteDb.delete","title":"<code>delete(table)</code>","text":"<p>Create an UPDATE query.</p> Source code in <code>src/embar/db/sqlite.py</code> <pre><code>def delete[T: Table](self, table: type[T]) -&gt; DeleteQueryReady[T, Self]:\n    \"\"\"\n    Create an UPDATE query.\n    \"\"\"\n    return DeleteQueryReady[T, Self](table=table, db=self)\n</code></pre>"},{"location":"reference/embar/db/sqlite/#embar.db.sqlite.SqliteDb.drop_tables","title":"<code>drop_tables(schema=None)</code>","text":"<p>Drop all tables in the database.</p> Source code in <code>src/embar/db/sqlite.py</code> <pre><code>@override\ndef drop_tables(self, schema: str | None = None):\n    \"\"\"\n    Drop all tables in the database.\n    \"\"\"\n    cursor = self.conn.cursor()\n    tables = self._get_live_table_names()\n    for (table_name,) in tables:\n        cursor.execute(f\"DROP TABLE {table_name}\")\n    if self._commit_after_execute:\n        self.conn.commit()\n</code></pre>"},{"location":"reference/embar/db/sqlite/#embar.db.sqlite.SqliteDb.execute","title":"<code>execute(query)</code>","text":"<p>Execute a query without returning results.</p> Source code in <code>src/embar/db/sqlite.py</code> <pre><code>@override\ndef execute(self, query: QuerySingle) -&gt; None:\n    \"\"\"\n    Execute a query without returning results.\n    \"\"\"\n    sql = _convert_params(query.sql)\n    self.conn.execute(sql, query.params)\n    if self._commit_after_execute:\n        self.conn.commit()\n</code></pre>"},{"location":"reference/embar/db/sqlite/#embar.db.sqlite.SqliteDb.executemany","title":"<code>executemany(query)</code>","text":"<p>Execute a query with multiple parameter sets.</p> Source code in <code>src/embar/db/sqlite.py</code> <pre><code>@override\ndef executemany(self, query: QueryMany):\n    \"\"\"\n    Execute a query with multiple parameter sets.\n    \"\"\"\n    sql = _convert_params(query.sql)\n    self.conn.executemany(sql, query.many_params)\n    if self._commit_after_execute:\n        self.conn.commit()\n</code></pre>"},{"location":"reference/embar/db/sqlite/#embar.db.sqlite.SqliteDb.fetch","title":"<code>fetch(query)</code>","text":"<p>Fetch all rows returned by a SELECT query.</p> <p>sqlite returns json/arrays as string, so need to parse them.</p> Source code in <code>src/embar/db/sqlite.py</code> <pre><code>@override\ndef fetch(self, query: QuerySingle | QueryMany) -&gt; list[dict[str, Any]]:\n    \"\"\"\n    Fetch all rows returned by a SELECT query.\n\n    sqlite returns json/arrays as string, so need to parse them.\n    \"\"\"\n    sql = _convert_params(query.sql)\n    if isinstance(query, QuerySingle):\n        cur = self.conn.execute(sql, query.params)\n    else:\n        cur = self.conn.executemany(sql, query.many_params)\n\n    if cur.description is None:\n        return []\n\n    results: list[dict[str, Any]] = []\n    for row in cur.fetchall():\n        row_dict = dict(row)\n        for key, value in row_dict.items():\n            if isinstance(value, str):\n                try:\n                    row_dict[key] = json.loads(value)\n                except (json.JSONDecodeError, ValueError):\n                    try:\n                        row_dict[key] = datetime.strptime(value, \"%Y-%m-%d %H:%M:%S\")\n                    except ValueError:\n                        pass  # Keep as string\n        results.append(row_dict)\n    return results\n</code></pre>"},{"location":"reference/embar/db/sqlite/#embar.db.sqlite.SqliteDb.insert","title":"<code>insert(table)</code>","text":"<p>Create an INSERT query.</p> Source code in <code>src/embar/db/sqlite.py</code> <pre><code>def insert[T: Table](self, table: type[T]) -&gt; InsertQuery[T, Self]:\n    \"\"\"\n    Create an INSERT query.\n    \"\"\"\n    return InsertQuery[T, Self](table=table, db=self)\n</code></pre>"},{"location":"reference/embar/db/sqlite/#embar.db.sqlite.SqliteDb.migrate","title":"<code>migrate(tables, enums=None)</code>","text":"<p>Create a migration from a list of tables.</p> Source code in <code>src/embar/db/sqlite.py</code> <pre><code>def migrate(self, tables: Sequence[type[Table]], enums: Sequence[type[EnumBase]] | None = None) -&gt; Migration[Self]:\n    \"\"\"\n    Create a migration from a list of tables.\n    \"\"\"\n    ddls = merge_ddls(MigrationDefs(tables, enums))\n    return Migration(ddls, self)\n</code></pre>"},{"location":"reference/embar/db/sqlite/#embar.db.sqlite.SqliteDb.migrates","title":"<code>migrates(schema)</code>","text":"<p>Create a migration from a schema module.</p> Source code in <code>src/embar/db/sqlite.py</code> <pre><code>def migrates(self, schema: types.ModuleType) -&gt; Migration[Self]:\n    \"\"\"\n    Create a migration from a schema module.\n    \"\"\"\n    defs = get_migration_defs(schema)\n    return self.migrate(defs.tables, defs.enums)\n</code></pre>"},{"location":"reference/embar/db/sqlite/#embar.db.sqlite.SqliteDb.select","title":"<code>select(model)</code>","text":"<p>Create a SELECT query.</p> Source code in <code>src/embar/db/sqlite.py</code> <pre><code>def select[M: BaseModel](self, model: type[M]) -&gt; SelectQuery[M, Self]:\n    \"\"\"\n    Create a SELECT query.\n    \"\"\"\n    return SelectQuery[M, Self](db=self, model=model)\n</code></pre>"},{"location":"reference/embar/db/sqlite/#embar.db.sqlite.SqliteDb.select_distinct","title":"<code>select_distinct(model)</code>","text":"<p>Create a SELECT query.</p> Source code in <code>src/embar/db/sqlite.py</code> <pre><code>def select_distinct[M: BaseModel](self, model: type[M]) -&gt; SelectDistinctQuery[M, Self]:\n    \"\"\"\n    Create a SELECT query.\n    \"\"\"\n    return SelectDistinctQuery[M, Self](db=self, model=model)\n</code></pre>"},{"location":"reference/embar/db/sqlite/#embar.db.sqlite.SqliteDb.sql","title":"<code>sql(template)</code>","text":"<p>Execute a raw SQL query using template strings.</p> Source code in <code>src/embar/db/sqlite.py</code> <pre><code>def sql(self, template: Template) -&gt; DbSql[Self]:\n    \"\"\"\n    Execute a raw SQL query using template strings.\n    \"\"\"\n    return DbSql(template, self)\n</code></pre>"},{"location":"reference/embar/db/sqlite/#embar.db.sqlite.SqliteDb.transaction","title":"<code>transaction()</code>","text":"<p>Start an isolated transaction.</p> Source code in <code>src/embar/db/sqlite.py</code> <pre><code>def transaction(self) -&gt; SqliteDbTransaction:\n    \"\"\"\n    Start an isolated transaction.\n    \"\"\"\n    db_copy = SqliteDb(self.conn)\n    db_copy._commit_after_execute = False\n    return SqliteDbTransaction(db_copy)\n</code></pre>"},{"location":"reference/embar/db/sqlite/#embar.db.sqlite.SqliteDb.truncate","title":"<code>truncate(schema=None)</code>","text":"<p>Truncate all tables in the database.</p> Source code in <code>src/embar/db/sqlite.py</code> <pre><code>@override\ndef truncate(self, schema: str | None = None):\n    \"\"\"\n    Truncate all tables in the database.\n    \"\"\"\n    cursor = self.conn.cursor()\n    tables = self._get_live_table_names()\n    for (table_name,) in tables:\n        cursor.execute(f\"DELETE FROM {table_name}\")\n    if self._commit_after_execute:\n        self.conn.commit()\n</code></pre>"},{"location":"reference/embar/db/sqlite/#embar.db.sqlite.SqliteDb.update","title":"<code>update(table)</code>","text":"<p>Create an UPDATE query.</p> Source code in <code>src/embar/db/sqlite.py</code> <pre><code>def update[T: Table](self, table: type[T]) -&gt; UpdateQuery[T, Self]:\n    \"\"\"\n    Create an UPDATE query.\n    \"\"\"\n    return UpdateQuery[T, Self](table=table, db=self)\n</code></pre>"},{"location":"reference/embar/db/sqlite/#embar.db.sqlite.SqliteDbTransaction","title":"<code>SqliteDbTransaction</code>","text":"<p>Transaction context manager for SqliteDb</p> Source code in <code>src/embar/db/sqlite.py</code> <pre><code>class SqliteDbTransaction:\n    \"\"\"\n    Transaction context manager for SqliteDb\n    \"\"\"\n\n    _db: SqliteDb\n\n    def __init__(self, db: SqliteDb):\n        self._db = db\n\n    def __enter__(self) -&gt; SqliteDb:\n        self._db.conn.execute(\"BEGIN\")\n        return self._db\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: types.TracebackType | None,\n    ) -&gt; bool:\n        if exc_type is None:\n            self._db.conn.commit()\n        else:\n            self._db.conn.rollback()\n        return False\n</code></pre>"},{"location":"reference/embar/query/","title":"Index","text":""},{"location":"reference/embar/query/clause_base/","title":"clause_base","text":""},{"location":"reference/embar/query/clause_base/#embar.query.clause_base.ClauseBase","title":"<code>ClauseBase</code>","text":"<p>               Bases: <code>ABC</code></p> <p>ABC for ORDER BY and WHERE clauses.</p> <p>Not all use the get_count() directly (those with no bindings) but their children might.</p> Source code in <code>src/embar/query/clause_base.py</code> <pre><code>class ClauseBase(ABC):\n    \"\"\"\n    ABC for ORDER BY and WHERE clauses.\n\n    Not all use the get_count() directly (those with no bindings)\n    but their children might.\n    \"\"\"\n\n    @abstractmethod\n    def sql(self, get_count: GetCount) -&gt; QuerySingle:\n        \"\"\"\n        Generate the SQL fragment for this clause.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"reference/embar/query/clause_base/#embar.query.clause_base.ClauseBase.sql","title":"<code>sql(get_count)</code>  <code>abstractmethod</code>","text":"<p>Generate the SQL fragment for this clause.</p> Source code in <code>src/embar/query/clause_base.py</code> <pre><code>@abstractmethod\ndef sql(self, get_count: GetCount) -&gt; QuerySingle:\n    \"\"\"\n    Generate the SQL fragment for this clause.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/embar/query/conflict/","title":"conflict","text":""},{"location":"reference/embar/query/delete/","title":"delete","text":"<p>Select query builder.</p>"},{"location":"reference/embar/query/delete/#embar.query.delete.DeleteQueryReady","title":"<code>DeleteQueryReady</code>","text":"<p><code>DeleteQueryReady</code> is used to delete data from a table.</p> <p>It is generic over the <code>Table</code> being inserted into, and the database being used.</p> <p><code>DeleteQueryReady</code> is returned by <code>db.delete()</code></p> Source code in <code>src/embar/query/delete.py</code> <pre><code>class DeleteQueryReady[T: Table, Db: AllDbBase]:\n    \"\"\"\n    `DeleteQueryReady` is used to delete data from a table.\n\n    It is generic over the `Table` being inserted into, and the database being used.\n\n    `DeleteQueryReady` is returned by `db.delete()`\n    \"\"\"\n\n    table: type[T]\n    _db: Db\n\n    _where_clause: ClauseBase | None = None\n    _order_clause: OrderBy | None = None\n    _limit_value: int | None = None\n\n    def __init__(self, table: type[T], db: Db):\n        \"\"\"\n        Create a new SelectQueryReady instance.\n        \"\"\"\n        self.table = table\n        self._db = db\n\n    def returning(self) -&gt; DeleteQueryReturning[T, Db]:\n        return DeleteQueryReturning(self.table, self._db, self._where_clause, self._order_clause, self._limit_value)\n\n    def where(self, where_clause: ClauseBase) -&gt; Self:\n        \"\"\"\n        Add a WHERE clause to the query.\n        \"\"\"\n        self._where_clause = where_clause\n        return self\n\n    def order_by(self, *clauses: ColumnBase | Asc | Desc | Sql) -&gt; Self:\n        \"\"\"\n        Add an ORDER BY clause to sort query results.\n\n        Accepts multiple ordering clauses:\n        - Bare column references (defaults to ASC): `User.id`\n        - `Asc(User.id)` or `Asc(User.id, nulls=\"last\")`\n        - `Desc(User.id)` or `Desc(User.id, nulls=\"first\")`\n        - Raw SQL: `Sql(t\"{User.id} DESC\")`\n\n        Can be called multiple times to add more sort columns.\n\n        ```python\n        from embar.db.pg import PgDb\n        from embar.table import Table\n        from embar.column.common import Integer\n\n        class User(Table):\n            id: Integer = Integer(primary=True)\n\n        db = PgDb(None)\n\n        query = db.delete(User).order_by(User.id)\n        sql_result = query.sql()\n        assert \"ORDER BY\" in sql_result.sql\n        ```\n        \"\"\"\n        # Convert each clause to an OrderByClause\n        order_clauses: list[ClauseBase] = []\n        for clause in clauses:\n            if isinstance(clause, (Asc, Desc)):\n                order_clauses.append(clause)\n            elif isinstance(clause, Sql):\n                order_clauses.append(RawSqlOrder(clause))\n            else:\n                order_clauses.append(BareColumn(clause))\n\n        if self._order_clause is None:\n            self._order_clause = OrderBy(tuple(order_clauses))\n        else:\n            # Add to existing ORDER BY clauses\n            self._order_clause = OrderBy((*self._order_clause.clauses, *order_clauses))\n\n        return self\n\n    def limit(self, n: int) -&gt; Self:\n        \"\"\"\n        Add a LIMIT clause to the query.\n        \"\"\"\n        self._limit_value = n\n        return self\n\n    def __await__(self):\n        \"\"\"\n        Async users should construct their query and await it.\n\n        Non-async users have the `run()` convenience method below.\n        But this method will still work if called in an async context against a non-async db.\n\n        The overrides provide for a few different cases:\n        - A Model was passed, in which case that's the return type\n        - `SelectAll` was passed, in which case the return type is the `Table`\n        - This is called with an async db, in which case an error is returned.\n        \"\"\"\n        query = self.sql()\n\n        async def awaitable():\n            db = self._db\n            if isinstance(db, AsyncDbBase):\n                await db.execute(query)\n            else:\n                db = cast(DbBase, self._db)\n                db.execute(query)\n\n        return awaitable().__await__()\n\n    @overload\n    def run(self: DeleteQueryReady[T, DbBase]) -&gt; None: ...\n    @overload\n    def run(self: DeleteQueryReady[T, AsyncDbBase]) -&gt; DeleteQueryReady[T, Db]: ...\n\n    def run(self) -&gt; None | DeleteQueryReady[T, Db]:\n        \"\"\"\n        Run the query against the underlying DB.\n\n        Convenience method for those not using async.\n        But still works if awaited.\n        \"\"\"\n        if isinstance(self._db, DbBase):\n            query = self.sql()\n            self._db.execute(query)\n        return self\n\n    def sql(self) -&gt; QuerySingle:\n        \"\"\"\n        Combine all the components of the query and build the SQL and bind parameters (psycopg format).\n        \"\"\"\n\n        sql = f\"\"\"\n        DELETE\n        FROM {self.table.fqn()}\n        \"\"\"\n        sql = dedent(sql).strip()\n\n        count = -1\n\n        def get_count() -&gt; int:\n            nonlocal count\n            count += 1\n            return count\n\n        params: dict[str, Any] = {}\n\n        if self._where_clause is not None:\n            where_data = self._where_clause.sql(get_count)\n            sql += f\"\\nWHERE {where_data.sql}\"\n            params = {**params, **where_data.params}\n\n        if self._order_clause is not None:\n            order_by_query = self._order_clause.sql(get_count)\n            sql += f\"\\nORDER BY {order_by_query.sql}\"\n            params = {**params, **order_by_query.params}\n\n        if self._limit_value is not None:\n            sql += f\"\\nLIMIT {self._limit_value}\"\n\n        sql = sql.strip()\n\n        return QuerySingle(sql, params=params)\n</code></pre>"},{"location":"reference/embar/query/delete/#embar.query.delete.DeleteQueryReady.__await__","title":"<code>__await__()</code>","text":"<p>Async users should construct their query and await it.</p> <p>Non-async users have the <code>run()</code> convenience method below. But this method will still work if called in an async context against a non-async db.</p> <p>The overrides provide for a few different cases: - A Model was passed, in which case that's the return type - <code>SelectAll</code> was passed, in which case the return type is the <code>Table</code> - This is called with an async db, in which case an error is returned.</p> Source code in <code>src/embar/query/delete.py</code> <pre><code>def __await__(self):\n    \"\"\"\n    Async users should construct their query and await it.\n\n    Non-async users have the `run()` convenience method below.\n    But this method will still work if called in an async context against a non-async db.\n\n    The overrides provide for a few different cases:\n    - A Model was passed, in which case that's the return type\n    - `SelectAll` was passed, in which case the return type is the `Table`\n    - This is called with an async db, in which case an error is returned.\n    \"\"\"\n    query = self.sql()\n\n    async def awaitable():\n        db = self._db\n        if isinstance(db, AsyncDbBase):\n            await db.execute(query)\n        else:\n            db = cast(DbBase, self._db)\n            db.execute(query)\n\n    return awaitable().__await__()\n</code></pre>"},{"location":"reference/embar/query/delete/#embar.query.delete.DeleteQueryReady.__init__","title":"<code>__init__(table, db)</code>","text":"<p>Create a new SelectQueryReady instance.</p> Source code in <code>src/embar/query/delete.py</code> <pre><code>def __init__(self, table: type[T], db: Db):\n    \"\"\"\n    Create a new SelectQueryReady instance.\n    \"\"\"\n    self.table = table\n    self._db = db\n</code></pre>"},{"location":"reference/embar/query/delete/#embar.query.delete.DeleteQueryReady.limit","title":"<code>limit(n)</code>","text":"<p>Add a LIMIT clause to the query.</p> Source code in <code>src/embar/query/delete.py</code> <pre><code>def limit(self, n: int) -&gt; Self:\n    \"\"\"\n    Add a LIMIT clause to the query.\n    \"\"\"\n    self._limit_value = n\n    return self\n</code></pre>"},{"location":"reference/embar/query/delete/#embar.query.delete.DeleteQueryReady.order_by","title":"<code>order_by(*clauses)</code>","text":"<p>Add an ORDER BY clause to sort query results.</p> <p>Accepts multiple ordering clauses: - Bare column references (defaults to ASC): <code>User.id</code> - <code>Asc(User.id)</code> or <code>Asc(User.id, nulls=\"last\")</code> - <code>Desc(User.id)</code> or <code>Desc(User.id, nulls=\"first\")</code> - Raw SQL: <code>Sql(t\"{User.id} DESC\")</code></p> <p>Can be called multiple times to add more sort columns.</p> <pre><code>from embar.db.pg import PgDb\nfrom embar.table import Table\nfrom embar.column.common import Integer\n\nclass User(Table):\n    id: Integer = Integer(primary=True)\n\ndb = PgDb(None)\n\nquery = db.delete(User).order_by(User.id)\nsql_result = query.sql()\nassert \"ORDER BY\" in sql_result.sql\n</code></pre> Source code in <code>src/embar/query/delete.py</code> <pre><code>def order_by(self, *clauses: ColumnBase | Asc | Desc | Sql) -&gt; Self:\n    \"\"\"\n    Add an ORDER BY clause to sort query results.\n\n    Accepts multiple ordering clauses:\n    - Bare column references (defaults to ASC): `User.id`\n    - `Asc(User.id)` or `Asc(User.id, nulls=\"last\")`\n    - `Desc(User.id)` or `Desc(User.id, nulls=\"first\")`\n    - Raw SQL: `Sql(t\"{User.id} DESC\")`\n\n    Can be called multiple times to add more sort columns.\n\n    ```python\n    from embar.db.pg import PgDb\n    from embar.table import Table\n    from embar.column.common import Integer\n\n    class User(Table):\n        id: Integer = Integer(primary=True)\n\n    db = PgDb(None)\n\n    query = db.delete(User).order_by(User.id)\n    sql_result = query.sql()\n    assert \"ORDER BY\" in sql_result.sql\n    ```\n    \"\"\"\n    # Convert each clause to an OrderByClause\n    order_clauses: list[ClauseBase] = []\n    for clause in clauses:\n        if isinstance(clause, (Asc, Desc)):\n            order_clauses.append(clause)\n        elif isinstance(clause, Sql):\n            order_clauses.append(RawSqlOrder(clause))\n        else:\n            order_clauses.append(BareColumn(clause))\n\n    if self._order_clause is None:\n        self._order_clause = OrderBy(tuple(order_clauses))\n    else:\n        # Add to existing ORDER BY clauses\n        self._order_clause = OrderBy((*self._order_clause.clauses, *order_clauses))\n\n    return self\n</code></pre>"},{"location":"reference/embar/query/delete/#embar.query.delete.DeleteQueryReady.run","title":"<code>run()</code>","text":"<pre><code>run() -&gt; None\n</code></pre><pre><code>run() -&gt; DeleteQueryReady[T, Db]\n</code></pre> <p>Run the query against the underlying DB.</p> <p>Convenience method for those not using async. But still works if awaited.</p> Source code in <code>src/embar/query/delete.py</code> <pre><code>def run(self) -&gt; None | DeleteQueryReady[T, Db]:\n    \"\"\"\n    Run the query against the underlying DB.\n\n    Convenience method for those not using async.\n    But still works if awaited.\n    \"\"\"\n    if isinstance(self._db, DbBase):\n        query = self.sql()\n        self._db.execute(query)\n    return self\n</code></pre>"},{"location":"reference/embar/query/delete/#embar.query.delete.DeleteQueryReady.sql","title":"<code>sql()</code>","text":"<p>Combine all the components of the query and build the SQL and bind parameters (psycopg format).</p> Source code in <code>src/embar/query/delete.py</code> <pre><code>def sql(self) -&gt; QuerySingle:\n    \"\"\"\n    Combine all the components of the query and build the SQL and bind parameters (psycopg format).\n    \"\"\"\n\n    sql = f\"\"\"\n    DELETE\n    FROM {self.table.fqn()}\n    \"\"\"\n    sql = dedent(sql).strip()\n\n    count = -1\n\n    def get_count() -&gt; int:\n        nonlocal count\n        count += 1\n        return count\n\n    params: dict[str, Any] = {}\n\n    if self._where_clause is not None:\n        where_data = self._where_clause.sql(get_count)\n        sql += f\"\\nWHERE {where_data.sql}\"\n        params = {**params, **where_data.params}\n\n    if self._order_clause is not None:\n        order_by_query = self._order_clause.sql(get_count)\n        sql += f\"\\nORDER BY {order_by_query.sql}\"\n        params = {**params, **order_by_query.params}\n\n    if self._limit_value is not None:\n        sql += f\"\\nLIMIT {self._limit_value}\"\n\n    sql = sql.strip()\n\n    return QuerySingle(sql, params=params)\n</code></pre>"},{"location":"reference/embar/query/delete/#embar.query.delete.DeleteQueryReady.where","title":"<code>where(where_clause)</code>","text":"<p>Add a WHERE clause to the query.</p> Source code in <code>src/embar/query/delete.py</code> <pre><code>def where(self, where_clause: ClauseBase) -&gt; Self:\n    \"\"\"\n    Add a WHERE clause to the query.\n    \"\"\"\n    self._where_clause = where_clause\n    return self\n</code></pre>"},{"location":"reference/embar/query/delete/#embar.query.delete.DeleteQueryReturning","title":"<code>DeleteQueryReturning</code>","text":"<p><code>DeleteQueryReturning</code> is used to delete data from a table and return it.</p> Source code in <code>src/embar/query/delete.py</code> <pre><code>class DeleteQueryReturning[T: Table, Db: AllDbBase]:\n    \"\"\"\n    `DeleteQueryReturning` is used to delete data from a table and return it.\n    \"\"\"\n\n    table: type[T]\n    _db: Db\n\n    _where_clause: ClauseBase | None = None\n    _order_clause: OrderBy | None = None\n    _limit_value: int | None = None\n\n    def __init__(\n        self,\n        table: type[T],\n        db: Db,\n        where_clause: ClauseBase | None,\n        order_clause: OrderBy | None,\n        limit_value: int | None,\n    ):\n        \"\"\"\n        Create a new SelectQueryReady instance.\n        \"\"\"\n        self.table = table\n        self._db = db\n        self._where_clause = where_clause\n        self._order_clause = order_clause\n        self._limit_value = limit_value\n\n    def __await__(self) -&gt; Generator[Any, None, list[T]]:\n        \"\"\"\n        Async users should construct their query and await it.\n\n        Non-async users have the `run()` convenience method below.\n        But this method will still work if called in an async context against a non-async db.\n\n        The overrides provide for a few different cases:\n        - A Model was passed, in which case that's the return type\n        - `SelectAll` was passed, in which case the return type is the `Table`\n        - This is called with an async db, in which case an error is returned.\n        \"\"\"\n        query = self.sql()\n        model = self._get_model()\n        model = cast(type[T], model)\n        adapter = TypeAdapter(list[model])\n\n        async def awaitable():\n            db = self._db\n            if isinstance(db, AsyncDbBase):\n                data = await db.fetch(query)\n            else:\n                db = cast(DbBase, self._db)\n                data = db.fetch(query)\n            results = adapter.validate_python(data)\n            return results\n\n        return awaitable().__await__()\n\n    @overload\n    def run(self: DeleteQueryReady[T, DbBase]) -&gt; list[T]: ...\n    @overload\n    def run(self: DeleteQueryReady[T, AsyncDbBase]) -&gt; DeleteQueryReturning[T, Db]: ...\n\n    def run(self) -&gt; list[T] | DeleteQueryReturning[T, Db]:\n        \"\"\"\n        Run the query against the underlying DB.\n\n        Convenience method for those not using async.\n        But still works if awaited.\n        \"\"\"\n        if isinstance(self._db, DbBase):\n            query = self.sql()\n            model = self._get_model()\n            model = cast(type[T], model)\n            adapter = TypeAdapter(list[model])\n            data = self._db.fetch(query)\n            results = adapter.validate_python(data)\n            return results\n        return self\n\n    def sql(self) -&gt; QuerySingle:\n        \"\"\"\n        Combine all the components of the query and build the SQL and bind parameters (psycopg format).\n        \"\"\"\n\n        sql = f\"\"\"\n        DELETE\n        FROM {self.table.fqn()}\n        \"\"\"\n        sql = dedent(sql).strip()\n\n        count = -1\n\n        def get_count() -&gt; int:\n            nonlocal count\n            count += 1\n            return count\n\n        params: dict[str, Any] = {}\n\n        if self._where_clause is not None:\n            where_data = self._where_clause.sql(get_count)\n            sql += f\"\\nWHERE {where_data.sql}\"\n            params = {**params, **where_data.params}\n\n        if self._order_clause is not None:\n            order_by_query = self._order_clause.sql(get_count)\n            sql += f\"\\nORDER BY {order_by_query.sql}\"\n            params = {**params, **order_by_query.params}\n\n        if self._limit_value is not None:\n            sql += f\"\\nLIMIT {self._limit_value}\"\n\n        # This is the only difference vs the regular DeleteQueryReady sql\n        sql += \"\\nRETURNING *\"\n\n        sql = sql.strip()\n\n        return QuerySingle(sql, params=params)\n\n    def _get_model(self) -&gt; type[BaseModel]:\n        \"\"\"\n        Generate the dataclass that will be used to deserialize (and validate) the query results.\n        \"\"\"\n        model = generate_model(self.table)\n        return model\n</code></pre>"},{"location":"reference/embar/query/delete/#embar.query.delete.DeleteQueryReturning.__await__","title":"<code>__await__()</code>","text":"<p>Async users should construct their query and await it.</p> <p>Non-async users have the <code>run()</code> convenience method below. But this method will still work if called in an async context against a non-async db.</p> <p>The overrides provide for a few different cases: - A Model was passed, in which case that's the return type - <code>SelectAll</code> was passed, in which case the return type is the <code>Table</code> - This is called with an async db, in which case an error is returned.</p> Source code in <code>src/embar/query/delete.py</code> <pre><code>def __await__(self) -&gt; Generator[Any, None, list[T]]:\n    \"\"\"\n    Async users should construct their query and await it.\n\n    Non-async users have the `run()` convenience method below.\n    But this method will still work if called in an async context against a non-async db.\n\n    The overrides provide for a few different cases:\n    - A Model was passed, in which case that's the return type\n    - `SelectAll` was passed, in which case the return type is the `Table`\n    - This is called with an async db, in which case an error is returned.\n    \"\"\"\n    query = self.sql()\n    model = self._get_model()\n    model = cast(type[T], model)\n    adapter = TypeAdapter(list[model])\n\n    async def awaitable():\n        db = self._db\n        if isinstance(db, AsyncDbBase):\n            data = await db.fetch(query)\n        else:\n            db = cast(DbBase, self._db)\n            data = db.fetch(query)\n        results = adapter.validate_python(data)\n        return results\n\n    return awaitable().__await__()\n</code></pre>"},{"location":"reference/embar/query/delete/#embar.query.delete.DeleteQueryReturning.__init__","title":"<code>__init__(table, db, where_clause, order_clause, limit_value)</code>","text":"<p>Create a new SelectQueryReady instance.</p> Source code in <code>src/embar/query/delete.py</code> <pre><code>def __init__(\n    self,\n    table: type[T],\n    db: Db,\n    where_clause: ClauseBase | None,\n    order_clause: OrderBy | None,\n    limit_value: int | None,\n):\n    \"\"\"\n    Create a new SelectQueryReady instance.\n    \"\"\"\n    self.table = table\n    self._db = db\n    self._where_clause = where_clause\n    self._order_clause = order_clause\n    self._limit_value = limit_value\n</code></pre>"},{"location":"reference/embar/query/delete/#embar.query.delete.DeleteQueryReturning.run","title":"<code>run()</code>","text":"<pre><code>run() -&gt; list[T]\n</code></pre><pre><code>run() -&gt; DeleteQueryReturning[T, Db]\n</code></pre> <p>Run the query against the underlying DB.</p> <p>Convenience method for those not using async. But still works if awaited.</p> Source code in <code>src/embar/query/delete.py</code> <pre><code>def run(self) -&gt; list[T] | DeleteQueryReturning[T, Db]:\n    \"\"\"\n    Run the query against the underlying DB.\n\n    Convenience method for those not using async.\n    But still works if awaited.\n    \"\"\"\n    if isinstance(self._db, DbBase):\n        query = self.sql()\n        model = self._get_model()\n        model = cast(type[T], model)\n        adapter = TypeAdapter(list[model])\n        data = self._db.fetch(query)\n        results = adapter.validate_python(data)\n        return results\n    return self\n</code></pre>"},{"location":"reference/embar/query/delete/#embar.query.delete.DeleteQueryReturning.sql","title":"<code>sql()</code>","text":"<p>Combine all the components of the query and build the SQL and bind parameters (psycopg format).</p> Source code in <code>src/embar/query/delete.py</code> <pre><code>def sql(self) -&gt; QuerySingle:\n    \"\"\"\n    Combine all the components of the query and build the SQL and bind parameters (psycopg format).\n    \"\"\"\n\n    sql = f\"\"\"\n    DELETE\n    FROM {self.table.fqn()}\n    \"\"\"\n    sql = dedent(sql).strip()\n\n    count = -1\n\n    def get_count() -&gt; int:\n        nonlocal count\n        count += 1\n        return count\n\n    params: dict[str, Any] = {}\n\n    if self._where_clause is not None:\n        where_data = self._where_clause.sql(get_count)\n        sql += f\"\\nWHERE {where_data.sql}\"\n        params = {**params, **where_data.params}\n\n    if self._order_clause is not None:\n        order_by_query = self._order_clause.sql(get_count)\n        sql += f\"\\nORDER BY {order_by_query.sql}\"\n        params = {**params, **order_by_query.params}\n\n    if self._limit_value is not None:\n        sql += f\"\\nLIMIT {self._limit_value}\"\n\n    # This is the only difference vs the regular DeleteQueryReady sql\n    sql += \"\\nRETURNING *\"\n\n    sql = sql.strip()\n\n    return QuerySingle(sql, params=params)\n</code></pre>"},{"location":"reference/embar/query/fns/","title":"fns","text":""},{"location":"reference/embar/query/group_by/","title":"group_by","text":"<p>Group by clause for queries.</p>"},{"location":"reference/embar/query/group_by/#embar.query.group_by.GroupBy","title":"<code>GroupBy</code>  <code>dataclass</code>","text":"<p>Represents a GROUP BY clause for queries.</p> Source code in <code>src/embar/query/group_by.py</code> <pre><code>@dataclass\nclass GroupBy:\n    \"\"\"\n    Represents a GROUP BY clause for queries.\n    \"\"\"\n\n    cols: tuple[ColumnBase, ...]\n</code></pre>"},{"location":"reference/embar/query/having/","title":"having","text":"<p>Having clause for filtering grouped queries.</p>"},{"location":"reference/embar/query/having/#embar.query.having.Having","title":"<code>Having</code>  <code>dataclass</code>","text":"<p>Represents a HAVING clause for filtering aggregated/grouped results.</p> <p>HAVING clauses are similar to WHERE clauses but operate on grouped/aggregated data. They are typically used with GROUP BY to filter groups based on aggregate conditions.</p> <pre><code>from embar.query.having import Having\nfrom embar.query.where import Gt\nfrom embar.column.base import ColumnBase, ColumnInfo\n\n# Example: HAVING COUNT(*) &gt; 5\ncount_col = ColumnBase()\ncount_col.info = ColumnInfo(\n    _table_name=lambda: \"users\",\n    name=\"count\",\n    col_type=\"INTEGER\",\n    py_type=int,\n    primary=False,\n    not_null=False\n)\nhaving = Having(Gt(count_col, 5))\n</code></pre> Source code in <code>src/embar/query/having.py</code> <pre><code>@dataclass\nclass Having:\n    \"\"\"\n    Represents a HAVING clause for filtering aggregated/grouped results.\n\n    HAVING clauses are similar to WHERE clauses but operate on grouped/aggregated data.\n    They are typically used with GROUP BY to filter groups based on aggregate conditions.\n\n    ```python\n    from embar.query.having import Having\n    from embar.query.where import Gt\n    from embar.column.base import ColumnBase, ColumnInfo\n\n    # Example: HAVING COUNT(*) &gt; 5\n    count_col = ColumnBase()\n    count_col.info = ColumnInfo(\n        _table_name=lambda: \"users\",\n        name=\"count\",\n        col_type=\"INTEGER\",\n        py_type=int,\n        primary=False,\n        not_null=False\n    )\n    having = Having(Gt(count_col, 5))\n    ```\n    \"\"\"\n\n    clause: ClauseBase\n</code></pre>"},{"location":"reference/embar/query/insert/","title":"insert","text":"<p>Insert query builder.</p>"},{"location":"reference/embar/query/insert/#embar.query.insert.InsertQuery","title":"<code>InsertQuery</code>","text":"<p><code>InsertQuery</code> is used to insert data into a table.</p> <p>It is generic over the <code>Table</code> being inserted into, and the database being used. <code>InsertQuery</code> is never used directly, but always returned by a Db instance. It returns an <code>InsertQueryReady</code> instance once <code>values()</code> has been called.</p> <pre><code>from embar.db.pg import PgDb\nfrom embar.query.insert import InsertQuery\ndb = PgDb(None)\ninsert = db.insert(None)\nassert isinstance(insert, InsertQuery)\n</code></pre> Source code in <code>src/embar/query/insert.py</code> <pre><code>class InsertQuery[T: Table, Db: AllDbBase]:\n    \"\"\"\n    `InsertQuery` is used to insert data into a table.\n\n    It is generic over the `Table` being inserted into, and the database being used.\n    `InsertQuery` is never used directly, but always returned by a Db instance.\n    It returns an `InsertQueryReady` instance once `values()` has been called.\n\n    ```python\n    from embar.db.pg import PgDb\n    from embar.query.insert import InsertQuery\n    db = PgDb(None)\n    insert = db.insert(None)\n    assert isinstance(insert, InsertQuery)\n    ```\n    \"\"\"\n\n    _db: Db\n    table: type[T]\n\n    def __init__(self, table: type[T], db: Db):\n        \"\"\"\n        Create a new InsertQuery instance.\n        \"\"\"\n        self.table = table\n        self._db = db\n\n    def values(self, *items: T) -&gt; InsertQueryReady[T, Db]:\n        \"\"\"\n        Load a sequence of items into the table.\n        \"\"\"\n        return InsertQueryReady(table=self.table, db=self._db, items=items)\n</code></pre>"},{"location":"reference/embar/query/insert/#embar.query.insert.InsertQuery.__init__","title":"<code>__init__(table, db)</code>","text":"<p>Create a new InsertQuery instance.</p> Source code in <code>src/embar/query/insert.py</code> <pre><code>def __init__(self, table: type[T], db: Db):\n    \"\"\"\n    Create a new InsertQuery instance.\n    \"\"\"\n    self.table = table\n    self._db = db\n</code></pre>"},{"location":"reference/embar/query/insert/#embar.query.insert.InsertQuery.values","title":"<code>values(*items)</code>","text":"<p>Load a sequence of items into the table.</p> Source code in <code>src/embar/query/insert.py</code> <pre><code>def values(self, *items: T) -&gt; InsertQueryReady[T, Db]:\n    \"\"\"\n    Load a sequence of items into the table.\n    \"\"\"\n    return InsertQueryReady(table=self.table, db=self._db, items=items)\n</code></pre>"},{"location":"reference/embar/query/insert/#embar.query.insert.InsertQueryReady","title":"<code>InsertQueryReady</code>","text":"<p><code>InsertQueryReady</code> is an insert query that is ready to be awaited or run.</p> Source code in <code>src/embar/query/insert.py</code> <pre><code>class InsertQueryReady[T: Table, Db: AllDbBase]:\n    \"\"\"\n    `InsertQueryReady` is an insert query that is ready to be awaited or run.\n    \"\"\"\n\n    _db: Db\n    table: type[T]\n    items: Sequence[T]\n    on_conflict: OnConflict | None = None\n\n    def __init__(self, table: type[T], db: Db, items: Sequence[T]):\n        \"\"\"\n        Create a new InsertQueryReady instance.\n        \"\"\"\n        self.table = table\n        self._db = db\n        self.items = items\n\n    def returning(self) -&gt; InsertQueryReturning[T, Db]:\n        return InsertQueryReturning(self.table, self._db, self.items, on_conflict=self.on_conflict)\n\n    def on_conflict_do_nothing(self, target: TupleAtLeastOne | None = None) -&gt; Self:\n        self.on_conflict = OnConflictDoNothing(target)\n        return self\n\n    def on_conflict_do_update(self, target: TupleAtLeastOne, update: dict[str, PyType]) -&gt; Self:\n        self.on_conflict = OnConflictDoUpdate(target, update)\n        return self\n\n    def __await__(self):\n        \"\"\"\n        async users should construct their query and await it.\n\n        non-async users have the `run()` convenience method below.\n        \"\"\"\n        query = self.sql()\n\n        async def awaitable():\n            db = self._db\n            if isinstance(db, AsyncDbBase):\n                return await db.executemany(query)\n            else:\n                db = cast(DbBase, self._db)\n                return db.executemany(query)\n\n        return awaitable().__await__()\n\n    @overload\n    def run(self: InsertQueryReady[T, DbBase]) -&gt; None: ...\n    @overload\n    def run(self: InsertQueryReady[T, AsyncDbBase]) -&gt; InsertQueryReady[T, Db]: ...\n\n    def run(self) -&gt; InsertQueryReady[T, Db] | None:\n        \"\"\"\n        Run the query against the underlying DB.\n\n        Convenience method for those not using async.\n        But still works if awaited.\n        \"\"\"\n        if isinstance(self._db, DbBase):\n            query = self.sql()\n            return self._db.executemany(query)\n        return self\n\n    def sql(self) -&gt; QueryMany:\n        \"\"\"\n        Create the SQL query and binding parameters (psycopg format) for the query.\n\n        ```python\n        from embar.column.common import Text\n        from embar.table import Table\n        from embar.query.insert import InsertQueryReady\n        class MyTable(Table):\n            my_col: Text = Text()\n        row = MyTable(my_col=\"foo\")\n        insert = InsertQueryReady(db=None, table=MyTable, items=[row])\n        query = insert.sql()\n        assert query.sql == 'INSERT INTO \"my_table\" (\"my_col\") VALUES (%(my_col)s)'\n        assert query.many_params == [{'my_col': 'foo'}]\n        ```\n        \"\"\"\n\n        column_names = self.table.column_names().values()\n        column_names_quoted = [f'\"{c}\"' for c in column_names]\n        columns = \", \".join(column_names_quoted)\n        placeholders = [f\"%({name})s\" for name in column_names]\n        placeholder_str = \", \".join(placeholders)\n        sql = f\"INSERT INTO {self.table.fqn()} ({columns}) VALUES ({placeholder_str})\"\n        values = [it.value_dict() for it in self.items]\n\n        if self.on_conflict is not None:\n            count = -1\n\n            def get_count() -&gt; int:\n                nonlocal count\n                count += 1\n                return count\n\n            conflict_query = self.on_conflict.sql(get_count)\n            values = [{**row, **conflict_query.params} for row in values]\n            sql += f\"\\n{conflict_query.sql}\"\n\n        return QueryMany(sql, many_params=values)\n</code></pre>"},{"location":"reference/embar/query/insert/#embar.query.insert.InsertQueryReady.__await__","title":"<code>__await__()</code>","text":"<p>async users should construct their query and await it.</p> <p>non-async users have the <code>run()</code> convenience method below.</p> Source code in <code>src/embar/query/insert.py</code> <pre><code>def __await__(self):\n    \"\"\"\n    async users should construct their query and await it.\n\n    non-async users have the `run()` convenience method below.\n    \"\"\"\n    query = self.sql()\n\n    async def awaitable():\n        db = self._db\n        if isinstance(db, AsyncDbBase):\n            return await db.executemany(query)\n        else:\n            db = cast(DbBase, self._db)\n            return db.executemany(query)\n\n    return awaitable().__await__()\n</code></pre>"},{"location":"reference/embar/query/insert/#embar.query.insert.InsertQueryReady.__init__","title":"<code>__init__(table, db, items)</code>","text":"<p>Create a new InsertQueryReady instance.</p> Source code in <code>src/embar/query/insert.py</code> <pre><code>def __init__(self, table: type[T], db: Db, items: Sequence[T]):\n    \"\"\"\n    Create a new InsertQueryReady instance.\n    \"\"\"\n    self.table = table\n    self._db = db\n    self.items = items\n</code></pre>"},{"location":"reference/embar/query/insert/#embar.query.insert.InsertQueryReady.run","title":"<code>run()</code>","text":"<pre><code>run() -&gt; None\n</code></pre><pre><code>run() -&gt; InsertQueryReady[T, Db]\n</code></pre> <p>Run the query against the underlying DB.</p> <p>Convenience method for those not using async. But still works if awaited.</p> Source code in <code>src/embar/query/insert.py</code> <pre><code>def run(self) -&gt; InsertQueryReady[T, Db] | None:\n    \"\"\"\n    Run the query against the underlying DB.\n\n    Convenience method for those not using async.\n    But still works if awaited.\n    \"\"\"\n    if isinstance(self._db, DbBase):\n        query = self.sql()\n        return self._db.executemany(query)\n    return self\n</code></pre>"},{"location":"reference/embar/query/insert/#embar.query.insert.InsertQueryReady.sql","title":"<code>sql()</code>","text":"<p>Create the SQL query and binding parameters (psycopg format) for the query.</p> <pre><code>from embar.column.common import Text\nfrom embar.table import Table\nfrom embar.query.insert import InsertQueryReady\nclass MyTable(Table):\n    my_col: Text = Text()\nrow = MyTable(my_col=\"foo\")\ninsert = InsertQueryReady(db=None, table=MyTable, items=[row])\nquery = insert.sql()\nassert query.sql == 'INSERT INTO \"my_table\" (\"my_col\") VALUES (%(my_col)s)'\nassert query.many_params == [{'my_col': 'foo'}]\n</code></pre> Source code in <code>src/embar/query/insert.py</code> <pre><code>def sql(self) -&gt; QueryMany:\n    \"\"\"\n    Create the SQL query and binding parameters (psycopg format) for the query.\n\n    ```python\n    from embar.column.common import Text\n    from embar.table import Table\n    from embar.query.insert import InsertQueryReady\n    class MyTable(Table):\n        my_col: Text = Text()\n    row = MyTable(my_col=\"foo\")\n    insert = InsertQueryReady(db=None, table=MyTable, items=[row])\n    query = insert.sql()\n    assert query.sql == 'INSERT INTO \"my_table\" (\"my_col\") VALUES (%(my_col)s)'\n    assert query.many_params == [{'my_col': 'foo'}]\n    ```\n    \"\"\"\n\n    column_names = self.table.column_names().values()\n    column_names_quoted = [f'\"{c}\"' for c in column_names]\n    columns = \", \".join(column_names_quoted)\n    placeholders = [f\"%({name})s\" for name in column_names]\n    placeholder_str = \", \".join(placeholders)\n    sql = f\"INSERT INTO {self.table.fqn()} ({columns}) VALUES ({placeholder_str})\"\n    values = [it.value_dict() for it in self.items]\n\n    if self.on_conflict is not None:\n        count = -1\n\n        def get_count() -&gt; int:\n            nonlocal count\n            count += 1\n            return count\n\n        conflict_query = self.on_conflict.sql(get_count)\n        values = [{**row, **conflict_query.params} for row in values]\n        sql += f\"\\n{conflict_query.sql}\"\n\n    return QueryMany(sql, many_params=values)\n</code></pre>"},{"location":"reference/embar/query/insert/#embar.query.insert.InsertQueryReturning","title":"<code>InsertQueryReturning</code>","text":"<p><code>InsertQueryReturning</code> is an insert query that will return what it inserts.</p> Source code in <code>src/embar/query/insert.py</code> <pre><code>class InsertQueryReturning[T: Table, Db: AllDbBase]:\n    \"\"\"\n    `InsertQueryReturning` is an insert query that will return what it inserts.\n    \"\"\"\n\n    _db: Db\n    table: type[T]\n    items: Sequence[T]\n    on_conflict: OnConflict | None\n\n    def __init__(self, table: type[T], db: Db, items: Sequence[T], on_conflict: OnConflict | None):\n        \"\"\"\n        Create a new InsertQueryReturning instance.\n        \"\"\"\n        self.table = table\n        self._db = db\n        self.items = items\n        self.on_conflict = on_conflict\n\n    def __await__(self) -&gt; Generator[Any, None, Sequence[T]]:\n        \"\"\"\n        async users should construct their query and await it.\n\n        non-async users have the `run()` convenience method below.\n        \"\"\"\n        query = self.sql()\n        model = self._get_model()\n        model = cast(type[T], model)\n        adapter = TypeAdapter(list[model])\n\n        async def awaitable():\n            db = self._db\n            if isinstance(db, AsyncDbBase):\n                data = await db.fetch(query)\n            else:\n                db = cast(DbBase, self._db)\n                data = db.fetch(query)\n            results = adapter.validate_python(data)\n            return results\n\n        return awaitable().__await__()\n\n    @overload\n    def run(self: InsertQueryReturning[T, DbBase]) -&gt; list[T]: ...\n    @overload\n    def run(self: InsertQueryReturning[T, AsyncDbBase]) -&gt; InsertQueryReturning[T, Db]: ...\n\n    def run(self) -&gt; Sequence[T] | InsertQueryReturning[T, Db]:\n        \"\"\"\n        Run the query against the underlying DB.\n\n        Convenience method for those not using async.\n        But still works if awaited.\n        \"\"\"\n        if isinstance(self._db, DbBase):\n            query = self.sql()\n            model = self._get_model()\n            model = cast(type[T], model)\n            adapter = TypeAdapter(list[model])\n            data = self._db.fetch(query)\n            results = adapter.validate_python(data)\n            return results\n        return self\n\n    def sql(self) -&gt; QueryMany:\n        \"\"\"\n        Create the SQL query and binding parameters (psycopg format) for the query.\n        \"\"\"\n        column_names = self.table.column_names().values()\n        column_names_quoted = [f'\"{c}\"' for c in column_names]\n        columns = \", \".join(column_names_quoted)\n        placeholders = [f\"%({name})s\" for name in column_names]\n        placeholder_str = \", \".join(placeholders)\n        sql = f\"INSERT INTO {self.table.fqn()} ({columns}) VALUES ({placeholder_str})\"\n        values = [it.value_dict() for it in self.items]\n\n        if self.on_conflict is not None:\n            count = -1\n\n            def get_count() -&gt; int:\n                nonlocal count\n                count += 1\n                return count\n\n            conflict_query = self.on_conflict.sql(get_count)\n            values = [{**row, **conflict_query.params} for row in values]\n            sql += f\"\\n{conflict_query.sql}\"\n\n        sql += \" RETURNING *\"\n        return QueryMany(sql, many_params=values)\n\n    def _get_model(self) -&gt; type[BaseModel]:\n        \"\"\"\n        Generate the dataclass that will be used to deserialize (and validate) the query results.\n        \"\"\"\n        model = generate_model(self.table)\n        return model\n</code></pre>"},{"location":"reference/embar/query/insert/#embar.query.insert.InsertQueryReturning.__await__","title":"<code>__await__()</code>","text":"<p>async users should construct their query and await it.</p> <p>non-async users have the <code>run()</code> convenience method below.</p> Source code in <code>src/embar/query/insert.py</code> <pre><code>def __await__(self) -&gt; Generator[Any, None, Sequence[T]]:\n    \"\"\"\n    async users should construct their query and await it.\n\n    non-async users have the `run()` convenience method below.\n    \"\"\"\n    query = self.sql()\n    model = self._get_model()\n    model = cast(type[T], model)\n    adapter = TypeAdapter(list[model])\n\n    async def awaitable():\n        db = self._db\n        if isinstance(db, AsyncDbBase):\n            data = await db.fetch(query)\n        else:\n            db = cast(DbBase, self._db)\n            data = db.fetch(query)\n        results = adapter.validate_python(data)\n        return results\n\n    return awaitable().__await__()\n</code></pre>"},{"location":"reference/embar/query/insert/#embar.query.insert.InsertQueryReturning.__init__","title":"<code>__init__(table, db, items, on_conflict)</code>","text":"<p>Create a new InsertQueryReturning instance.</p> Source code in <code>src/embar/query/insert.py</code> <pre><code>def __init__(self, table: type[T], db: Db, items: Sequence[T], on_conflict: OnConflict | None):\n    \"\"\"\n    Create a new InsertQueryReturning instance.\n    \"\"\"\n    self.table = table\n    self._db = db\n    self.items = items\n    self.on_conflict = on_conflict\n</code></pre>"},{"location":"reference/embar/query/insert/#embar.query.insert.InsertQueryReturning.run","title":"<code>run()</code>","text":"<pre><code>run() -&gt; list[T]\n</code></pre><pre><code>run() -&gt; InsertQueryReturning[T, Db]\n</code></pre> <p>Run the query against the underlying DB.</p> <p>Convenience method for those not using async. But still works if awaited.</p> Source code in <code>src/embar/query/insert.py</code> <pre><code>def run(self) -&gt; Sequence[T] | InsertQueryReturning[T, Db]:\n    \"\"\"\n    Run the query against the underlying DB.\n\n    Convenience method for those not using async.\n    But still works if awaited.\n    \"\"\"\n    if isinstance(self._db, DbBase):\n        query = self.sql()\n        model = self._get_model()\n        model = cast(type[T], model)\n        adapter = TypeAdapter(list[model])\n        data = self._db.fetch(query)\n        results = adapter.validate_python(data)\n        return results\n    return self\n</code></pre>"},{"location":"reference/embar/query/insert/#embar.query.insert.InsertQueryReturning.sql","title":"<code>sql()</code>","text":"<p>Create the SQL query and binding parameters (psycopg format) for the query.</p> Source code in <code>src/embar/query/insert.py</code> <pre><code>def sql(self) -&gt; QueryMany:\n    \"\"\"\n    Create the SQL query and binding parameters (psycopg format) for the query.\n    \"\"\"\n    column_names = self.table.column_names().values()\n    column_names_quoted = [f'\"{c}\"' for c in column_names]\n    columns = \", \".join(column_names_quoted)\n    placeholders = [f\"%({name})s\" for name in column_names]\n    placeholder_str = \", \".join(placeholders)\n    sql = f\"INSERT INTO {self.table.fqn()} ({columns}) VALUES ({placeholder_str})\"\n    values = [it.value_dict() for it in self.items]\n\n    if self.on_conflict is not None:\n        count = -1\n\n        def get_count() -&gt; int:\n            nonlocal count\n            count += 1\n            return count\n\n        conflict_query = self.on_conflict.sql(get_count)\n        values = [{**row, **conflict_query.params} for row in values]\n        sql += f\"\\n{conflict_query.sql}\"\n\n    sql += \" RETURNING *\"\n    return QueryMany(sql, many_params=values)\n</code></pre>"},{"location":"reference/embar/query/join/","title":"join","text":"<p>Join clauses for queries.</p>"},{"location":"reference/embar/query/join/#embar.query.join.CrossJoin","title":"<code>CrossJoin</code>","text":"<p>               Bases: <code>JoinClause</code></p> <p>CROSS JOIN clause.</p> Source code in <code>src/embar/query/join.py</code> <pre><code>class CrossJoin(JoinClause):\n    \"\"\"\n    CROSS JOIN clause.\n    \"\"\"\n\n    table: type[Table]\n\n    def __init__(self, table: type[Table]):\n        \"\"\"\n        Create a new CrossJoin instance.\n        \"\"\"\n        self.table = table\n\n    @override\n    def get(self, get_count: GetCount) -&gt; QuerySingle:\n        \"\"\"\n        Generate the CROSS JOIN SQL.\n        \"\"\"\n        sql = f\"CROSS JOIN {self.table.fqn()}\"\n        return QuerySingle(sql=sql)\n</code></pre>"},{"location":"reference/embar/query/join/#embar.query.join.CrossJoin.__init__","title":"<code>__init__(table)</code>","text":"<p>Create a new CrossJoin instance.</p> Source code in <code>src/embar/query/join.py</code> <pre><code>def __init__(self, table: type[Table]):\n    \"\"\"\n    Create a new CrossJoin instance.\n    \"\"\"\n    self.table = table\n</code></pre>"},{"location":"reference/embar/query/join/#embar.query.join.CrossJoin.get","title":"<code>get(get_count)</code>","text":"<p>Generate the CROSS JOIN SQL.</p> Source code in <code>src/embar/query/join.py</code> <pre><code>@override\ndef get(self, get_count: GetCount) -&gt; QuerySingle:\n    \"\"\"\n    Generate the CROSS JOIN SQL.\n    \"\"\"\n    sql = f\"CROSS JOIN {self.table.fqn()}\"\n    return QuerySingle(sql=sql)\n</code></pre>"},{"location":"reference/embar/query/join/#embar.query.join.FullJoin","title":"<code>FullJoin</code>","text":"<p>               Bases: <code>JoinClause</code></p> <p>FULL OUTER JOIN clause.</p> Source code in <code>src/embar/query/join.py</code> <pre><code>class FullJoin(JoinClause):\n    \"\"\"\n    FULL OUTER JOIN clause.\n    \"\"\"\n\n    table: type[Table]\n    on: ClauseBase\n\n    def __init__(self, table: type[Table], on: ClauseBase):\n        \"\"\"\n        Create a new FullJoin instance.\n        \"\"\"\n        self.table = table\n        self.on = on\n\n    @override\n    def get(self, get_count: GetCount) -&gt; QuerySingle:\n        \"\"\"\n        Generate the FULL OUTER JOIN SQL.\n        \"\"\"\n        on = self.on.sql(get_count)\n\n        sql = f\"FULL OUTER JOIN {self.table.fqn()} ON {on.sql}\"\n        return QuerySingle(sql=sql, params=on.params)\n</code></pre>"},{"location":"reference/embar/query/join/#embar.query.join.FullJoin.__init__","title":"<code>__init__(table, on)</code>","text":"<p>Create a new FullJoin instance.</p> Source code in <code>src/embar/query/join.py</code> <pre><code>def __init__(self, table: type[Table], on: ClauseBase):\n    \"\"\"\n    Create a new FullJoin instance.\n    \"\"\"\n    self.table = table\n    self.on = on\n</code></pre>"},{"location":"reference/embar/query/join/#embar.query.join.FullJoin.get","title":"<code>get(get_count)</code>","text":"<p>Generate the FULL OUTER JOIN SQL.</p> Source code in <code>src/embar/query/join.py</code> <pre><code>@override\ndef get(self, get_count: GetCount) -&gt; QuerySingle:\n    \"\"\"\n    Generate the FULL OUTER JOIN SQL.\n    \"\"\"\n    on = self.on.sql(get_count)\n\n    sql = f\"FULL OUTER JOIN {self.table.fqn()} ON {on.sql}\"\n    return QuerySingle(sql=sql, params=on.params)\n</code></pre>"},{"location":"reference/embar/query/join/#embar.query.join.InnerJoin","title":"<code>InnerJoin</code>","text":"<p>               Bases: <code>JoinClause</code></p> <p>INNER JOIN clause.</p> Source code in <code>src/embar/query/join.py</code> <pre><code>class InnerJoin(JoinClause):\n    \"\"\"\n    INNER JOIN clause.\n    \"\"\"\n\n    table: type[Table]\n    on: ClauseBase\n\n    def __init__(self, table: type[Table], on: ClauseBase):\n        \"\"\"\n        Create a new InnerJoin instance.\n        \"\"\"\n        self.table = table\n        self.on = on\n\n    @override\n    def get(self, get_count: GetCount) -&gt; QuerySingle:\n        \"\"\"\n        Generate the INNER JOIN SQL.\n        \"\"\"\n        on = self.on.sql(get_count)\n\n        sql = f\"INNER JOIN {self.table.fqn()} ON {on.sql}\"\n        return QuerySingle(sql=sql, params=on.params)\n</code></pre>"},{"location":"reference/embar/query/join/#embar.query.join.InnerJoin.__init__","title":"<code>__init__(table, on)</code>","text":"<p>Create a new InnerJoin instance.</p> Source code in <code>src/embar/query/join.py</code> <pre><code>def __init__(self, table: type[Table], on: ClauseBase):\n    \"\"\"\n    Create a new InnerJoin instance.\n    \"\"\"\n    self.table = table\n    self.on = on\n</code></pre>"},{"location":"reference/embar/query/join/#embar.query.join.InnerJoin.get","title":"<code>get(get_count)</code>","text":"<p>Generate the INNER JOIN SQL.</p> Source code in <code>src/embar/query/join.py</code> <pre><code>@override\ndef get(self, get_count: GetCount) -&gt; QuerySingle:\n    \"\"\"\n    Generate the INNER JOIN SQL.\n    \"\"\"\n    on = self.on.sql(get_count)\n\n    sql = f\"INNER JOIN {self.table.fqn()} ON {on.sql}\"\n    return QuerySingle(sql=sql, params=on.params)\n</code></pre>"},{"location":"reference/embar/query/join/#embar.query.join.JoinClause","title":"<code>JoinClause</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for all join clauses.</p> Source code in <code>src/embar/query/join.py</code> <pre><code>class JoinClause(ABC):\n    \"\"\"\n    Base class for all join clauses.\n    \"\"\"\n\n    @abstractmethod\n    def get(self, get_count: GetCount) -&gt; QuerySingle:\n        \"\"\"\n        Generate the SQL for this join clause.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"reference/embar/query/join/#embar.query.join.JoinClause.get","title":"<code>get(get_count)</code>  <code>abstractmethod</code>","text":"<p>Generate the SQL for this join clause.</p> Source code in <code>src/embar/query/join.py</code> <pre><code>@abstractmethod\ndef get(self, get_count: GetCount) -&gt; QuerySingle:\n    \"\"\"\n    Generate the SQL for this join clause.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/embar/query/join/#embar.query.join.LeftJoin","title":"<code>LeftJoin</code>","text":"<p>               Bases: <code>JoinClause</code></p> <p>LEFT JOIN clause.</p> Source code in <code>src/embar/query/join.py</code> <pre><code>class LeftJoin(JoinClause):\n    \"\"\"\n    LEFT JOIN clause.\n    \"\"\"\n\n    table: type[Table]\n    on: ClauseBase\n\n    def __init__(self, table: type[Table], on: ClauseBase):\n        \"\"\"\n        Create a new LeftJoin instance.\n        \"\"\"\n        self.table = table\n        self.on = on\n\n    @override\n    def get(self, get_count: GetCount) -&gt; QuerySingle:\n        \"\"\"\n        Generate the LEFT JOIN SQL.\n        \"\"\"\n        on = self.on.sql(get_count)\n\n        sql = f\"LEFT JOIN {self.table.fqn()} ON {on.sql}\"\n        return QuerySingle(sql=sql, params=on.params)\n</code></pre>"},{"location":"reference/embar/query/join/#embar.query.join.LeftJoin.__init__","title":"<code>__init__(table, on)</code>","text":"<p>Create a new LeftJoin instance.</p> Source code in <code>src/embar/query/join.py</code> <pre><code>def __init__(self, table: type[Table], on: ClauseBase):\n    \"\"\"\n    Create a new LeftJoin instance.\n    \"\"\"\n    self.table = table\n    self.on = on\n</code></pre>"},{"location":"reference/embar/query/join/#embar.query.join.LeftJoin.get","title":"<code>get(get_count)</code>","text":"<p>Generate the LEFT JOIN SQL.</p> Source code in <code>src/embar/query/join.py</code> <pre><code>@override\ndef get(self, get_count: GetCount) -&gt; QuerySingle:\n    \"\"\"\n    Generate the LEFT JOIN SQL.\n    \"\"\"\n    on = self.on.sql(get_count)\n\n    sql = f\"LEFT JOIN {self.table.fqn()} ON {on.sql}\"\n    return QuerySingle(sql=sql, params=on.params)\n</code></pre>"},{"location":"reference/embar/query/join/#embar.query.join.RightJoin","title":"<code>RightJoin</code>","text":"<p>               Bases: <code>JoinClause</code></p> <p>RIGHT JOIN clause.</p> Source code in <code>src/embar/query/join.py</code> <pre><code>class RightJoin(JoinClause):\n    \"\"\"\n    RIGHT JOIN clause.\n    \"\"\"\n\n    table: type[Table]\n    on: ClauseBase\n\n    def __init__(self, table: type[Table], on: ClauseBase):\n        \"\"\"\n        Create a new RightJoin instance.\n        \"\"\"\n        self.table = table\n        self.on = on\n\n    @override\n    def get(self, get_count: GetCount) -&gt; QuerySingle:\n        \"\"\"\n        Generate the RIGHT JOIN SQL.\n        \"\"\"\n        on = self.on.sql(get_count)\n\n        sql = f\"RIGHT JOIN {self.table.fqn()} ON {on.sql}\"\n        return QuerySingle(sql=sql, params=on.params)\n</code></pre>"},{"location":"reference/embar/query/join/#embar.query.join.RightJoin.__init__","title":"<code>__init__(table, on)</code>","text":"<p>Create a new RightJoin instance.</p> Source code in <code>src/embar/query/join.py</code> <pre><code>def __init__(self, table: type[Table], on: ClauseBase):\n    \"\"\"\n    Create a new RightJoin instance.\n    \"\"\"\n    self.table = table\n    self.on = on\n</code></pre>"},{"location":"reference/embar/query/join/#embar.query.join.RightJoin.get","title":"<code>get(get_count)</code>","text":"<p>Generate the RIGHT JOIN SQL.</p> Source code in <code>src/embar/query/join.py</code> <pre><code>@override\ndef get(self, get_count: GetCount) -&gt; QuerySingle:\n    \"\"\"\n    Generate the RIGHT JOIN SQL.\n    \"\"\"\n    on = self.on.sql(get_count)\n\n    sql = f\"RIGHT JOIN {self.table.fqn()} ON {on.sql}\"\n    return QuerySingle(sql=sql, params=on.params)\n</code></pre>"},{"location":"reference/embar/query/many/","title":"many","text":"<p>Types for nesting arrays in queries.</p>"},{"location":"reference/embar/query/many/#embar.query.many.ManyColumn","title":"<code>ManyColumn</code>  <code>dataclass</code>","text":"<p>Used to nest arrays of column results.</p> Source code in <code>src/embar/query/many.py</code> <pre><code>@dataclass\nclass ManyColumn[T: ColumnBase]:\n    \"\"\"\n    Used to nest arrays of column results.\n    \"\"\"\n\n    of: T\n</code></pre>"},{"location":"reference/embar/query/many/#embar.query.many.ManyTable","title":"<code>ManyTable</code>  <code>dataclass</code>","text":"<p>Used to nest arrays of entire tables.</p> Source code in <code>src/embar/query/many.py</code> <pre><code>@dataclass\nclass ManyTable[T: type[TableBase]]:\n    \"\"\"\n    Used to nest arrays of entire tables.\n    \"\"\"\n\n    of: T\n</code></pre>"},{"location":"reference/embar/query/many/#embar.query.many.OneTable","title":"<code>OneTable</code>  <code>dataclass</code>","text":"<p>Used to nest arrays of entire tables.</p> Source code in <code>src/embar/query/many.py</code> <pre><code>@dataclass\nclass OneTable[T: type[TableBase]]:\n    \"\"\"\n    Used to nest arrays of entire tables.\n    \"\"\"\n\n    of: T\n</code></pre>"},{"location":"reference/embar/query/order_by/","title":"order_by","text":"<p>Order by clause for sorting query results.</p>"},{"location":"reference/embar/query/order_by/#embar.query.order_by.Asc","title":"<code>Asc</code>","text":"<p>               Bases: <code>ClauseBase</code></p> <p>Represents an ascending sort order for a column.</p> <pre><code>from embar.query.order_by import Asc\nfrom embar.column.base import ColumnBase, ColumnInfo\n\ncol = ColumnBase()\ncol.info = ColumnInfo(\n    _table_name=lambda: \"users\",\n    name=\"age\",\n    col_type=\"INTEGER\",\n    py_type=int,\n    primary=False,\n    not_null=False\n)\nasc = Asc(col, nulls=\"last\")\nsql = asc.sql(lambda: 0)\nassert sql.sql == '\"users\".\"age\" ASC NULLS LAST'\n</code></pre> Source code in <code>src/embar/query/order_by.py</code> <pre><code>class Asc(ClauseBase):\n    \"\"\"\n    Represents an ascending sort order for a column.\n\n    ```python\n    from embar.query.order_by import Asc\n    from embar.column.base import ColumnBase, ColumnInfo\n\n    col = ColumnBase()\n    col.info = ColumnInfo(\n        _table_name=lambda: \"users\",\n        name=\"age\",\n        col_type=\"INTEGER\",\n        py_type=int,\n        primary=False,\n        not_null=False\n    )\n    asc = Asc(col, nulls=\"last\")\n    sql = asc.sql(lambda: 0)\n    assert sql.sql == '\"users\".\"age\" ASC NULLS LAST'\n    ```\n    \"\"\"\n\n    clause: ColumnBase | ClauseBase\n    nulls: NullsOrdering | None\n\n    def __init__(self, clause: ColumnBase | ClauseBase, nulls: NullsOrdering | None = None):\n        \"\"\"\n        Create an ascending sort order.\n\n        Args:\n            col: The column to sort by\n            nulls: Optional nulls ordering (\"first\" or \"last\")\n        \"\"\"\n        self.clause = clause\n        self.nulls = nulls\n\n    @override\n    def sql(self, get_count: GetCount) -&gt; QuerySingle:\n        \"\"\"Generate the SQL fragment.\"\"\"\n        return _asc_or_desc_sql(\n            self.clause,\n            self.nulls,\n            True,\n            get_count,\n        )\n</code></pre>"},{"location":"reference/embar/query/order_by/#embar.query.order_by.Asc.__init__","title":"<code>__init__(clause, nulls=None)</code>","text":"<p>Create an ascending sort order.</p> <p>Parameters:</p> Name Type Description Default <code>col</code> <p>The column to sort by</p> required <code>nulls</code> <code>NullsOrdering | None</code> <p>Optional nulls ordering (\"first\" or \"last\")</p> <code>None</code> Source code in <code>src/embar/query/order_by.py</code> <pre><code>def __init__(self, clause: ColumnBase | ClauseBase, nulls: NullsOrdering | None = None):\n    \"\"\"\n    Create an ascending sort order.\n\n    Args:\n        col: The column to sort by\n        nulls: Optional nulls ordering (\"first\" or \"last\")\n    \"\"\"\n    self.clause = clause\n    self.nulls = nulls\n</code></pre>"},{"location":"reference/embar/query/order_by/#embar.query.order_by.Asc.sql","title":"<code>sql(get_count)</code>","text":"<p>Generate the SQL fragment.</p> Source code in <code>src/embar/query/order_by.py</code> <pre><code>@override\ndef sql(self, get_count: GetCount) -&gt; QuerySingle:\n    \"\"\"Generate the SQL fragment.\"\"\"\n    return _asc_or_desc_sql(\n        self.clause,\n        self.nulls,\n        True,\n        get_count,\n    )\n</code></pre>"},{"location":"reference/embar/query/order_by/#embar.query.order_by.BareColumn","title":"<code>BareColumn</code>","text":"<p>               Bases: <code>ClauseBase</code></p> <p>Represents a bare column reference (defaults to ASC).</p> <p>This is used internally when a column is passed directly to order_by().</p> <pre><code>from embar.query.order_by import BareColumn\nfrom embar.column.base import ColumnBase, ColumnInfo\n\ncol = ColumnBase()\ncol.info = ColumnInfo(\n    _table_name=lambda: \"users\",\n    name=\"id\",\n    col_type=\"INTEGER\",\n    py_type=int,\n    primary=False,\n    not_null=False\n)\nbare = BareColumn(col)\nsql = bare.sql(lambda: 0)\nassert sql.sql == '\"users\".\"id\"'\n</code></pre> Source code in <code>src/embar/query/order_by.py</code> <pre><code>class BareColumn(ClauseBase):\n    \"\"\"\n    Represents a bare column reference (defaults to ASC).\n\n    This is used internally when a column is passed directly to order_by().\n\n    ```python\n    from embar.query.order_by import BareColumn\n    from embar.column.base import ColumnBase, ColumnInfo\n\n    col = ColumnBase()\n    col.info = ColumnInfo(\n        _table_name=lambda: \"users\",\n        name=\"id\",\n        col_type=\"INTEGER\",\n        py_type=int,\n        primary=False,\n        not_null=False\n    )\n    bare = BareColumn(col)\n    sql = bare.sql(lambda: 0)\n    assert sql.sql == '\"users\".\"id\"'\n    ```\n    \"\"\"\n\n    col: ColumnBase\n\n    def __init__(self, col: ColumnBase):\n        \"\"\"Create a bare column reference.\"\"\"\n        self.col = col\n\n    @override\n    def sql(self, get_count: GetCount) -&gt; QuerySingle:\n        \"\"\"Generate the SQL fragment (just the column FQN).\"\"\"\n        return QuerySingle(sql=self.col.info.fqn(), params=None)\n</code></pre>"},{"location":"reference/embar/query/order_by/#embar.query.order_by.BareColumn.__init__","title":"<code>__init__(col)</code>","text":"<p>Create a bare column reference.</p> Source code in <code>src/embar/query/order_by.py</code> <pre><code>def __init__(self, col: ColumnBase):\n    \"\"\"Create a bare column reference.\"\"\"\n    self.col = col\n</code></pre>"},{"location":"reference/embar/query/order_by/#embar.query.order_by.BareColumn.sql","title":"<code>sql(get_count)</code>","text":"<p>Generate the SQL fragment (just the column FQN).</p> Source code in <code>src/embar/query/order_by.py</code> <pre><code>@override\ndef sql(self, get_count: GetCount) -&gt; QuerySingle:\n    \"\"\"Generate the SQL fragment (just the column FQN).\"\"\"\n    return QuerySingle(sql=self.col.info.fqn(), params=None)\n</code></pre>"},{"location":"reference/embar/query/order_by/#embar.query.order_by.Desc","title":"<code>Desc</code>","text":"<p>               Bases: <code>ClauseBase</code></p> <p>Represents a descending sort order for a column.</p> <pre><code>from embar.query.order_by import Desc\nfrom embar.column.base import ColumnBase, ColumnInfo\n\ncol = ColumnBase()\ncol.info = ColumnInfo(\n    _table_name=lambda: \"users\",\n    name=\"age\",\n    col_type=\"INTEGER\",\n    py_type=int,\n    primary=False,\n    not_null=False\n)\ndesc = Desc(col, nulls=\"first\")\nsql = desc.sql(lambda: 0)\nassert sql.sql == '\"users\".\"age\" DESC NULLS FIRST'\n</code></pre> Source code in <code>src/embar/query/order_by.py</code> <pre><code>class Desc(ClauseBase):\n    \"\"\"\n    Represents a descending sort order for a column.\n\n    ```python\n    from embar.query.order_by import Desc\n    from embar.column.base import ColumnBase, ColumnInfo\n\n    col = ColumnBase()\n    col.info = ColumnInfo(\n        _table_name=lambda: \"users\",\n        name=\"age\",\n        col_type=\"INTEGER\",\n        py_type=int,\n        primary=False,\n        not_null=False\n    )\n    desc = Desc(col, nulls=\"first\")\n    sql = desc.sql(lambda: 0)\n    assert sql.sql == '\"users\".\"age\" DESC NULLS FIRST'\n    ```\n    \"\"\"\n\n    clause: ColumnBase | ClauseBase\n    nulls: NullsOrdering | None\n\n    def __init__(self, clause: ColumnBase | ClauseBase, nulls: NullsOrdering | None = None):\n        \"\"\"\n        Create a descending sort order.\n\n        Args:\n            col: The column to sort by\n            nulls: Optional nulls ordering (\"first\" or \"last\")\n        \"\"\"\n        self.clause = clause\n        self.nulls = nulls\n\n    @override\n    def sql(self, get_count: GetCount) -&gt; QuerySingle:\n        \"\"\"Generate the SQL fragment.\"\"\"\n        return _asc_or_desc_sql(\n            self.clause,\n            self.nulls,\n            False,\n            get_count,\n        )\n</code></pre>"},{"location":"reference/embar/query/order_by/#embar.query.order_by.Desc.__init__","title":"<code>__init__(clause, nulls=None)</code>","text":"<p>Create a descending sort order.</p> <p>Parameters:</p> Name Type Description Default <code>col</code> <p>The column to sort by</p> required <code>nulls</code> <code>NullsOrdering | None</code> <p>Optional nulls ordering (\"first\" or \"last\")</p> <code>None</code> Source code in <code>src/embar/query/order_by.py</code> <pre><code>def __init__(self, clause: ColumnBase | ClauseBase, nulls: NullsOrdering | None = None):\n    \"\"\"\n    Create a descending sort order.\n\n    Args:\n        col: The column to sort by\n        nulls: Optional nulls ordering (\"first\" or \"last\")\n    \"\"\"\n    self.clause = clause\n    self.nulls = nulls\n</code></pre>"},{"location":"reference/embar/query/order_by/#embar.query.order_by.Desc.sql","title":"<code>sql(get_count)</code>","text":"<p>Generate the SQL fragment.</p> Source code in <code>src/embar/query/order_by.py</code> <pre><code>@override\ndef sql(self, get_count: GetCount) -&gt; QuerySingle:\n    \"\"\"Generate the SQL fragment.\"\"\"\n    return _asc_or_desc_sql(\n        self.clause,\n        self.nulls,\n        False,\n        get_count,\n    )\n</code></pre>"},{"location":"reference/embar/query/order_by/#embar.query.order_by.OrderBy","title":"<code>OrderBy</code>  <code>dataclass</code>","text":"<p>Represents an ORDER BY clause for sorting query results.</p> <pre><code>from embar.query.order_by import OrderBy, Asc, Desc, BareColumn\nfrom embar.column.base import ColumnBase, ColumnInfo\n\ncol1 = ColumnBase()\ncol1.info = ColumnInfo(\n    _table_name=lambda: \"users\",\n    name=\"age\",\n    col_type=\"INTEGER\",\n    py_type=int,\n    primary=False,\n    not_null=False\n)\n\ncol2 = ColumnBase()\ncol2.info = ColumnInfo(\n    _table_name=lambda: \"users\",\n    name=\"name\",\n    col_type=\"TEXT\",\n    py_type=str,\n    primary=False,\n    not_null=False\n)\n\norder = OrderBy((\n    Desc(col1),\n    Asc(col2, nulls=\"first\"),\n))\nsql = order.sql(lambda: 0)\nprint(sql)\nassert sql.sql == '\"users\".\"age\" DESC, \"users\".\"name\" ASC NULLS FIRST'\n</code></pre> Source code in <code>src/embar/query/order_by.py</code> <pre><code>@dataclass\nclass OrderBy:\n    \"\"\"\n    Represents an ORDER BY clause for sorting query results.\n\n    ```python\n    from embar.query.order_by import OrderBy, Asc, Desc, BareColumn\n    from embar.column.base import ColumnBase, ColumnInfo\n\n    col1 = ColumnBase()\n    col1.info = ColumnInfo(\n        _table_name=lambda: \"users\",\n        name=\"age\",\n        col_type=\"INTEGER\",\n        py_type=int,\n        primary=False,\n        not_null=False\n    )\n\n    col2 = ColumnBase()\n    col2.info = ColumnInfo(\n        _table_name=lambda: \"users\",\n        name=\"name\",\n        col_type=\"TEXT\",\n        py_type=str,\n        primary=False,\n        not_null=False\n    )\n\n    order = OrderBy((\n        Desc(col1),\n        Asc(col2, nulls=\"first\"),\n    ))\n    sql = order.sql(lambda: 0)\n    print(sql)\n    assert sql.sql == '\"users\".\"age\" DESC, \"users\".\"name\" ASC NULLS FIRST'\n    ```\n    \"\"\"\n\n    clauses: tuple[ClauseBase, ...]\n\n    def sql(self, get_count: GetCount) -&gt; QuerySingle:\n        \"\"\"\n        Generate the full ORDER BY SQL clause.\n\n        ```python\n        from embar.query.order_by import OrderBy, Asc, BareColumn\n        from embar.column.base import ColumnBase, ColumnInfo\n\n        col1 = ColumnBase()\n        col1.info = ColumnInfo(\n            _table_name=lambda: \"users\",\n            name=\"id\",\n            col_type=\"INTEGER\",\n            py_type=int,\n            primary=False,\n            not_null=False\n        )\n\n        col2 = ColumnBase()\n        col2.info = ColumnInfo(\n            _table_name=lambda: \"users\",\n            name=\"name\",\n            col_type=\"TEXT\",\n            py_type=str,\n            primary=False,\n            not_null=False\n        )\n\n        order = OrderBy((BareColumn(col1), Asc(col2)))\n        sql = order.sql(lambda: 0)\n        assert sql.sql == '\"users\".\"id\", \"users\".\"name\" ASC'\n        ```\n        \"\"\"\n\n        queries = [clause.sql(get_count) for clause in self.clauses]\n        params = {k: v for d in queries for k, v in d.params.items()}\n\n        sql = \", \".join(q.sql for q in queries)\n        return QuerySingle(sql=sql, params=params)\n</code></pre>"},{"location":"reference/embar/query/order_by/#embar.query.order_by.OrderBy.sql","title":"<code>sql(get_count)</code>","text":"<p>Generate the full ORDER BY SQL clause.</p> <pre><code>from embar.query.order_by import OrderBy, Asc, BareColumn\nfrom embar.column.base import ColumnBase, ColumnInfo\n\ncol1 = ColumnBase()\ncol1.info = ColumnInfo(\n    _table_name=lambda: \"users\",\n    name=\"id\",\n    col_type=\"INTEGER\",\n    py_type=int,\n    primary=False,\n    not_null=False\n)\n\ncol2 = ColumnBase()\ncol2.info = ColumnInfo(\n    _table_name=lambda: \"users\",\n    name=\"name\",\n    col_type=\"TEXT\",\n    py_type=str,\n    primary=False,\n    not_null=False\n)\n\norder = OrderBy((BareColumn(col1), Asc(col2)))\nsql = order.sql(lambda: 0)\nassert sql.sql == '\"users\".\"id\", \"users\".\"name\" ASC'\n</code></pre> Source code in <code>src/embar/query/order_by.py</code> <pre><code>def sql(self, get_count: GetCount) -&gt; QuerySingle:\n    \"\"\"\n    Generate the full ORDER BY SQL clause.\n\n    ```python\n    from embar.query.order_by import OrderBy, Asc, BareColumn\n    from embar.column.base import ColumnBase, ColumnInfo\n\n    col1 = ColumnBase()\n    col1.info = ColumnInfo(\n        _table_name=lambda: \"users\",\n        name=\"id\",\n        col_type=\"INTEGER\",\n        py_type=int,\n        primary=False,\n        not_null=False\n    )\n\n    col2 = ColumnBase()\n    col2.info = ColumnInfo(\n        _table_name=lambda: \"users\",\n        name=\"name\",\n        col_type=\"TEXT\",\n        py_type=str,\n        primary=False,\n        not_null=False\n    )\n\n    order = OrderBy((BareColumn(col1), Asc(col2)))\n    sql = order.sql(lambda: 0)\n    assert sql.sql == '\"users\".\"id\", \"users\".\"name\" ASC'\n    ```\n    \"\"\"\n\n    queries = [clause.sql(get_count) for clause in self.clauses]\n    params = {k: v for d in queries for k, v in d.params.items()}\n\n    sql = \", \".join(q.sql for q in queries)\n    return QuerySingle(sql=sql, params=params)\n</code></pre>"},{"location":"reference/embar/query/order_by/#embar.query.order_by.RawSqlOrder","title":"<code>RawSqlOrder</code>","text":"<p>               Bases: <code>ClauseBase</code></p> <p>Represents raw SQL in an ORDER BY clause.</p> <pre><code>from embar.query.order_by import RawSqlOrder\nfrom embar.sql import Sql\nfrom embar.table import Table\nfrom embar.column.common import Integer\n\nclass User(Table):\n    id: Integer = Integer()\n\nraw = RawSqlOrder(Sql(t\"{User.id} DESC\"))\nsql = raw.sql(lambda: 0)\nassert sql.sql == '\"user\".\"id\" DESC'\n</code></pre> Source code in <code>src/embar/query/order_by.py</code> <pre><code>class RawSqlOrder(ClauseBase):\n    \"\"\"\n    Represents raw SQL in an ORDER BY clause.\n\n    ```python\n    from embar.query.order_by import RawSqlOrder\n    from embar.sql import Sql\n    from embar.table import Table\n    from embar.column.common import Integer\n\n    class User(Table):\n        id: Integer = Integer()\n\n    raw = RawSqlOrder(Sql(t\"{User.id} DESC\"))\n    sql = raw.sql(lambda: 0)\n    assert sql.sql == '\"user\".\"id\" DESC'\n    ```\n    \"\"\"\n\n    sql_obj: Sql\n\n    def __init__(self, sql_obj: Sql):\n        \"\"\"Create a raw SQL order clause.\"\"\"\n        self.sql_obj = sql_obj\n\n    @override\n    def sql(self, get_count: GetCount) -&gt; QuerySingle:\n        \"\"\"Generate the SQL fragment.\"\"\"\n        return QuerySingle(sql=self.sql_obj.sql(), params=None)\n</code></pre>"},{"location":"reference/embar/query/order_by/#embar.query.order_by.RawSqlOrder.__init__","title":"<code>__init__(sql_obj)</code>","text":"<p>Create a raw SQL order clause.</p> Source code in <code>src/embar/query/order_by.py</code> <pre><code>def __init__(self, sql_obj: Sql):\n    \"\"\"Create a raw SQL order clause.\"\"\"\n    self.sql_obj = sql_obj\n</code></pre>"},{"location":"reference/embar/query/order_by/#embar.query.order_by.RawSqlOrder.sql","title":"<code>sql(get_count)</code>","text":"<p>Generate the SQL fragment.</p> Source code in <code>src/embar/query/order_by.py</code> <pre><code>@override\ndef sql(self, get_count: GetCount) -&gt; QuerySingle:\n    \"\"\"Generate the SQL fragment.\"\"\"\n    return QuerySingle(sql=self.sql_obj.sql(), params=None)\n</code></pre>"},{"location":"reference/embar/query/query/","title":"query","text":"<p>Query class for SQL queries with parameterized values.</p>"},{"location":"reference/embar/query/query/#embar.query.query.QueryMany","title":"<code>QueryMany</code>","text":"<p>Represents an SQL query with a sequence parameterized values.</p> Source code in <code>src/embar/query/query.py</code> <pre><code>class QueryMany:\n    \"\"\"\n    Represents an SQL query with a sequence parameterized values.\n    \"\"\"\n\n    sql: str\n    many_params: Sequence[dict[str, PyType]]\n\n    def __init__(self, sql: str, many_params: Sequence[dict[str, Any]] | None = None):\n        \"\"\"\n        Create a new QueryMany instance.\n        \"\"\"\n        self.sql = sql\n        self.many_params = many_params if many_params is not None else []\n</code></pre>"},{"location":"reference/embar/query/query/#embar.query.query.QueryMany.__init__","title":"<code>__init__(sql, many_params=None)</code>","text":"<p>Create a new QueryMany instance.</p> Source code in <code>src/embar/query/query.py</code> <pre><code>def __init__(self, sql: str, many_params: Sequence[dict[str, Any]] | None = None):\n    \"\"\"\n    Create a new QueryMany instance.\n    \"\"\"\n    self.sql = sql\n    self.many_params = many_params if many_params is not None else []\n</code></pre>"},{"location":"reference/embar/query/query/#embar.query.query.QuerySingle","title":"<code>QuerySingle</code>","text":"<p>Represents an SQL query with parameterized values.</p> Source code in <code>src/embar/query/query.py</code> <pre><code>class QuerySingle:\n    \"\"\"\n    Represents an SQL query with parameterized values.\n    \"\"\"\n\n    sql: str\n    params: dict[str, PyType]\n\n    def __init__(self, sql: str, params: dict[str, Any] | None = None):\n        \"\"\"\n        Create a new QuerySingle instance.\n        \"\"\"\n        self.sql = sql\n        self.params = params if params is not None else {}\n\n    def merged(self) -&gt; str:\n        \"\"\"\n        Combine query and params into a single string.\n\n        This is used in Constraints where we don't want params as it's desirable to be\n        able to print the DDL to a text file.\n\n        ```python\n        from embar.query.query import QuerySingle\n        query = QuerySingle(\n            sql=\"SELECT * FROM a WHERE id = %(my_var_name)s\",\n            params={\"my_var_name\": 100},\n        )\n        assert query.merged() == \"SELECT * FROM a WHERE id = 100\"\n        ```\n        \"\"\"\n\n        def replace_param(match: re.Match[str]) -&gt; str:\n            param_name = match.group(1)\n            value = self.params[param_name]\n\n            if isinstance(value, str):\n                return f\"'{value}'\"\n            elif value is None:\n                return \"NULL\"\n            else:\n                return str(value)\n\n        return re.sub(r\"%\\((\\w+)\\)s\", replace_param, self.sql)\n</code></pre>"},{"location":"reference/embar/query/query/#embar.query.query.QuerySingle.__init__","title":"<code>__init__(sql, params=None)</code>","text":"<p>Create a new QuerySingle instance.</p> Source code in <code>src/embar/query/query.py</code> <pre><code>def __init__(self, sql: str, params: dict[str, Any] | None = None):\n    \"\"\"\n    Create a new QuerySingle instance.\n    \"\"\"\n    self.sql = sql\n    self.params = params if params is not None else {}\n</code></pre>"},{"location":"reference/embar/query/query/#embar.query.query.QuerySingle.merged","title":"<code>merged()</code>","text":"<p>Combine query and params into a single string.</p> <p>This is used in Constraints where we don't want params as it's desirable to be able to print the DDL to a text file.</p> <pre><code>from embar.query.query import QuerySingle\nquery = QuerySingle(\n    sql=\"SELECT * FROM a WHERE id = %(my_var_name)s\",\n    params={\"my_var_name\": 100},\n)\nassert query.merged() == \"SELECT * FROM a WHERE id = 100\"\n</code></pre> Source code in <code>src/embar/query/query.py</code> <pre><code>def merged(self) -&gt; str:\n    \"\"\"\n    Combine query and params into a single string.\n\n    This is used in Constraints where we don't want params as it's desirable to be\n    able to print the DDL to a text file.\n\n    ```python\n    from embar.query.query import QuerySingle\n    query = QuerySingle(\n        sql=\"SELECT * FROM a WHERE id = %(my_var_name)s\",\n        params={\"my_var_name\": 100},\n    )\n    assert query.merged() == \"SELECT * FROM a WHERE id = 100\"\n    ```\n    \"\"\"\n\n    def replace_param(match: re.Match[str]) -&gt; str:\n        param_name = match.group(1)\n        value = self.params[param_name]\n\n        if isinstance(value, str):\n            return f\"'{value}'\"\n        elif value is None:\n            return \"NULL\"\n        else:\n            return str(value)\n\n    return re.sub(r\"%\\((\\w+)\\)s\", replace_param, self.sql)\n</code></pre>"},{"location":"reference/embar/query/select/","title":"select","text":"<p>Select query builder.</p>"},{"location":"reference/embar/query/select/#embar.query.select.SelectDistinctQuery","title":"<code>SelectDistinctQuery</code>","text":"<p><code>SelectDistinctQuery</code> is returned by Db.select and exposes one method that produced the <code>SelectQueryReady</code>.</p> <p>The only difference is that <code>distinct=True</code> is passed.</p> Source code in <code>src/embar/query/select.py</code> <pre><code>class SelectDistinctQuery[M: BaseModel, Db: AllDbBase]:\n    \"\"\"\n    `SelectDistinctQuery` is returned by Db.select and exposes one method that produced the `SelectQueryReady`.\n\n    The only difference is that `distinct=True` is passed.\n    \"\"\"\n\n    _db: Db\n    model: type[M]\n\n    def __init__(self, model: type[M], db: Db):\n        \"\"\"\n        Create a new SelectQuery instance.\n        \"\"\"\n        self.model = model\n        self._db = db\n\n    @deprecated(\"Use from_ instead\")\n    def fromm[T: Table](self, table: type[T]) -&gt; SelectQueryReady[M, T, Db]:\n        \"\"\"\n        The silly name is because `from` is a reserved keyword.\n        \"\"\"\n        return SelectQueryReady[M, T, Db](model=self.model, table=table, db=self._db, distinct=True)\n\n    def from_[T: Table](self, table: type[T]) -&gt; SelectQueryReady[M, T, Db]:\n        \"\"\"\n        The underscore is because `from` is a reserved keyword.\n        \"\"\"\n        return SelectQueryReady[M, T, Db](model=self.model, table=table, db=self._db, distinct=True)\n</code></pre>"},{"location":"reference/embar/query/select/#embar.query.select.SelectDistinctQuery.__init__","title":"<code>__init__(model, db)</code>","text":"<p>Create a new SelectQuery instance.</p> Source code in <code>src/embar/query/select.py</code> <pre><code>def __init__(self, model: type[M], db: Db):\n    \"\"\"\n    Create a new SelectQuery instance.\n    \"\"\"\n    self.model = model\n    self._db = db\n</code></pre>"},{"location":"reference/embar/query/select/#embar.query.select.SelectDistinctQuery.from_","title":"<code>from_(table)</code>","text":"<p>The underscore is because <code>from</code> is a reserved keyword.</p> Source code in <code>src/embar/query/select.py</code> <pre><code>def from_[T: Table](self, table: type[T]) -&gt; SelectQueryReady[M, T, Db]:\n    \"\"\"\n    The underscore is because `from` is a reserved keyword.\n    \"\"\"\n    return SelectQueryReady[M, T, Db](model=self.model, table=table, db=self._db, distinct=True)\n</code></pre>"},{"location":"reference/embar/query/select/#embar.query.select.SelectDistinctQuery.fromm","title":"<code>fromm(table)</code>","text":"<p>The silly name is because <code>from</code> is a reserved keyword.</p> Source code in <code>src/embar/query/select.py</code> <pre><code>@deprecated(\"Use from_ instead\")\ndef fromm[T: Table](self, table: type[T]) -&gt; SelectQueryReady[M, T, Db]:\n    \"\"\"\n    The silly name is because `from` is a reserved keyword.\n    \"\"\"\n    return SelectQueryReady[M, T, Db](model=self.model, table=table, db=self._db, distinct=True)\n</code></pre>"},{"location":"reference/embar/query/select/#embar.query.select.SelectQuery","title":"<code>SelectQuery</code>","text":"<p><code>SelectQuery</code> is returned by Db.select and exposes one method that produced the <code>SelectQueryReady</code>.</p> Source code in <code>src/embar/query/select.py</code> <pre><code>class SelectQuery[M: BaseModel, Db: AllDbBase]:\n    \"\"\"\n    `SelectQuery` is returned by Db.select and exposes one method that produced the `SelectQueryReady`.\n    \"\"\"\n\n    _db: Db\n    model: type[M]\n\n    def __init__(self, model: type[M], db: Db):\n        \"\"\"\n        Create a new SelectQuery instance.\n        \"\"\"\n        self.model = model\n        self._db = db\n\n    @deprecated(\"Use from_ instead\")\n    def fromm[T: Table](self, table: type[T]) -&gt; SelectQueryReady[M, T, Db]:\n        \"\"\"\n        The silly name is because `from` is a reserved keyword.\n        \"\"\"\n        return SelectQueryReady[M, T, Db](model=self.model, table=table, db=self._db, distinct=False)\n\n    def from_[T: Table](self, table: type[T]) -&gt; SelectQueryReady[M, T, Db]:\n        \"\"\"\n        The underscore is because `from` is a reserved keyword.\n        \"\"\"\n        return SelectQueryReady[M, T, Db](model=self.model, table=table, db=self._db, distinct=False)\n</code></pre>"},{"location":"reference/embar/query/select/#embar.query.select.SelectQuery.__init__","title":"<code>__init__(model, db)</code>","text":"<p>Create a new SelectQuery instance.</p> Source code in <code>src/embar/query/select.py</code> <pre><code>def __init__(self, model: type[M], db: Db):\n    \"\"\"\n    Create a new SelectQuery instance.\n    \"\"\"\n    self.model = model\n    self._db = db\n</code></pre>"},{"location":"reference/embar/query/select/#embar.query.select.SelectQuery.from_","title":"<code>from_(table)</code>","text":"<p>The underscore is because <code>from</code> is a reserved keyword.</p> Source code in <code>src/embar/query/select.py</code> <pre><code>def from_[T: Table](self, table: type[T]) -&gt; SelectQueryReady[M, T, Db]:\n    \"\"\"\n    The underscore is because `from` is a reserved keyword.\n    \"\"\"\n    return SelectQueryReady[M, T, Db](model=self.model, table=table, db=self._db, distinct=False)\n</code></pre>"},{"location":"reference/embar/query/select/#embar.query.select.SelectQuery.fromm","title":"<code>fromm(table)</code>","text":"<p>The silly name is because <code>from</code> is a reserved keyword.</p> Source code in <code>src/embar/query/select.py</code> <pre><code>@deprecated(\"Use from_ instead\")\ndef fromm[T: Table](self, table: type[T]) -&gt; SelectQueryReady[M, T, Db]:\n    \"\"\"\n    The silly name is because `from` is a reserved keyword.\n    \"\"\"\n    return SelectQueryReady[M, T, Db](model=self.model, table=table, db=self._db, distinct=False)\n</code></pre>"},{"location":"reference/embar/query/select/#embar.query.select.SelectQueryReady","title":"<code>SelectQueryReady</code>","text":"<p><code>SelectQueryReady</code> is used to insert data into a table.</p> <p>It is generic over the <code>Model</code> made, <code>Table</code> being inserted into, and the database being used.</p> <p><code>SelectQueryReady</code> is returned by <code>from_</code>.</p> <pre><code>from embar.db.pg import PgDb\nfrom embar.query.select import SelectQueryReady\ndb = PgDb(None)\nselect = db.select(None).from_(None)\nassert isinstance(select, SelectQueryReady)\n</code></pre> Source code in <code>src/embar/query/select.py</code> <pre><code>class SelectQueryReady[M: BaseModel, T: Table, Db: AllDbBase]:\n    \"\"\"\n    `SelectQueryReady` is used to insert data into a table.\n\n    It is generic over the `Model` made, `Table` being inserted into, and the database being used.\n\n    `SelectQueryReady` is returned by [`from_`][embar.query.select.SelectQuery.from_].\n\n    ```python\n    from embar.db.pg import PgDb\n    from embar.query.select import SelectQueryReady\n    db = PgDb(None)\n    select = db.select(None).from_(None)\n    assert isinstance(select, SelectQueryReady)\n    ```\n    \"\"\"\n\n    model: type[M]\n    table: type[T]\n    _db: Db\n\n    _distinct: bool\n    _joins: list[JoinClause]\n    _where_clause: ClauseBase | None = None\n    _group_clause: GroupBy | None = None\n    _having_clause: Having | None = None\n    _order_clause: OrderBy | None = None\n    _limit_value: int | None = None\n    _offset_value: int | None = None\n\n    def __init__(self, model: type[M], table: type[T], db: Db, distinct: bool):\n        \"\"\"\n        Create a new SelectQueryReady instance.\n        \"\"\"\n        self.model = model\n        self.table = table\n        self._db = db\n        self._distinct = distinct\n        self._joins = []\n\n    def left_join(self, table: type[Table], on: ClauseBase) -&gt; Self:\n        \"\"\"\n        Add a LEFT JOIN clause to the query.\n        \"\"\"\n        self._joins.append(LeftJoin(table, on))\n        return self\n\n    def right_join(self, table: type[Table], on: ClauseBase) -&gt; Self:\n        \"\"\"\n        Add a RIGHT JOIN clause to the query.\n        \"\"\"\n        self._joins.append(RightJoin(table, on))\n        return self\n\n    def inner_join(self, table: type[Table], on: ClauseBase) -&gt; Self:\n        \"\"\"\n        Add an INNER JOIN clause to the query.\n        \"\"\"\n        self._joins.append(InnerJoin(table, on))\n        return self\n\n    def full_join(self, table: type[Table], on: ClauseBase) -&gt; Self:\n        \"\"\"\n        Add a FULL OUTER JOIN clause to the query.\n        \"\"\"\n        self._joins.append(FullJoin(table, on))\n        return self\n\n    def cross_join(self, table: type[Table]) -&gt; Self:\n        \"\"\"\n        Add a CROSS JOIN clause to the query.\n        \"\"\"\n        self._joins.append(CrossJoin(table))\n        return self\n\n    def where(self, where_clause: ClauseBase) -&gt; Self:\n        \"\"\"\n        Add a WHERE clause to the query.\n        \"\"\"\n        self._where_clause = where_clause\n        return self\n\n    def group_by(self, *cols: ColumnBase) -&gt; Self:\n        \"\"\"\n        Add a GROUP BY clause to the query.\n        \"\"\"\n        self._group_clause = GroupBy(cols)\n        return self\n\n    def having(self, clause: ClauseBase) -&gt; Self:\n        \"\"\"\n        Add a HAVING clause to filter grouped/aggregated results.\n\n        HAVING clauses work like WHERE clauses but operate on grouped data.\n        They are typically used with GROUP BY to filter groups based on aggregate conditions.\n\n        ```python\n        from embar.db.pg import PgDb\n        from embar.table import Table\n        from embar.column.common import Integer, Text\n        from embar.query.where import Gt\n\n        class User(Table):\n            id: Integer = Integer(primary=True)\n            age: Integer = Integer()\n            name: Text = Text()\n\n        db = PgDb(None)\n\n        # SELECT * FROM users GROUP BY age HAVING COUNT(*) &gt; 5\n        query = db.select(User.all()).from_(User).group_by(User.age).having(Gt(User.age, 18))\n        sql_result = query.sql()\n        assert \"HAVING\" in sql_result.sql\n        ```\n        \"\"\"\n        self._having_clause = Having(clause)\n        return self\n\n    def order_by(self, *clauses: ColumnBase | Asc | Desc | ClauseBase | Sql) -&gt; Self:\n        \"\"\"\n        Add an ORDER BY clause to sort query results.\n\n        Accepts multiple ordering clauses:\n        - Bare column references (defaults to ASC): `User.id`\n        - `Asc(User.id)` or `Asc(User.id, nulls=\"last\")`\n        - `Desc(User.id)` or `Desc(User.id, nulls=\"first\")`\n        - Raw SQL: `Sql(t\"{User.id} DESC\")`\n\n        Can be called multiple times to add more sort columns.\n\n        ```python\n        from embar.db.pg import PgDb\n        from embar.table import Table\n        from embar.column.common import Integer, Text\n        from embar.query.order_by import Asc, Desc\n        from embar.sql import Sql\n\n        class User(Table):\n            id: Integer = Integer(primary=True)\n            age: Integer = Integer()\n            name: Text = Text()\n\n        db = PgDb(None)\n\n        # Multiple ways to specify ORDER BY\n        query = db.select(User.all()).from_(User).order_by(User.age, Desc(User.name))\n        sql_result = query.sql()\n        assert \"ORDER BY\" in sql_result.sql\n\n        # With nulls handling\n        query2 = db.select(User.all()).from_(User).order_by(Asc(User.age, nulls=\"last\"))\n        sql_result2 = query2.sql()\n        assert \"NULLS LAST\" in sql_result2.sql\n\n        # With raw SQL\n        query3 = db.select(User.all()).from_(User).order_by(Sql(t\"{User.id} DESC\"))\n        sql_result3 = query3.sql()\n        assert \"ORDER BY\" in sql_result3.sql\n        ```\n        \"\"\"\n        # Convert each clause to an OrderByClause\n        order_clauses: list[ClauseBase] = []\n        for clause in clauses:\n            if isinstance(clause, (Asc, Desc)):\n                order_clauses.append(clause)\n            elif isinstance(clause, Sql):\n                order_clauses.append(RawSqlOrder(clause))\n            elif isinstance(clause, ClauseBase):\n                order_clauses.append(clause)\n            else:\n                order_clauses.append(BareColumn(clause))\n\n        if self._order_clause is None:\n            self._order_clause = OrderBy(tuple(order_clauses))\n        else:\n            # Add to existing ORDER BY clauses\n            self._order_clause = OrderBy((*self._order_clause.clauses, *order_clauses))\n\n        return self\n\n    def limit(self, n: int) -&gt; Self:\n        \"\"\"\n        Add a LIMIT clause to the query.\n        \"\"\"\n        self._limit_value = n\n        return self\n\n    def offset(self, n: int) -&gt; Self:\n        \"\"\"\n        Add an OFFSET clause to skip a number of rows.\n\n        Typically used with LIMIT for pagination.\n\n        ```python\n        from embar.db.pg import PgDb\n        from embar.table import Table\n        from embar.column.common import Integer, Text\n\n        class User(Table):\n            id: Integer = Integer(primary=True)\n            age: Integer = Integer()\n            name: Text = Text()\n\n        db = PgDb(None)\n\n        # SELECT * FROM users LIMIT 10 OFFSET 20\n        query = db.select(User.all()).from_(User).limit(10).offset(20)\n        sql_result = query.sql()\n        assert \"LIMIT 10\" in sql_result.sql\n        assert \"OFFSET 20\" in sql_result.sql\n        ```\n        \"\"\"\n        self._offset_value = n\n        return self\n\n    @overload\n    def __await__(self: SelectQueryReady[SelectAll, T, Db]) -&gt; Generator[Any, None, Sequence[T]]: ...\n    @overload\n    def __await__(self: SelectQueryReady[M, T, Db]) -&gt; Generator[Any, None, Sequence[M]]: ...\n\n    def __await__(self) -&gt; Generator[Any, None, Sequence[T | M]]:\n        \"\"\"\n        Async users should construct their query and await it.\n\n        Non-async users have the `run()` convenience method below.\n        But this method will still work if called in an async context against a non-async db.\n\n        The overrides provide for a few different cases:\n        - A Model was passed, in which case that's the return type\n        - `SelectAll` was passed, in which case the return type is the `Table`\n        - This is called with an async db, in which case an error is returned.\n        \"\"\"\n        query = self.sql()\n        model = self._get_model()\n        model = cast(type[T] | type[M], model)\n        adapter = TypeAdapter(list[model])\n\n        async def awaitable():\n            db = self._db\n            if isinstance(db, AsyncDbBase):\n                data = await db.fetch(query)\n            else:\n                db = cast(DbBase, self._db)\n                data = db.fetch(query)\n            results = adapter.validate_python(data)\n            return results\n\n        return awaitable().__await__()\n\n    @overload\n    def run(self: SelectQueryReady[SelectAll, T, DbBase]) -&gt; Sequence[T]: ...\n    @overload\n    def run(self: SelectQueryReady[M, T, DbBase]) -&gt; Sequence[M]: ...\n    @overload\n    def run(self: SelectQueryReady[M, T, AsyncDbBase]) -&gt; SelectQueryReady[M, T, Db]: ...\n\n    def run(self) -&gt; Sequence[M | T] | SelectQueryReady[M, T, Db]:\n        \"\"\"\n        Run the query against the underlying DB.\n\n        Convenience method for those not using async.\n        But still works if awaited.\n        \"\"\"\n        if isinstance(self._db, DbBase):\n            query = self.sql()\n            model = self._get_model()\n            model = cast(type[T] | type[M], model)\n            adapter = TypeAdapter(list[model])\n            data = self._db.fetch(query)\n            results = adapter.validate_python(data)\n            return results\n        return self\n\n    def _get_model(self) -&gt; type[BaseModel] | type[M]:\n        \"\"\"\n        Generate the dataclass that will be used to deserialize (and validate) the query results.\n\n        If the model is `SelectAll`, we generate a dataclass based on the `Table`,\n        otherwise the model itself\n        is used.\n\n        Extra processing is done to check for nested children that are Tables themselves.\n        \"\"\"\n        model = generate_model(self.table) if self.model is SelectAll else self.model\n        upgraded = upgrade_model_nested_fields(model)\n        return upgraded\n\n    def sql(self) -&gt; QuerySingle:\n        \"\"\"\n        Combine all the components of the query and build the SQL and bind parameters (psycopg format).\n        \"\"\"\n        data_class = self._get_model()\n\n        columns = to_sql_columns(data_class, self._db.db_type)\n\n        distinct = \"DISTINCT\" if self._distinct else \"\"\n\n        sql = f\"\"\"\n        SELECT {distinct} {columns}\n        FROM {self.table.fqn()}\n        \"\"\"\n        sql = dedent(sql).strip()\n\n        count = -1\n\n        def get_count() -&gt; int:\n            nonlocal count\n            count += 1\n            return count\n\n        params: dict[str, Any] = {}\n\n        for join in self._joins:\n            join_data = join.get(get_count)\n            sql += f\"\\n{join_data.sql}\"\n            params = {**params, **join_data.params}\n\n        if self._where_clause is not None:\n            where_data = self._where_clause.sql(get_count)\n            sql += f\"\\nWHERE {where_data.sql}\"\n            params = {**params, **where_data.params}\n\n        if self._group_clause is not None:\n            col_names = [c.info.fqn() for c in self._group_clause.cols]\n            group_by_col = \", \".join(col_names)\n            sql += f\"\\nGROUP BY {group_by_col}\"\n\n        if self._having_clause is not None:\n            having_data = self._having_clause.clause.sql(get_count)\n            sql += f\"\\nHAVING {having_data.sql}\"\n            params = {**params, **having_data.params}\n\n        if self._order_clause is not None:\n            order_by_query = self._order_clause.sql(get_count)\n            sql += f\"\\nORDER BY {order_by_query.sql}\"\n            params = {**params, **order_by_query.params}\n\n        if self._limit_value is not None:\n            sql += f\"\\nLIMIT {self._limit_value}\"\n\n        if self._offset_value is not None:\n            sql += f\"\\nOFFSET {self._offset_value}\"\n\n        sql = sql.strip()\n\n        return QuerySingle(sql, params=params)\n</code></pre>"},{"location":"reference/embar/query/select/#embar.query.select.SelectQueryReady.__await__","title":"<code>__await__()</code>","text":"<pre><code>__await__() -&gt; Generator[Any, None, Sequence[T]]\n</code></pre><pre><code>__await__() -&gt; Generator[Any, None, Sequence[M]]\n</code></pre> <p>Async users should construct their query and await it.</p> <p>Non-async users have the <code>run()</code> convenience method below. But this method will still work if called in an async context against a non-async db.</p> <p>The overrides provide for a few different cases: - A Model was passed, in which case that's the return type - <code>SelectAll</code> was passed, in which case the return type is the <code>Table</code> - This is called with an async db, in which case an error is returned.</p> Source code in <code>src/embar/query/select.py</code> <pre><code>def __await__(self) -&gt; Generator[Any, None, Sequence[T | M]]:\n    \"\"\"\n    Async users should construct their query and await it.\n\n    Non-async users have the `run()` convenience method below.\n    But this method will still work if called in an async context against a non-async db.\n\n    The overrides provide for a few different cases:\n    - A Model was passed, in which case that's the return type\n    - `SelectAll` was passed, in which case the return type is the `Table`\n    - This is called with an async db, in which case an error is returned.\n    \"\"\"\n    query = self.sql()\n    model = self._get_model()\n    model = cast(type[T] | type[M], model)\n    adapter = TypeAdapter(list[model])\n\n    async def awaitable():\n        db = self._db\n        if isinstance(db, AsyncDbBase):\n            data = await db.fetch(query)\n        else:\n            db = cast(DbBase, self._db)\n            data = db.fetch(query)\n        results = adapter.validate_python(data)\n        return results\n\n    return awaitable().__await__()\n</code></pre>"},{"location":"reference/embar/query/select/#embar.query.select.SelectQueryReady.__init__","title":"<code>__init__(model, table, db, distinct)</code>","text":"<p>Create a new SelectQueryReady instance.</p> Source code in <code>src/embar/query/select.py</code> <pre><code>def __init__(self, model: type[M], table: type[T], db: Db, distinct: bool):\n    \"\"\"\n    Create a new SelectQueryReady instance.\n    \"\"\"\n    self.model = model\n    self.table = table\n    self._db = db\n    self._distinct = distinct\n    self._joins = []\n</code></pre>"},{"location":"reference/embar/query/select/#embar.query.select.SelectQueryReady.cross_join","title":"<code>cross_join(table)</code>","text":"<p>Add a CROSS JOIN clause to the query.</p> Source code in <code>src/embar/query/select.py</code> <pre><code>def cross_join(self, table: type[Table]) -&gt; Self:\n    \"\"\"\n    Add a CROSS JOIN clause to the query.\n    \"\"\"\n    self._joins.append(CrossJoin(table))\n    return self\n</code></pre>"},{"location":"reference/embar/query/select/#embar.query.select.SelectQueryReady.full_join","title":"<code>full_join(table, on)</code>","text":"<p>Add a FULL OUTER JOIN clause to the query.</p> Source code in <code>src/embar/query/select.py</code> <pre><code>def full_join(self, table: type[Table], on: ClauseBase) -&gt; Self:\n    \"\"\"\n    Add a FULL OUTER JOIN clause to the query.\n    \"\"\"\n    self._joins.append(FullJoin(table, on))\n    return self\n</code></pre>"},{"location":"reference/embar/query/select/#embar.query.select.SelectQueryReady.group_by","title":"<code>group_by(*cols)</code>","text":"<p>Add a GROUP BY clause to the query.</p> Source code in <code>src/embar/query/select.py</code> <pre><code>def group_by(self, *cols: ColumnBase) -&gt; Self:\n    \"\"\"\n    Add a GROUP BY clause to the query.\n    \"\"\"\n    self._group_clause = GroupBy(cols)\n    return self\n</code></pre>"},{"location":"reference/embar/query/select/#embar.query.select.SelectQueryReady.having","title":"<code>having(clause)</code>","text":"<p>Add a HAVING clause to filter grouped/aggregated results.</p> <p>HAVING clauses work like WHERE clauses but operate on grouped data. They are typically used with GROUP BY to filter groups based on aggregate conditions.</p> <pre><code>from embar.db.pg import PgDb\nfrom embar.table import Table\nfrom embar.column.common import Integer, Text\nfrom embar.query.where import Gt\n\nclass User(Table):\n    id: Integer = Integer(primary=True)\n    age: Integer = Integer()\n    name: Text = Text()\n\ndb = PgDb(None)\n\n# SELECT * FROM users GROUP BY age HAVING COUNT(*) &gt; 5\nquery = db.select(User.all()).from_(User).group_by(User.age).having(Gt(User.age, 18))\nsql_result = query.sql()\nassert \"HAVING\" in sql_result.sql\n</code></pre> Source code in <code>src/embar/query/select.py</code> <pre><code>def having(self, clause: ClauseBase) -&gt; Self:\n    \"\"\"\n    Add a HAVING clause to filter grouped/aggregated results.\n\n    HAVING clauses work like WHERE clauses but operate on grouped data.\n    They are typically used with GROUP BY to filter groups based on aggregate conditions.\n\n    ```python\n    from embar.db.pg import PgDb\n    from embar.table import Table\n    from embar.column.common import Integer, Text\n    from embar.query.where import Gt\n\n    class User(Table):\n        id: Integer = Integer(primary=True)\n        age: Integer = Integer()\n        name: Text = Text()\n\n    db = PgDb(None)\n\n    # SELECT * FROM users GROUP BY age HAVING COUNT(*) &gt; 5\n    query = db.select(User.all()).from_(User).group_by(User.age).having(Gt(User.age, 18))\n    sql_result = query.sql()\n    assert \"HAVING\" in sql_result.sql\n    ```\n    \"\"\"\n    self._having_clause = Having(clause)\n    return self\n</code></pre>"},{"location":"reference/embar/query/select/#embar.query.select.SelectQueryReady.inner_join","title":"<code>inner_join(table, on)</code>","text":"<p>Add an INNER JOIN clause to the query.</p> Source code in <code>src/embar/query/select.py</code> <pre><code>def inner_join(self, table: type[Table], on: ClauseBase) -&gt; Self:\n    \"\"\"\n    Add an INNER JOIN clause to the query.\n    \"\"\"\n    self._joins.append(InnerJoin(table, on))\n    return self\n</code></pre>"},{"location":"reference/embar/query/select/#embar.query.select.SelectQueryReady.left_join","title":"<code>left_join(table, on)</code>","text":"<p>Add a LEFT JOIN clause to the query.</p> Source code in <code>src/embar/query/select.py</code> <pre><code>def left_join(self, table: type[Table], on: ClauseBase) -&gt; Self:\n    \"\"\"\n    Add a LEFT JOIN clause to the query.\n    \"\"\"\n    self._joins.append(LeftJoin(table, on))\n    return self\n</code></pre>"},{"location":"reference/embar/query/select/#embar.query.select.SelectQueryReady.limit","title":"<code>limit(n)</code>","text":"<p>Add a LIMIT clause to the query.</p> Source code in <code>src/embar/query/select.py</code> <pre><code>def limit(self, n: int) -&gt; Self:\n    \"\"\"\n    Add a LIMIT clause to the query.\n    \"\"\"\n    self._limit_value = n\n    return self\n</code></pre>"},{"location":"reference/embar/query/select/#embar.query.select.SelectQueryReady.offset","title":"<code>offset(n)</code>","text":"<p>Add an OFFSET clause to skip a number of rows.</p> <p>Typically used with LIMIT for pagination.</p> <pre><code>from embar.db.pg import PgDb\nfrom embar.table import Table\nfrom embar.column.common import Integer, Text\n\nclass User(Table):\n    id: Integer = Integer(primary=True)\n    age: Integer = Integer()\n    name: Text = Text()\n\ndb = PgDb(None)\n\n# SELECT * FROM users LIMIT 10 OFFSET 20\nquery = db.select(User.all()).from_(User).limit(10).offset(20)\nsql_result = query.sql()\nassert \"LIMIT 10\" in sql_result.sql\nassert \"OFFSET 20\" in sql_result.sql\n</code></pre> Source code in <code>src/embar/query/select.py</code> <pre><code>def offset(self, n: int) -&gt; Self:\n    \"\"\"\n    Add an OFFSET clause to skip a number of rows.\n\n    Typically used with LIMIT for pagination.\n\n    ```python\n    from embar.db.pg import PgDb\n    from embar.table import Table\n    from embar.column.common import Integer, Text\n\n    class User(Table):\n        id: Integer = Integer(primary=True)\n        age: Integer = Integer()\n        name: Text = Text()\n\n    db = PgDb(None)\n\n    # SELECT * FROM users LIMIT 10 OFFSET 20\n    query = db.select(User.all()).from_(User).limit(10).offset(20)\n    sql_result = query.sql()\n    assert \"LIMIT 10\" in sql_result.sql\n    assert \"OFFSET 20\" in sql_result.sql\n    ```\n    \"\"\"\n    self._offset_value = n\n    return self\n</code></pre>"},{"location":"reference/embar/query/select/#embar.query.select.SelectQueryReady.order_by","title":"<code>order_by(*clauses)</code>","text":"<p>Add an ORDER BY clause to sort query results.</p> <p>Accepts multiple ordering clauses: - Bare column references (defaults to ASC): <code>User.id</code> - <code>Asc(User.id)</code> or <code>Asc(User.id, nulls=\"last\")</code> - <code>Desc(User.id)</code> or <code>Desc(User.id, nulls=\"first\")</code> - Raw SQL: <code>Sql(t\"{User.id} DESC\")</code></p> <p>Can be called multiple times to add more sort columns.</p> <pre><code>from embar.db.pg import PgDb\nfrom embar.table import Table\nfrom embar.column.common import Integer, Text\nfrom embar.query.order_by import Asc, Desc\nfrom embar.sql import Sql\n\nclass User(Table):\n    id: Integer = Integer(primary=True)\n    age: Integer = Integer()\n    name: Text = Text()\n\ndb = PgDb(None)\n\n# Multiple ways to specify ORDER BY\nquery = db.select(User.all()).from_(User).order_by(User.age, Desc(User.name))\nsql_result = query.sql()\nassert \"ORDER BY\" in sql_result.sql\n\n# With nulls handling\nquery2 = db.select(User.all()).from_(User).order_by(Asc(User.age, nulls=\"last\"))\nsql_result2 = query2.sql()\nassert \"NULLS LAST\" in sql_result2.sql\n\n# With raw SQL\nquery3 = db.select(User.all()).from_(User).order_by(Sql(t\"{User.id} DESC\"))\nsql_result3 = query3.sql()\nassert \"ORDER BY\" in sql_result3.sql\n</code></pre> Source code in <code>src/embar/query/select.py</code> <pre><code>def order_by(self, *clauses: ColumnBase | Asc | Desc | ClauseBase | Sql) -&gt; Self:\n    \"\"\"\n    Add an ORDER BY clause to sort query results.\n\n    Accepts multiple ordering clauses:\n    - Bare column references (defaults to ASC): `User.id`\n    - `Asc(User.id)` or `Asc(User.id, nulls=\"last\")`\n    - `Desc(User.id)` or `Desc(User.id, nulls=\"first\")`\n    - Raw SQL: `Sql(t\"{User.id} DESC\")`\n\n    Can be called multiple times to add more sort columns.\n\n    ```python\n    from embar.db.pg import PgDb\n    from embar.table import Table\n    from embar.column.common import Integer, Text\n    from embar.query.order_by import Asc, Desc\n    from embar.sql import Sql\n\n    class User(Table):\n        id: Integer = Integer(primary=True)\n        age: Integer = Integer()\n        name: Text = Text()\n\n    db = PgDb(None)\n\n    # Multiple ways to specify ORDER BY\n    query = db.select(User.all()).from_(User).order_by(User.age, Desc(User.name))\n    sql_result = query.sql()\n    assert \"ORDER BY\" in sql_result.sql\n\n    # With nulls handling\n    query2 = db.select(User.all()).from_(User).order_by(Asc(User.age, nulls=\"last\"))\n    sql_result2 = query2.sql()\n    assert \"NULLS LAST\" in sql_result2.sql\n\n    # With raw SQL\n    query3 = db.select(User.all()).from_(User).order_by(Sql(t\"{User.id} DESC\"))\n    sql_result3 = query3.sql()\n    assert \"ORDER BY\" in sql_result3.sql\n    ```\n    \"\"\"\n    # Convert each clause to an OrderByClause\n    order_clauses: list[ClauseBase] = []\n    for clause in clauses:\n        if isinstance(clause, (Asc, Desc)):\n            order_clauses.append(clause)\n        elif isinstance(clause, Sql):\n            order_clauses.append(RawSqlOrder(clause))\n        elif isinstance(clause, ClauseBase):\n            order_clauses.append(clause)\n        else:\n            order_clauses.append(BareColumn(clause))\n\n    if self._order_clause is None:\n        self._order_clause = OrderBy(tuple(order_clauses))\n    else:\n        # Add to existing ORDER BY clauses\n        self._order_clause = OrderBy((*self._order_clause.clauses, *order_clauses))\n\n    return self\n</code></pre>"},{"location":"reference/embar/query/select/#embar.query.select.SelectQueryReady.right_join","title":"<code>right_join(table, on)</code>","text":"<p>Add a RIGHT JOIN clause to the query.</p> Source code in <code>src/embar/query/select.py</code> <pre><code>def right_join(self, table: type[Table], on: ClauseBase) -&gt; Self:\n    \"\"\"\n    Add a RIGHT JOIN clause to the query.\n    \"\"\"\n    self._joins.append(RightJoin(table, on))\n    return self\n</code></pre>"},{"location":"reference/embar/query/select/#embar.query.select.SelectQueryReady.run","title":"<code>run()</code>","text":"<pre><code>run() -&gt; Sequence[T]\n</code></pre><pre><code>run() -&gt; Sequence[M]\n</code></pre><pre><code>run() -&gt; SelectQueryReady[M, T, Db]\n</code></pre> <p>Run the query against the underlying DB.</p> <p>Convenience method for those not using async. But still works if awaited.</p> Source code in <code>src/embar/query/select.py</code> <pre><code>def run(self) -&gt; Sequence[M | T] | SelectQueryReady[M, T, Db]:\n    \"\"\"\n    Run the query against the underlying DB.\n\n    Convenience method for those not using async.\n    But still works if awaited.\n    \"\"\"\n    if isinstance(self._db, DbBase):\n        query = self.sql()\n        model = self._get_model()\n        model = cast(type[T] | type[M], model)\n        adapter = TypeAdapter(list[model])\n        data = self._db.fetch(query)\n        results = adapter.validate_python(data)\n        return results\n    return self\n</code></pre>"},{"location":"reference/embar/query/select/#embar.query.select.SelectQueryReady.sql","title":"<code>sql()</code>","text":"<p>Combine all the components of the query and build the SQL and bind parameters (psycopg format).</p> Source code in <code>src/embar/query/select.py</code> <pre><code>def sql(self) -&gt; QuerySingle:\n    \"\"\"\n    Combine all the components of the query and build the SQL and bind parameters (psycopg format).\n    \"\"\"\n    data_class = self._get_model()\n\n    columns = to_sql_columns(data_class, self._db.db_type)\n\n    distinct = \"DISTINCT\" if self._distinct else \"\"\n\n    sql = f\"\"\"\n    SELECT {distinct} {columns}\n    FROM {self.table.fqn()}\n    \"\"\"\n    sql = dedent(sql).strip()\n\n    count = -1\n\n    def get_count() -&gt; int:\n        nonlocal count\n        count += 1\n        return count\n\n    params: dict[str, Any] = {}\n\n    for join in self._joins:\n        join_data = join.get(get_count)\n        sql += f\"\\n{join_data.sql}\"\n        params = {**params, **join_data.params}\n\n    if self._where_clause is not None:\n        where_data = self._where_clause.sql(get_count)\n        sql += f\"\\nWHERE {where_data.sql}\"\n        params = {**params, **where_data.params}\n\n    if self._group_clause is not None:\n        col_names = [c.info.fqn() for c in self._group_clause.cols]\n        group_by_col = \", \".join(col_names)\n        sql += f\"\\nGROUP BY {group_by_col}\"\n\n    if self._having_clause is not None:\n        having_data = self._having_clause.clause.sql(get_count)\n        sql += f\"\\nHAVING {having_data.sql}\"\n        params = {**params, **having_data.params}\n\n    if self._order_clause is not None:\n        order_by_query = self._order_clause.sql(get_count)\n        sql += f\"\\nORDER BY {order_by_query.sql}\"\n        params = {**params, **order_by_query.params}\n\n    if self._limit_value is not None:\n        sql += f\"\\nLIMIT {self._limit_value}\"\n\n    if self._offset_value is not None:\n        sql += f\"\\nOFFSET {self._offset_value}\"\n\n    sql = sql.strip()\n\n    return QuerySingle(sql, params=params)\n</code></pre>"},{"location":"reference/embar/query/select/#embar.query.select.SelectQueryReady.where","title":"<code>where(where_clause)</code>","text":"<p>Add a WHERE clause to the query.</p> Source code in <code>src/embar/query/select.py</code> <pre><code>def where(self, where_clause: ClauseBase) -&gt; Self:\n    \"\"\"\n    Add a WHERE clause to the query.\n    \"\"\"\n    self._where_clause = where_clause\n    return self\n</code></pre>"},{"location":"reference/embar/query/update/","title":"update","text":"<p>Update query builder.</p>"},{"location":"reference/embar/query/update/#embar.query.update.UpdateQuery","title":"<code>UpdateQuery</code>","text":"<p><code>UpdateQuery</code> is used to update rows.</p> <p>It is never used directly, but always created from a Db. It returns an <code>UpdateQueryReady</code> instance once <code>set()</code> has been called.</p> <pre><code>from embar.db.pg import PgDb\nfrom embar.query.update import UpdateQuery\ndb = PgDb(None)\nupdate = db.update(None)\nassert isinstance(update, UpdateQuery)\n</code></pre> Source code in <code>src/embar/query/update.py</code> <pre><code>class UpdateQuery[T: Table, Db: AllDbBase]:\n    \"\"\"\n    `UpdateQuery` is used to update rows.\n\n    It is never used directly, but always created from a Db.\n    It returns an `UpdateQueryReady` instance once `set()` has been called.\n\n    ```python\n    from embar.db.pg import PgDb\n    from embar.query.update import UpdateQuery\n    db = PgDb(None)\n    update = db.update(None)\n    assert isinstance(update, UpdateQuery)\n    ```\n    \"\"\"\n\n    table: type[T]\n    _db: Db\n\n    def __init__(self, table: type[T], db: Db):\n        \"\"\"\n        Create a new UpdateQuery instance.\n        \"\"\"\n        self.table = table\n        self._db = db\n\n    def set(self, data: Mapping[str, Any]) -&gt; UpdateQueryReady[T, Db]:\n        \"\"\"\n        Set the values to be updated.\n        \"\"\"\n        return UpdateQueryReady(table=self.table, db=self._db, data=data)\n</code></pre>"},{"location":"reference/embar/query/update/#embar.query.update.UpdateQuery.__init__","title":"<code>__init__(table, db)</code>","text":"<p>Create a new UpdateQuery instance.</p> Source code in <code>src/embar/query/update.py</code> <pre><code>def __init__(self, table: type[T], db: Db):\n    \"\"\"\n    Create a new UpdateQuery instance.\n    \"\"\"\n    self.table = table\n    self._db = db\n</code></pre>"},{"location":"reference/embar/query/update/#embar.query.update.UpdateQuery.set","title":"<code>set(data)</code>","text":"<p>Set the values to be updated.</p> Source code in <code>src/embar/query/update.py</code> <pre><code>def set(self, data: Mapping[str, Any]) -&gt; UpdateQueryReady[T, Db]:\n    \"\"\"\n    Set the values to be updated.\n    \"\"\"\n    return UpdateQueryReady(table=self.table, db=self._db, data=data)\n</code></pre>"},{"location":"reference/embar/query/update/#embar.query.update.UpdateQueryReady","title":"<code>UpdateQueryReady</code>","text":"<p><code>UpdateQueryReady</code> is an update query that is ready to be awaited or run.</p> Source code in <code>src/embar/query/update.py</code> <pre><code>class UpdateQueryReady[T: Table, Db: AllDbBase]:\n    \"\"\"\n    `UpdateQueryReady` is an update query that is ready to be awaited or run.\n    \"\"\"\n\n    table: type[T]\n    _db: Db\n    data: Mapping[str, Any]\n    _where_clause: ClauseBase | None = None\n\n    def __init__(self, table: type[T], db: Db, data: Mapping[str, Any]):\n        \"\"\"\n        Create a new UpdateQueryReady instance.\n        \"\"\"\n        self.table = table\n        self._db = db\n        self.data = data\n\n    def where(self, where_clause: ClauseBase) -&gt; Self:\n        \"\"\"\n        Add a WHERE clause to limit which rows are updated.\n        \"\"\"\n        self._where_clause = where_clause\n        return self\n\n    def returning(self) -&gt; UpdateQueryReturning[T, Db]:\n        return UpdateQueryReturning(self.table, self._db, self.data, self._where_clause)\n\n    def __await__(self):\n        \"\"\"\n        async users should construct their query and await it.\n\n        non-async users have the `run()` convenience method below.\n        \"\"\"\n        query = self.sql()\n\n        async def awaitable():\n            db = self._db\n            if isinstance(db, AsyncDbBase):\n                return await db.execute(query)\n            else:\n                db = cast(DbBase, self._db)\n                return db.execute(query)\n\n        return awaitable().__await__()\n\n    @overload\n    def run(self: UpdateQueryReady[T, DbBase]) -&gt; None: ...\n    @overload\n    def run(self: UpdateQueryReady[T, AsyncDbBase]) -&gt; UpdateQueryReady[T, Db]: ...\n\n    def run(self) -&gt; None | UpdateQueryReady[T, Db]:\n        \"\"\"\n        Run the query against the underlying DB.\n\n        Convenience method for those not using async.\n        But still works if awaited.\n        \"\"\"\n        if isinstance(self._db, DbBase):\n            query = self.sql()\n            return self._db.execute(query)\n        return self\n\n    def sql(self) -&gt; QuerySingle:\n        \"\"\"\n        Combine all the components of the query and build the SQL and bind parameters (psycopg format).\n        \"\"\"\n        count = -1\n\n        def get_count() -&gt; int:\n            nonlocal count\n            count += 1\n            return count\n\n        params: dict[str, Any] = {}\n\n        cols = self.table.column_names()\n\n        setters: list[str] = []\n        for field_name, value in self.data.items():\n            col = cols[field_name]\n            count = get_count()\n            binding_name = f\"set_{field_name}_{count}\"\n            setter = f'\"{col}\" = %({binding_name})s'\n            setters.append(setter)\n            params[binding_name] = value\n\n        set_stmt = \", \".join(setters)\n        sql = f\"UPDATE {self.table.fqn()} SET {set_stmt}\"\n\n        if self._where_clause is not None:\n            where_data = self._where_clause.sql(get_count)\n            sql += f\"\\nWHERE {where_data.sql}\"\n            params = {**params, **where_data.params}\n\n        return QuerySingle(sql, params)\n</code></pre>"},{"location":"reference/embar/query/update/#embar.query.update.UpdateQueryReady.__await__","title":"<code>__await__()</code>","text":"<p>async users should construct their query and await it.</p> <p>non-async users have the <code>run()</code> convenience method below.</p> Source code in <code>src/embar/query/update.py</code> <pre><code>def __await__(self):\n    \"\"\"\n    async users should construct their query and await it.\n\n    non-async users have the `run()` convenience method below.\n    \"\"\"\n    query = self.sql()\n\n    async def awaitable():\n        db = self._db\n        if isinstance(db, AsyncDbBase):\n            return await db.execute(query)\n        else:\n            db = cast(DbBase, self._db)\n            return db.execute(query)\n\n    return awaitable().__await__()\n</code></pre>"},{"location":"reference/embar/query/update/#embar.query.update.UpdateQueryReady.__init__","title":"<code>__init__(table, db, data)</code>","text":"<p>Create a new UpdateQueryReady instance.</p> Source code in <code>src/embar/query/update.py</code> <pre><code>def __init__(self, table: type[T], db: Db, data: Mapping[str, Any]):\n    \"\"\"\n    Create a new UpdateQueryReady instance.\n    \"\"\"\n    self.table = table\n    self._db = db\n    self.data = data\n</code></pre>"},{"location":"reference/embar/query/update/#embar.query.update.UpdateQueryReady.run","title":"<code>run()</code>","text":"<pre><code>run() -&gt; None\n</code></pre><pre><code>run() -&gt; UpdateQueryReady[T, Db]\n</code></pre> <p>Run the query against the underlying DB.</p> <p>Convenience method for those not using async. But still works if awaited.</p> Source code in <code>src/embar/query/update.py</code> <pre><code>def run(self) -&gt; None | UpdateQueryReady[T, Db]:\n    \"\"\"\n    Run the query against the underlying DB.\n\n    Convenience method for those not using async.\n    But still works if awaited.\n    \"\"\"\n    if isinstance(self._db, DbBase):\n        query = self.sql()\n        return self._db.execute(query)\n    return self\n</code></pre>"},{"location":"reference/embar/query/update/#embar.query.update.UpdateQueryReady.sql","title":"<code>sql()</code>","text":"<p>Combine all the components of the query and build the SQL and bind parameters (psycopg format).</p> Source code in <code>src/embar/query/update.py</code> <pre><code>def sql(self) -&gt; QuerySingle:\n    \"\"\"\n    Combine all the components of the query and build the SQL and bind parameters (psycopg format).\n    \"\"\"\n    count = -1\n\n    def get_count() -&gt; int:\n        nonlocal count\n        count += 1\n        return count\n\n    params: dict[str, Any] = {}\n\n    cols = self.table.column_names()\n\n    setters: list[str] = []\n    for field_name, value in self.data.items():\n        col = cols[field_name]\n        count = get_count()\n        binding_name = f\"set_{field_name}_{count}\"\n        setter = f'\"{col}\" = %({binding_name})s'\n        setters.append(setter)\n        params[binding_name] = value\n\n    set_stmt = \", \".join(setters)\n    sql = f\"UPDATE {self.table.fqn()} SET {set_stmt}\"\n\n    if self._where_clause is not None:\n        where_data = self._where_clause.sql(get_count)\n        sql += f\"\\nWHERE {where_data.sql}\"\n        params = {**params, **where_data.params}\n\n    return QuerySingle(sql, params)\n</code></pre>"},{"location":"reference/embar/query/update/#embar.query.update.UpdateQueryReady.where","title":"<code>where(where_clause)</code>","text":"<p>Add a WHERE clause to limit which rows are updated.</p> Source code in <code>src/embar/query/update.py</code> <pre><code>def where(self, where_clause: ClauseBase) -&gt; Self:\n    \"\"\"\n    Add a WHERE clause to limit which rows are updated.\n    \"\"\"\n    self._where_clause = where_clause\n    return self\n</code></pre>"},{"location":"reference/embar/query/update/#embar.query.update.UpdateQueryReturning","title":"<code>UpdateQueryReturning</code>","text":"<p><code>UpdateQueryReturning</code> is an update query that returns all results.</p> Source code in <code>src/embar/query/update.py</code> <pre><code>class UpdateQueryReturning[T: Table, Db: AllDbBase]:\n    \"\"\"\n    `UpdateQueryReturning` is an update query that returns all results.\n    \"\"\"\n\n    table: type[T]\n    _db: Db\n    data: Mapping[str, Any]\n    _where_clause: ClauseBase | None = None\n\n    def __init__(self, table: type[T], db: Db, data: Mapping[str, Any], where_clause: ClauseBase | None):\n        \"\"\"\n        Create a new UpdateQueryReturning instance.\n        \"\"\"\n        self.table = table\n        self._db = db\n        self.data = data\n        self._where_clause = where_clause\n\n    def __await__(self) -&gt; Generator[Any, None, Sequence[T]]:\n        \"\"\"\n        async users should construct their query and await it.\n\n        non-async users have the `run()` convenience method below.\n        \"\"\"\n        query = self.sql()\n        model = self._get_model()\n        model = cast(type[T], model)\n        adapter = TypeAdapter(list[model])\n\n        async def awaitable():\n            db = self._db\n            if isinstance(db, AsyncDbBase):\n                data = await db.fetch(query)\n            else:\n                db = cast(DbBase, self._db)\n                data = db.fetch(query)\n            results = adapter.validate_python(data)\n            return results\n\n        return awaitable().__await__()\n\n    @overload\n    def run(self: UpdateQueryReturning[T, DbBase]) -&gt; list[T]: ...\n    @overload\n    def run(self: UpdateQueryReturning[T, AsyncDbBase]) -&gt; UpdateQueryReturning[T, Db]: ...\n\n    def run(self) -&gt; list[T] | UpdateQueryReturning[T, Db]:\n        \"\"\"\n        Run the query against the underlying DB.\n\n        Convenience method for those not using async.\n        But still works if awaited.\n        \"\"\"\n        if isinstance(self._db, DbBase):\n            query = self.sql()\n            model = self._get_model()\n            model = cast(type[T], model)\n            adapter = TypeAdapter(list[model])\n            data = self._db.fetch(query)\n            results = adapter.validate_python(data)\n            return results\n        return self\n\n    def sql(self) -&gt; QuerySingle:\n        \"\"\"\n        Combine all the components of the query and build the SQL and bind parameters (psycopg format).\n        \"\"\"\n        count = -1\n\n        def get_count() -&gt; int:\n            nonlocal count\n            count += 1\n            return count\n\n        params: dict[str, Any] = {}\n\n        cols = self.table.column_names()\n\n        setters: list[str] = []\n        for field_name, value in self.data.items():\n            col = cols[field_name]\n            count = get_count()\n            binding_name = f\"set_{field_name}_{count}\"\n            setter = f'\"{col}\" = %({binding_name})s'\n            setters.append(setter)\n            params[binding_name] = value\n\n        set_stmt = \", \".join(setters)\n        sql = f\"UPDATE {self.table.fqn()} SET {set_stmt}\"\n\n        if self._where_clause is not None:\n            where_data = self._where_clause.sql(get_count)\n            sql += f\"\\nWHERE {where_data.sql}\"\n            params = {**params, **where_data.params}\n\n        sql += \" RETURNING *\"\n\n        return QuerySingle(sql, params)\n\n    def _get_model(self) -&gt; type[BaseModel]:\n        \"\"\"\n        Generate the dataclass that will be used to deserialize (and validate) the query results.\n        \"\"\"\n        model = generate_model(self.table)\n        return model\n</code></pre>"},{"location":"reference/embar/query/update/#embar.query.update.UpdateQueryReturning.__await__","title":"<code>__await__()</code>","text":"<p>async users should construct their query and await it.</p> <p>non-async users have the <code>run()</code> convenience method below.</p> Source code in <code>src/embar/query/update.py</code> <pre><code>def __await__(self) -&gt; Generator[Any, None, Sequence[T]]:\n    \"\"\"\n    async users should construct their query and await it.\n\n    non-async users have the `run()` convenience method below.\n    \"\"\"\n    query = self.sql()\n    model = self._get_model()\n    model = cast(type[T], model)\n    adapter = TypeAdapter(list[model])\n\n    async def awaitable():\n        db = self._db\n        if isinstance(db, AsyncDbBase):\n            data = await db.fetch(query)\n        else:\n            db = cast(DbBase, self._db)\n            data = db.fetch(query)\n        results = adapter.validate_python(data)\n        return results\n\n    return awaitable().__await__()\n</code></pre>"},{"location":"reference/embar/query/update/#embar.query.update.UpdateQueryReturning.__init__","title":"<code>__init__(table, db, data, where_clause)</code>","text":"<p>Create a new UpdateQueryReturning instance.</p> Source code in <code>src/embar/query/update.py</code> <pre><code>def __init__(self, table: type[T], db: Db, data: Mapping[str, Any], where_clause: ClauseBase | None):\n    \"\"\"\n    Create a new UpdateQueryReturning instance.\n    \"\"\"\n    self.table = table\n    self._db = db\n    self.data = data\n    self._where_clause = where_clause\n</code></pre>"},{"location":"reference/embar/query/update/#embar.query.update.UpdateQueryReturning.run","title":"<code>run()</code>","text":"<pre><code>run() -&gt; list[T]\n</code></pre><pre><code>run() -&gt; UpdateQueryReturning[T, Db]\n</code></pre> <p>Run the query against the underlying DB.</p> <p>Convenience method for those not using async. But still works if awaited.</p> Source code in <code>src/embar/query/update.py</code> <pre><code>def run(self) -&gt; list[T] | UpdateQueryReturning[T, Db]:\n    \"\"\"\n    Run the query against the underlying DB.\n\n    Convenience method for those not using async.\n    But still works if awaited.\n    \"\"\"\n    if isinstance(self._db, DbBase):\n        query = self.sql()\n        model = self._get_model()\n        model = cast(type[T], model)\n        adapter = TypeAdapter(list[model])\n        data = self._db.fetch(query)\n        results = adapter.validate_python(data)\n        return results\n    return self\n</code></pre>"},{"location":"reference/embar/query/update/#embar.query.update.UpdateQueryReturning.sql","title":"<code>sql()</code>","text":"<p>Combine all the components of the query and build the SQL and bind parameters (psycopg format).</p> Source code in <code>src/embar/query/update.py</code> <pre><code>def sql(self) -&gt; QuerySingle:\n    \"\"\"\n    Combine all the components of the query and build the SQL and bind parameters (psycopg format).\n    \"\"\"\n    count = -1\n\n    def get_count() -&gt; int:\n        nonlocal count\n        count += 1\n        return count\n\n    params: dict[str, Any] = {}\n\n    cols = self.table.column_names()\n\n    setters: list[str] = []\n    for field_name, value in self.data.items():\n        col = cols[field_name]\n        count = get_count()\n        binding_name = f\"set_{field_name}_{count}\"\n        setter = f'\"{col}\" = %({binding_name})s'\n        setters.append(setter)\n        params[binding_name] = value\n\n    set_stmt = \", \".join(setters)\n    sql = f\"UPDATE {self.table.fqn()} SET {set_stmt}\"\n\n    if self._where_clause is not None:\n        where_data = self._where_clause.sql(get_count)\n        sql += f\"\\nWHERE {where_data.sql}\"\n        params = {**params, **where_data.params}\n\n    sql += \" RETURNING *\"\n\n    return QuerySingle(sql, params)\n</code></pre>"},{"location":"reference/embar/query/vector/","title":"vector","text":"<p>Code specific to the pgvector extension.</p> <p>The base vector column is still defined in embar.column.pg</p>"},{"location":"reference/embar/query/vector/#embar.query.vector.CosineDistance","title":"<code>CosineDistance</code>","text":"<p>               Bases: <code>ClauseBase</code></p> <p>Get the Cosine Distance using pgvector.</p> <p>Assumes pgvector extension is installed and activated.</p> <p>Creates a query like col_a &lt;=&gt; '[1,2,3]' or col_a &lt;=&gt; col_b.</p> Source code in <code>src/embar/query/vector.py</code> <pre><code>class CosineDistance(ClauseBase):\n    \"\"\"\n    Get the Cosine Distance using pgvector.\n\n    Assumes pgvector extension is installed and activated.\n\n    Creates a query like col_a &lt;=&gt; '[1,2,3]' or col_a &lt;=&gt; col_b.\n    \"\"\"\n\n    left: ColumnInfo\n    right: list[float] | ColumnInfo\n\n    def __init__(self, left: Column[list[float]], right: list[float] | Column[list[float]]):\n        self.left = left.info\n        self.right = right.info if isinstance(right, Column) else right\n\n    @override\n    def sql(self, get_count: GetCount) -&gt; QuerySingle:\n        count = get_count()\n        name = f\"l2distance_{self.left.name}_{count}\"\n        if isinstance(self.right, ColumnInfo):\n            return QuerySingle(sql=f\"{self.left.fqn()} &lt;=&gt; {self.right.fqn()}\")\n\n        # pgvector expects an argument of the form '[1,2,3]'\n        stringified = str(self.right).replace(\" \", \"\")\n\n        return QuerySingle(sql=f\"{self.left.fqn()} &lt;=&gt; %({name})s\", params={name: stringified})\n</code></pre>"},{"location":"reference/embar/query/vector/#embar.query.vector.L2Distance","title":"<code>L2Distance</code>","text":"<p>               Bases: <code>ClauseBase</code></p> <p>Get the L2 Distance using pgvector.</p> <p>Assumes pgvector extension is installed and activated.</p> <p>Creates a query like col_a &lt;-&gt; '[1,2,3]' or col_a &lt;-&gt; col_b.</p> Source code in <code>src/embar/query/vector.py</code> <pre><code>class L2Distance(ClauseBase):\n    \"\"\"\n    Get the L2 Distance using pgvector.\n\n    Assumes pgvector extension is installed and activated.\n\n    Creates a query like col_a &lt;-&gt; '[1,2,3]' or col_a &lt;-&gt; col_b.\n    \"\"\"\n\n    left: ColumnInfo\n    right: list[float] | ColumnInfo\n\n    def __init__(self, left: Column[list[float]], right: list[float] | Column[list[float]]):\n        self.left = left.info\n        self.right = right.info if isinstance(right, Column) else right\n\n    @override\n    def sql(self, get_count: GetCount) -&gt; QuerySingle:\n        count = get_count()\n        name = f\"l2distance_{self.left.name}_{count}\"\n        if isinstance(self.right, ColumnInfo):\n            return QuerySingle(sql=f\"{self.left.fqn()} &lt;-&gt; {self.right.fqn()}\")\n\n        # pgvector expects an argument of the form '[1,2,3]'\n        stringified = str(self.right).replace(\" \", \"\")\n\n        return QuerySingle(sql=f\"{self.left.fqn()} &lt;-&gt; %({name})s\", params={name: stringified})\n</code></pre>"},{"location":"reference/embar/query/where/","title":"where","text":"<p>Where clauses for filtering queries.</p>"},{"location":"reference/embar/query/where/#embar.query.where.And","title":"<code>And</code>","text":"<p>               Bases: <code>ClauseBase</code></p> <p>AND two clauses.</p> Source code in <code>src/embar/query/where.py</code> <pre><code>class And(ClauseBase):\n    \"\"\"\n    AND two clauses.\n    \"\"\"\n\n    left: ClauseBase\n    right: ClauseBase\n\n    def __init__(self, left: ClauseBase, right: ClauseBase):\n        self.left = left\n        self.right = right\n\n    @override\n    def sql(self, get_count: GetCount) -&gt; QuerySingle:\n        left = self.left.sql(get_count)\n        right = self.right.sql(get_count)\n        params = {**left.params, **right.params}\n        sql = f\"{left.sql} AND {right.sql}\"\n        return QuerySingle(sql=sql, params=params)\n</code></pre>"},{"location":"reference/embar/query/where/#embar.query.where.Between","title":"<code>Between</code>","text":"<p>               Bases: <code>ClauseBase</code></p> <p>Checks if a column value is between two values (inclusive).</p> Source code in <code>src/embar/query/where.py</code> <pre><code>class Between[T: PyType](ClauseBase):\n    \"\"\"\n    Checks if a column value is between two values (inclusive).\n    \"\"\"\n\n    column: ColumnInfo\n    lower: PyType\n    upper: PyType\n\n    def __init__(self, column: Column[T], lower: T, upper: T):\n        self.column = column.info\n        self.lower = lower\n        self.upper = upper\n\n    @override\n    def sql(self, get_count: GetCount) -&gt; QuerySingle:\n        count = get_count()\n        lower_name = f\"between_lower_{self.column.name}_{count}\"\n        upper_name = f\"between_upper_{self.column.name}_{count}\"\n        return QuerySingle(\n            sql=f\"{self.column.fqn()} BETWEEN %({lower_name})s AND %({upper_name})s\",\n            params={lower_name: self.lower, upper_name: self.upper},\n        )\n</code></pre>"},{"location":"reference/embar/query/where/#embar.query.where.Eq","title":"<code>Eq</code>","text":"<p>               Bases: <code>ClauseBase</code></p> <p>Checks if a column value is equal to another column or a passed param.</p> <p>Right now the left must always be a column, maybe that must be loosened.</p> Source code in <code>src/embar/query/where.py</code> <pre><code>class Eq[T: PyType](ClauseBase):\n    \"\"\"\n    Checks if a column value is equal to another column or a passed param.\n\n    Right now the left must always be a column, maybe that must be loosened.\n    \"\"\"\n\n    left: ColumnInfo | ClauseBase\n    right: ColumnInfo | PyType\n\n    def __init__(self, left: Column[T] | ClauseBase, right: Column[T] | T):\n        self.left = left.info if isinstance(left, Column) else left\n        self.right = right.info if isinstance(right, Column) else right\n\n    @override\n    def sql(self, get_count: GetCount) -&gt; QuerySingle:\n        return _gen_comparison_sql(self.left, self.right, \"=\", \"eq\", get_count)\n</code></pre>"},{"location":"reference/embar/query/where/#embar.query.where.Exists","title":"<code>Exists</code>","text":"<p>               Bases: <code>ClauseBase</code></p> <p>Check if a subquery result exists.</p> Source code in <code>src/embar/query/where.py</code> <pre><code>class Exists(ClauseBase):\n    \"\"\"\n    Check if a subquery result exists.\n    \"\"\"\n\n    query: SqlAble\n\n    def __init__(self, query: SqlAble):\n        self.query = query\n\n    @override\n    def sql(self, get_count: GetCount) -&gt; QuerySingle:\n        query = self.query.sql()\n        return QuerySingle(f\"EXISTS ({query.sql})\", query.params)\n</code></pre>"},{"location":"reference/embar/query/where/#embar.query.where.Gt","title":"<code>Gt</code>","text":"<p>               Bases: <code>ClauseBase</code></p> <p>Checks if a column value is greater than another column or a passed param.</p> Source code in <code>src/embar/query/where.py</code> <pre><code>class Gt[T: PyType](ClauseBase):\n    \"\"\"\n    Checks if a column value is greater than another column or a passed param.\n    \"\"\"\n\n    left: ColumnInfo | ClauseBase\n    right: ColumnInfo | PyType\n\n    def __init__(self, left: Column[T] | ClauseBase, right: Column[T] | T):\n        self.left = left.info if isinstance(left, Column) else left\n        self.right = right.info if isinstance(right, Column) else right\n\n    @override\n    def sql(self, get_count: GetCount) -&gt; QuerySingle:\n        return _gen_comparison_sql(self.left, self.right, \"&gt;\", \"gt\", get_count)\n</code></pre>"},{"location":"reference/embar/query/where/#embar.query.where.Gte","title":"<code>Gte</code>","text":"<p>               Bases: <code>ClauseBase</code></p> <p>Checks if a column value is greater than or equal to another column or a passed param.</p> Source code in <code>src/embar/query/where.py</code> <pre><code>class Gte[T: PyType](ClauseBase):\n    \"\"\"\n    Checks if a column value is greater than or equal to another column or a passed param.\n    \"\"\"\n\n    left: ColumnInfo | ClauseBase\n    right: ColumnInfo | PyType\n\n    def __init__(self, left: Column[T] | ClauseBase, right: Column[T] | T):\n        self.left = left.info if isinstance(left, Column) else left\n        self.right = right.info if isinstance(right, Column) else right\n\n    @override\n    def sql(self, get_count: GetCount) -&gt; QuerySingle:\n        return _gen_comparison_sql(self.left, self.right, \"&gt;=\", \"gte\", get_count)\n</code></pre>"},{"location":"reference/embar/query/where/#embar.query.where.Ilike","title":"<code>Ilike</code>","text":"<p>               Bases: <code>ClauseBase</code></p> <p>Case-insensitive LIKE pattern matching.</p> Source code in <code>src/embar/query/where.py</code> <pre><code>class Ilike[T: PyType](ClauseBase):\n    \"\"\"\n    Case-insensitive LIKE pattern matching.\n    \"\"\"\n\n    left: ColumnInfo\n    right: PyType | ColumnInfo\n\n    def __init__(self, left: Column[T], right: T | Column[T]):\n        self.left = left.info\n        self.right = right.info if isinstance(right, Column) else right\n\n    @override\n    def sql(self, get_count: GetCount) -&gt; QuerySingle:\n        count = get_count()\n        name = f\"ilike_{self.left.name}_{count}\"\n        if isinstance(self.right, ColumnInfo):\n            return QuerySingle(sql=f\"{self.left.fqn()} ILIKE {self.right.fqn()}\")\n\n        return QuerySingle(sql=f\"{self.left.fqn()} ILIKE %({name})s\", params={name: self.right})\n</code></pre>"},{"location":"reference/embar/query/where/#embar.query.where.InArray","title":"<code>InArray</code>","text":"<p>               Bases: <code>ClauseBase</code></p> <p>Checks if a column value is in a list of values.</p> Source code in <code>src/embar/query/where.py</code> <pre><code>class InArray[T: PyType](ClauseBase):\n    \"\"\"\n    Checks if a column value is in a list of values.\n    \"\"\"\n\n    column: ColumnInfo\n    values: list[PyType]\n\n    def __init__(self, column: Column[T], values: list[T]):\n        self.column = column.info\n        self.values = values\n\n    @override\n    def sql(self, get_count: GetCount) -&gt; QuerySingle:\n        count = get_count()\n        name = f\"in_{self.column.name}_{count}\"\n        return QuerySingle(sql=f\"{self.column.fqn()} = ANY(%({name})s)\", params={name: self.values})\n</code></pre>"},{"location":"reference/embar/query/where/#embar.query.where.IsNotNull","title":"<code>IsNotNull</code>","text":"<p>               Bases: <code>ClauseBase</code></p> <p>Checks if a column value is NOT NULL.</p> Source code in <code>src/embar/query/where.py</code> <pre><code>class IsNotNull(ClauseBase):\n    \"\"\"\n    Checks if a column value is NOT NULL.\n    \"\"\"\n\n    column: ColumnInfo\n\n    def __init__(self, column: Column[Any]):\n        self.column = column.info\n\n    @override\n    def sql(self, get_count: GetCount) -&gt; QuerySingle:\n        return QuerySingle(sql=f\"{self.column.fqn()} IS NOT NULL\")\n</code></pre>"},{"location":"reference/embar/query/where/#embar.query.where.IsNull","title":"<code>IsNull</code>","text":"<p>               Bases: <code>ClauseBase</code></p> <p>Checks if a column value is NULL.</p> Source code in <code>src/embar/query/where.py</code> <pre><code>class IsNull(ClauseBase):\n    \"\"\"\n    Checks if a column value is NULL.\n    \"\"\"\n\n    column: ColumnInfo\n\n    def __init__(self, column: Column[Any]):\n        self.column = column.info\n\n    @override\n    def sql(self, get_count: GetCount) -&gt; QuerySingle:\n        return QuerySingle(sql=f\"{self.column.fqn()} IS NULL\")\n</code></pre>"},{"location":"reference/embar/query/where/#embar.query.where.Lt","title":"<code>Lt</code>","text":"<p>               Bases: <code>ClauseBase</code></p> <p>Checks if a column value is less than another column or a passed param.</p> Source code in <code>src/embar/query/where.py</code> <pre><code>class Lt[T: PyType](ClauseBase):\n    \"\"\"\n    Checks if a column value is less than another column or a passed param.\n    \"\"\"\n\n    left: ColumnInfo | ClauseBase\n    right: ColumnInfo | PyType\n\n    def __init__(self, left: Column[T] | ClauseBase, right: Column[T] | T):\n        self.left = left.info if isinstance(left, Column) else left\n        self.right = right.info if isinstance(right, Column) else right\n\n    @override\n    def sql(self, get_count: GetCount) -&gt; QuerySingle:\n        return _gen_comparison_sql(self.left, self.right, \"&lt;\", \"lt\", get_count)\n</code></pre>"},{"location":"reference/embar/query/where/#embar.query.where.Lte","title":"<code>Lte</code>","text":"<p>               Bases: <code>ClauseBase</code></p> <p>Checks if a column value is less than or equal to another column or a passed param.</p> Source code in <code>src/embar/query/where.py</code> <pre><code>class Lte[T: PyType](ClauseBase):\n    \"\"\"\n    Checks if a column value is less than or equal to another column or a passed param.\n    \"\"\"\n\n    left: ColumnInfo | ClauseBase\n    right: ColumnInfo | PyType\n\n    def __init__(self, left: Column[T] | ClauseBase, right: Column[T] | T):\n        self.left = left.info if isinstance(left, Column) else left\n        self.right = right.info if isinstance(right, Column) else right\n\n    @override\n    def sql(self, get_count: GetCount) -&gt; QuerySingle:\n        return _gen_comparison_sql(self.left, self.right, \"&lt;=\", \"lte\", get_count)\n</code></pre>"},{"location":"reference/embar/query/where/#embar.query.where.Ne","title":"<code>Ne</code>","text":"<p>               Bases: <code>ClauseBase</code></p> <p>Checks if a column value is not equal to another column or a passed param.</p> Source code in <code>src/embar/query/where.py</code> <pre><code>class Ne[T: PyType](ClauseBase):\n    \"\"\"\n    Checks if a column value is not equal to another column or a passed param.\n    \"\"\"\n\n    left: ColumnInfo | ClauseBase\n    right: ColumnInfo | PyType\n\n    def __init__(self, left: Column[T] | ClauseBase, right: Column[T] | T):\n        self.left = left.info if isinstance(left, Column) else left\n        self.right = right.info if isinstance(right, Column) else right\n\n    @override\n    def sql(self, get_count: GetCount) -&gt; QuerySingle:\n        return _gen_comparison_sql(self.left, self.right, \"!=\", \"ne\", get_count)\n</code></pre>"},{"location":"reference/embar/query/where/#embar.query.where.Not","title":"<code>Not</code>","text":"<p>               Bases: <code>ClauseBase</code></p> <p>Negates a where clause.</p> Source code in <code>src/embar/query/where.py</code> <pre><code>class Not(ClauseBase):\n    \"\"\"\n    Negates a where clause.\n    \"\"\"\n\n    clause: ClauseBase\n\n    def __init__(self, clause: ClauseBase):\n        self.clause = clause\n\n    @override\n    def sql(self, get_count: GetCount) -&gt; QuerySingle:\n        inner = self.clause.sql(get_count)\n        return QuerySingle(sql=f\"NOT ({inner.sql})\", params=inner.params)\n</code></pre>"},{"location":"reference/embar/query/where/#embar.query.where.NotBetween","title":"<code>NotBetween</code>","text":"<p>               Bases: <code>ClauseBase</code></p> <p>Checks if a column value is not between two values (inclusive).</p> Source code in <code>src/embar/query/where.py</code> <pre><code>class NotBetween[T: PyType](ClauseBase):\n    \"\"\"\n    Checks if a column value is not between two values (inclusive).\n    \"\"\"\n\n    column: ColumnInfo\n    lower: PyType\n    upper: PyType\n\n    def __init__(self, column: Column[T], lower: T, upper: T):\n        self.column = column.info\n        self.lower = lower\n        self.upper = upper\n\n    @override\n    def sql(self, get_count: GetCount) -&gt; QuerySingle:\n        count = get_count()\n        lower_name = f\"notbetween_lower_{self.column.name}_{count}\"\n        upper_name = f\"notbetween_upper_{self.column.name}_{count}\"\n        return QuerySingle(\n            sql=f\"{self.column.fqn()} NOT BETWEEN %({lower_name})s AND %({upper_name})s\",\n            params={lower_name: self.lower, upper_name: self.upper},\n        )\n</code></pre>"},{"location":"reference/embar/query/where/#embar.query.where.NotExists","title":"<code>NotExists</code>","text":"<p>               Bases: <code>ClauseBase</code></p> <p>Check if a subquery result does not exist.</p> Source code in <code>src/embar/query/where.py</code> <pre><code>class NotExists(ClauseBase):\n    \"\"\"\n    Check if a subquery result does not exist.\n    \"\"\"\n\n    query: SqlAble\n\n    def __init__(self, query: SqlAble):\n        self.query = query\n\n    @override\n    def sql(self, get_count: GetCount) -&gt; QuerySingle:\n        query = self.query.sql()\n        return QuerySingle(f\"NOT EXISTS ({query.sql})\", query.params)\n</code></pre>"},{"location":"reference/embar/query/where/#embar.query.where.NotInArray","title":"<code>NotInArray</code>","text":"<p>               Bases: <code>ClauseBase</code></p> <p>Checks if a column value is not in a list of values.</p> Source code in <code>src/embar/query/where.py</code> <pre><code>class NotInArray[T: PyType](ClauseBase):\n    \"\"\"\n    Checks if a column value is not in a list of values.\n    \"\"\"\n\n    column: ColumnInfo\n    values: list[PyType]\n\n    def __init__(self, column: Column[T], values: list[T]):\n        self.column = column.info\n        self.values = values\n\n    @override\n    def sql(self, get_count: GetCount) -&gt; QuerySingle:\n        count = get_count()\n        name = f\"notin_{self.column.name}_{count}\"\n        return QuerySingle(sql=f\"{self.column.fqn()} != ALL(%({name})s)\", params={name: self.values})\n</code></pre>"},{"location":"reference/embar/query/where/#embar.query.where.NotLike","title":"<code>NotLike</code>","text":"<p>               Bases: <code>ClauseBase</code></p> <p>Negated LIKE pattern matching.</p> Source code in <code>src/embar/query/where.py</code> <pre><code>class NotLike[T: PyType](ClauseBase):\n    \"\"\"\n    Negated LIKE pattern matching.\n    \"\"\"\n\n    left: ColumnInfo\n    right: PyType | ColumnInfo\n\n    def __init__(self, left: Column[T], right: T | Column[T]):\n        self.left = left.info\n        self.right = right.info if isinstance(right, Column) else right\n\n    @override\n    def sql(self, get_count: GetCount) -&gt; QuerySingle:\n        count = get_count()\n        name = f\"notlike_{self.left.name}_{count}\"\n        if isinstance(self.right, ColumnInfo):\n            return QuerySingle(sql=f\"{self.left.fqn()} NOT LIKE {self.right.fqn()}\")\n\n        return QuerySingle(sql=f\"{self.left.fqn()} NOT LIKE %({name})s\", params={name: self.right})\n</code></pre>"},{"location":"reference/embar/query/where/#embar.query.where.Or","title":"<code>Or</code>","text":"<p>               Bases: <code>ClauseBase</code></p> <p>OR two clauses.</p> Source code in <code>src/embar/query/where.py</code> <pre><code>class Or(ClauseBase):\n    \"\"\"\n    OR two clauses.\n    \"\"\"\n\n    left: ClauseBase\n    right: ClauseBase\n\n    def __init__(self, left: ClauseBase, right: ClauseBase):\n        self.left = left\n        self.right = right\n\n    @override\n    def sql(self, get_count: GetCount) -&gt; QuerySingle:\n        left = self.left.sql(get_count)\n        right = self.right.sql(get_count)\n        params = {**left.params, **right.params}\n        sql = f\"{left.sql} OR {right.sql}\"\n        return QuerySingle(sql=sql, params=params)\n</code></pre>"},{"location":"reference/embar/tools/","title":"Index","text":""},{"location":"reference/embar/tools/commands/","title":"commands","text":""},{"location":"reference/embar/tools/commands/#embar.tools.commands.main","title":"<code>main()</code>","text":"<p>Main entry point for the migration tool.</p> Source code in <code>src/embar/tools/commands.py</code> <pre><code>def main():\n    \"\"\"Main entry point for the migration tool.\"\"\"\n    # Load .env file\n    load_env_file()\n\n    # Add current directory to Python path for schema imports\n    if os.getcwd() not in sys.path:\n        sys.path.insert(0, os.getcwd())\n\n    # Parse command line arguments\n    if len(sys.argv) &lt; 2:\n        print(\"Usage: embar &lt;command&gt; [config_path]\")\n        print(\"\")\n        print(\"Commands:\")\n        print(\"  schema      Print the current table schema to stdout\")\n        print(\"  generate    Generate migration and save to file (requires migrations_dir in config)\")\n        print(\"  migrate     Apply migrations from migration files (not yet implemented)\")\n        print(\"  push        Generate and execute migrations with confirmation\")\n        print(\"  pull        Pull schema from database (not yet implemented)\")\n        print(\"\")\n        print(\"Arguments:\")\n        print(\"  config_path    Optional path to config file (default: embar.yml)\")\n        sys.exit(1)\n\n    command = sys.argv[1]\n    config_path = sys.argv[2] if len(sys.argv) &gt; 2 else None\n\n    if command == \"schema\":\n        _cmd_schema(config_path)\n    elif command == \"generate\":\n        _cmd_generate(config_path)\n    elif command == \"migrate\":\n        _cmd_migrate(config_path)\n    elif command == \"push\":\n        _cmd_push(config_path)\n    elif command == \"pull\":\n        _cmd_pull(config_path)\n    else:\n        print(f\"Error: Unknown command '{command}'\")\n        print(\"Valid commands: generate, migrate, push, pull\")\n        sys.exit(1)\n</code></pre>"},{"location":"reference/embar/tools/fmt/","title":"fmt","text":""},{"location":"reference/embar/tools/fmt/#embar.tools.fmt.format_migration_output","title":"<code>format_migration_output(diffs)</code>","text":"<p>Format migration diffs as SQL with metadata comments.</p> Source code in <code>src/embar/tools/fmt.py</code> <pre><code>def format_migration_output(diffs: list[MigrationDiff]) -&gt; str:\n    \"\"\"Format migration diffs as SQL with metadata comments.\"\"\"\n    output: list[str] = []\n    output.append(\"-- Generated Migration SQL\")\n    output.append(\"-- =======================\")\n    output.append(\"\")\n\n    for i, diff in enumerate(diffs, 1):\n        output.append(f\"-- Migration {i}/{len(diffs)}\")\n        output.append(f\"-- Table: {diff.table_name}\")\n        output.append(f\"-- Type: {diff.match_type.upper()}\")\n\n        if diff.old_table_name and diff.new_table_name and diff.old_table_name != diff.new_table_name:\n            output.append(f\"-- Rename: {diff.old_table_name} -&gt; {diff.new_table_name}\")\n\n        compat_status = \"BACKWARD-COMPATIBLE\" if diff.is_backward_compatible else \"\u26a0\ufe0f  NON-BACKWARD-COMPATIBLE\"\n        output.append(f\"-- Compatibility: {compat_status}\")\n        output.append(f\"-- Explanation: {diff.explanation}\")\n        output.append(\"\")\n        output.append(diff.sql)\n        output.append(\"\")\n        output.append(\"\")\n\n    return \"\\n\".join(output)\n</code></pre>"},{"location":"reference/embar/tools/fmt/#embar.tools.fmt.green","title":"<code>green(text)</code>","text":"<p>Return text in green for terminal.</p> Source code in <code>src/embar/tools/fmt.py</code> <pre><code>def green(text: str) -&gt; str:\n    \"\"\"Return text in green for terminal.\"\"\"\n    return f\"\\033[32m{text}\\033[0m\"\n</code></pre>"},{"location":"reference/embar/tools/fmt/#embar.tools.fmt.red_bold","title":"<code>red_bold(text)</code>","text":"<p>Return text in red and bold for terminal.</p> Source code in <code>src/embar/tools/fmt.py</code> <pre><code>def red_bold(text: str) -&gt; str:\n    \"\"\"Return text in red and bold for terminal.\"\"\"\n    return f\"\\033[1;31m{text}\\033[0m\"\n</code></pre>"},{"location":"reference/embar/tools/fmt/#embar.tools.fmt.yellow","title":"<code>yellow(text)</code>","text":"<p>Return text in yellow for terminal.</p> Source code in <code>src/embar/tools/fmt.py</code> <pre><code>def yellow(text: str) -&gt; str:\n    \"\"\"Return text in yellow for terminal.\"\"\"\n    return f\"\\033[33m{text}\\033[0m\"\n</code></pre>"},{"location":"reference/embar/tools/llm/","title":"llm","text":"<p>Wrapper for Anthropic API</p>"},{"location":"reference/embar/tools/llm/#embar.tools.llm.call_anthropic","title":"<code>call_anthropic(api_key, prompt, max_tokens=2000)</code>","text":"<p>Make a request to Anthropic API using urllib.</p> Source code in <code>src/embar/tools/llm.py</code> <pre><code>def call_anthropic(api_key: str, prompt: str, max_tokens: int = 2000) -&gt; str:\n    \"\"\"Make a request to Anthropic API using urllib.\"\"\"\n    url = \"https://api.anthropic.com/v1/messages\"\n\n    data = {\n        \"model\": \"claude-3-5-haiku-20241022\",\n        \"max_tokens\": max_tokens,\n        \"messages\": [{\"role\": \"user\", \"content\": prompt}],\n    }\n\n    headers = {\"Content-Type\": \"application/json\", \"x-api-key\": api_key, \"anthropic-version\": \"2023-06-01\"}\n\n    request = Request(url, data=json.dumps(data).encode(\"utf-8\"), headers=headers, method=\"POST\")\n\n    with urlopen(request) as response:\n        result = json.loads(response.read().decode(\"utf-8\"))\n        return result[\"content\"][0][\"text\"]\n</code></pre>"},{"location":"reference/embar/tools/migrate/","title":"migrate","text":"<p>Migration tool for generating and applying database migrations using LLMs.</p>"},{"location":"reference/embar/tools/migrate/#embar.tools.migrate.apply_migration_file","title":"<code>apply_migration_file(conn, db, migration_name, filepath)</code>","text":"<p>Apply a single migration file.</p> Source code in <code>src/embar/tools/migrate.py</code> <pre><code>def apply_migration_file(conn: psycopg.Connection, db: PgDb, migration_name: str, filepath: str) -&gt; None:\n    \"\"\"Apply a single migration file.\"\"\"\n    # Read the SQL file\n    with open(filepath, \"r\") as f:\n        sql_content = f.read()\n\n    # Extract SQL statements (skip comment lines starting with --)\n    current_statement: list[str] = []\n    for line in sql_content.split(\"\\n\"):\n        stripped = line.strip()\n        # Skip comment lines and empty lines\n        if stripped.startswith(\"--\") or not stripped:\n            continue\n        current_statement.append(line)\n\n    # Join all non-comment lines\n    full_sql = \"\\n\".join(current_statement).strip()\n\n    if not full_sql:\n        print(f\"  {yellow('\u2298 No SQL to execute (comments only)')}\")\n        return\n\n    # Record migration start\n    with conn.cursor() as cur:\n        cur.execute(\n            \"\"\"\n            INSERT INTO _embar_migrations (migration_name, started_at)\n            VALUES (%s, NOW())\n        \"\"\",\n            (migration_name,),\n        )\n    conn.commit()\n\n    try:\n        # Execute the SQL\n        db.execute(QuerySingle(full_sql))\n\n        # Record migration completion\n        with conn.cursor() as cur:\n            cur.execute(\n                \"\"\"\n                UPDATE _embar_migrations\n                SET finished_at = NOW()\n                WHERE migration_name = %s\n            \"\"\",\n                (migration_name,),\n            )\n        conn.commit()\n\n        print(f\"  {green('\u2713 Applied successfully')}\")\n\n    except Exception as e:\n        print(f\"  {red_bold(f'\u2717 Error: {e}')}\")\n        conn.rollback()\n        raise\n</code></pre>"},{"location":"reference/embar/tools/migrate/#embar.tools.migrate.check_migration_state","title":"<code>check_migration_state(conn)</code>","text":"<p>Check if any migrations are in an invalid state (started but not finished).</p> Source code in <code>src/embar/tools/migrate.py</code> <pre><code>def check_migration_state(conn: psycopg.Connection) -&gt; None:\n    \"\"\"Check if any migrations are in an invalid state (started but not finished).\"\"\"\n    with conn.cursor() as cur:\n        cur.execute(\"\"\"\n            SELECT migration_name, started_at\n            FROM _embar_migrations\n            WHERE started_at IS NOT NULL AND finished_at IS NULL\n            ORDER BY started_at\n        \"\"\")\n        incomplete = cur.fetchall()\n\n    if incomplete:\n        print(red_bold(\"Error: Database is in an invalid state!\"))\n        print(\"The following migrations were started but not completed:\")\n        for name, started_at in incomplete:\n            print(f\"  - {name} (started at {started_at})\")\n        print(\"\\nPlease resolve this manually before running new migrations.\")\n        sys.exit(1)\n</code></pre>"},{"location":"reference/embar/tools/migrate/#embar.tools.migrate.ensure_migrations_table","title":"<code>ensure_migrations_table(conn)</code>","text":"<p>Create _embar_migrations table if it doesn't exist.</p> Source code in <code>src/embar/tools/migrate.py</code> <pre><code>def ensure_migrations_table(conn: psycopg.Connection) -&gt; None:\n    \"\"\"Create _embar_migrations table if it doesn't exist.\"\"\"\n    with conn.cursor() as cur:\n        cur.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS _embar_migrations (\n                migration_name TEXT PRIMARY KEY,\n                started_at TIMESTAMP NOT NULL DEFAULT NOW(),\n                finished_at TIMESTAMP\n            )\n        \"\"\")\n    conn.commit()\n</code></pre>"},{"location":"reference/embar/tools/migrate/#embar.tools.migrate.execute_migrations","title":"<code>execute_migrations(diffs, db)</code>","text":"<p>Execute migrations with user confirmation for each one.</p> Source code in <code>src/embar/tools/migrate.py</code> <pre><code>def execute_migrations(diffs: list[MigrationDiff], db: PgDb) -&gt; None:\n    \"\"\"Execute migrations with user confirmation for each one.\"\"\"\n    print(f\"\\n{yellow('EXECUTE MODE ENABLED')}\")\n    print(\"You will be prompted to confirm each migration.\\n\")\n\n    for i, diff in enumerate(diffs, 1):\n        if not _confirm_migration(diff, i, len(diffs)):\n            print(red_bold(\"\\n\u2717 Migration cancelled by user. Exiting.\"))\n            sys.exit(0)\n\n        # Execute the migration\n        print(\"Executing...\")\n        try:\n            db.execute(QuerySingle(diff.sql))\n            print(green(\"\u2713 Migration executed successfully\"))\n        except Exception as e:\n            print(red_bold(f\"\u2717 Error executing migration: {e}\"))\n            sys.exit(1)\n\n    print(f\"\\n{green('\u2713 All migrations executed successfully!')}\")\n</code></pre>"},{"location":"reference/embar/tools/migrate/#embar.tools.migrate.generate_diffs","title":"<code>generate_diffs(config, api_key, llm)</code>","text":"<p>Generate migration diffs from database and schema comparison.</p> Source code in <code>src/embar/tools/migrate.py</code> <pre><code>def generate_diffs(config: MigrateConfig, api_key: str, llm: Llm) -&gt; list[MigrationDiff]:\n    \"\"\"Generate migration diffs from database and schema comparison.\"\"\"\n    print(f\"Connecting to database: {config.db_url}\")\n    print(f\"Loading schema from: {config.schema_path}\")\n    print(\"\")\n\n    conn = psycopg.connect(config.db_url)\n\n    try:\n        diffs = _create_migrations(config, api_key, conn, llm)\n    except Exception as e:\n        print(f\"Error generating migrations: {e}\")\n        import traceback\n\n        traceback.print_exc()\n        sys.exit(1)\n\n    return diffs\n</code></pre>"},{"location":"reference/embar/tools/migrate/#embar.tools.migrate.get_applied_migrations","title":"<code>get_applied_migrations(conn)</code>","text":"<p>Get set of migration names that have been successfully applied.</p> Source code in <code>src/embar/tools/migrate.py</code> <pre><code>def get_applied_migrations(conn: psycopg.Connection) -&gt; set[str]:\n    \"\"\"Get set of migration names that have been successfully applied.\"\"\"\n    with conn.cursor() as cur:\n        cur.execute(\"\"\"\n            SELECT migration_name\n            FROM _embar_migrations\n            WHERE finished_at IS NOT NULL\n            ORDER BY finished_at\n        \"\"\")\n        return {row[0] for row in cur.fetchall()}\n</code></pre>"},{"location":"reference/embar/tools/migrate/#embar.tools.migrate.get_migration_files","title":"<code>get_migration_files(migrations_dir)</code>","text":"<p>Get list of migration files sorted by timestamp. Returns (filename, filepath) tuples.</p> Source code in <code>src/embar/tools/migrate.py</code> <pre><code>def get_migration_files(migrations_dir: str) -&gt; list[tuple[str, str]]:\n    \"\"\"Get list of migration files sorted by timestamp. Returns (filename, filepath) tuples.\"\"\"\n    if not os.path.exists(migrations_dir):\n        return []\n\n    files: list[tuple[str, str]] = []\n    for filename in sorted(os.listdir(migrations_dir)):\n        if filename.endswith(\".sql\"):\n            filepath = os.path.join(migrations_dir, filename)\n            # Extract migration name (remove .sql extension)\n            migration_name = filename[:-4]\n            files.append((migration_name, filepath))\n\n    return files\n</code></pre>"},{"location":"reference/embar/tools/migrate/#embar.tools.migrate.get_schema_from_db","title":"<code>get_schema_from_db(conn)</code>","text":"<p>Extract current database schema as DDL objects.</p> Source code in <code>src/embar/tools/migrate.py</code> <pre><code>def get_schema_from_db(conn: psycopg.Connection) -&gt; list[Ddl]:\n    \"\"\"Extract current database schema as DDL objects.\"\"\"\n    results: list[Ddl] = []\n\n    # Get enums\n    enum_query = \"\"\"\n        SELECT\n            t.typname as enum_name,\n            string_agg(e.enumlabel, ', ' ORDER BY e.enumsortorder) as enum_values\n        FROM pg_type t\n        JOIN pg_enum e ON t.oid = e.enumtypid\n        JOIN pg_namespace n ON t.typnamespace = n.oid\n        WHERE n.nspname = 'public'\n        GROUP BY t.typname\n        ORDER BY t.typname\n    \"\"\"\n\n    with conn.cursor() as cur:\n        cur.execute(enum_query)\n        for enum_name, enum_values in cur.fetchall():\n            ddl = f\"CREATE TYPE {enum_name} AS ENUM ({', '.join(f\"'{v}'\" for v in enum_values.split(', '))});\"\n            results.append(Ddl(name=enum_name, ddl=ddl))\n\n    # Get tables\n    table_query = \"\"\"\n        SELECT tablename\n        FROM pg_tables\n        WHERE schemaname = 'public'\n        ORDER BY tablename\n    \"\"\"\n\n    with conn.cursor() as cur:\n        cur.execute(table_query)\n        tables = [row[0] for row in cur.fetchall()]\n\n    for table in tables:\n        # Get column definitions\n        column_query = \"\"\"\n            SELECT\n                a.attname,\n                pg_catalog.format_type(a.atttypid, a.atttypmod) as data_type,\n                a.attnotnull,\n                pg_get_expr(d.adbin, d.adrelid) as default_value\n            FROM pg_attribute a\n            LEFT JOIN pg_attrdef d ON a.attrelid = d.adrelid AND a.attnum = d.adnum\n            WHERE a.attrelid = %s::regclass\n                AND a.attnum &gt; 0\n                AND NOT a.attisdropped\n            ORDER BY a.attnum\n        \"\"\"\n\n        with conn.cursor() as cur:\n            cur.execute(column_query, (table,))\n            columns = cur.fetchall()\n\n        # Build CREATE TABLE statement\n        col_defs: list[str] = []\n        for col_name, data_type, not_null, default in columns:\n            col_def = f\"    {col_name} {data_type}\"\n            if default:\n                col_def += f\" DEFAULT {default}\"\n            if not_null:\n                col_def += \" NOT NULL\"\n            col_defs.append(col_def)\n\n        ddl = f\"CREATE TABLE {table} (\\n\" + \",\\n\".join(col_defs) + \"\\n);\"\n\n        # Get constraints\n        constraint_query = \"\"\"\n            SELECT conname, pg_get_constraintdef(oid)\n            FROM pg_constraint\n            WHERE conrelid = %s::regclass\n            ORDER BY contype, conname\n        \"\"\"\n\n        constraints: list[str] = []\n        with conn.cursor() as cur:\n            cur.execute(constraint_query, (table,))\n            for con_name, con_def in cur.fetchall():\n                constraints.append(f\"ALTER TABLE {table} ADD CONSTRAINT {con_name} {con_def};\")\n\n        results.append(Ddl(name=table, ddl=ddl, constraints=constraints))\n\n    return results\n</code></pre>"},{"location":"reference/embar/tools/migrate/#embar.tools.migrate.save_migration_to_file","title":"<code>save_migration_to_file(diffs, migrations_dir, migration_name)</code>","text":"<p>Save migrations to a file in the migrations directory.</p> Source code in <code>src/embar/tools/migrate.py</code> <pre><code>def save_migration_to_file(diffs: list[MigrationDiff], migrations_dir: str, migration_name: str) -&gt; str:\n    \"\"\"Save migrations to a file in the migrations directory.\"\"\"\n    # Create migrations directory if it doesn't exist\n    os.makedirs(migrations_dir, exist_ok=True)\n\n    # Generate filename with timestamp\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    filename = f\"{timestamp}_{migration_name}.sql\"\n    filepath = os.path.join(migrations_dir, filename)\n\n    # Write migration to file\n    content = format_migration_output(diffs)\n    with open(filepath, \"w\") as f:\n        f.write(content)\n\n    return filepath\n</code></pre>"},{"location":"reference/embar/tools/models/","title":"models","text":""},{"location":"reference/embar/tools/models/#embar.tools.models.MigrateConfig","title":"<code>MigrateConfig</code>  <code>dataclass</code>","text":"<p>Configuration for the migration tool.</p> Source code in <code>src/embar/tools/models.py</code> <pre><code>@dataclass\nclass MigrateConfig:\n    \"\"\"\n    Configuration for the migration tool.\n    \"\"\"\n\n    dialect: Literal[\"postgresql\"]\n    db_url: str\n    schema_path: str\n    migrations_dir: str | None = None\n</code></pre>"},{"location":"reference/embar/tools/models/#embar.tools.models.MigrationDiff","title":"<code>MigrationDiff</code>  <code>dataclass</code>","text":"<p>Represents a migration diff with compatibility information.</p> Source code in <code>src/embar/tools/models.py</code> <pre><code>@dataclass\nclass MigrationDiff:\n    \"\"\"\n    Represents a migration diff with compatibility information.\n    \"\"\"\n\n    table_name: str\n    old_table_name: str | None\n    new_table_name: str | None\n    match_type: Literal[\"exact\", \"renamed\", \"new\", \"deleted\"]\n    sql: str\n    is_backward_compatible: bool\n    explanation: str\n</code></pre>"},{"location":"reference/embar/tools/models/#embar.tools.models.TableMatch","title":"<code>TableMatch</code>  <code>dataclass</code>","text":"<p>Represents a match between old and new table definitions.</p> Source code in <code>src/embar/tools/models.py</code> <pre><code>@dataclass\nclass TableMatch:\n    \"\"\"\n    Represents a match between old and new table definitions.\n    \"\"\"\n\n    old_name: str | None\n    new_name: str | None\n    old_ddl: Ddl | None\n    new_ddl: Ddl | None\n    match_type: Literal[\"exact\", \"renamed\", \"new\", \"deleted\"]\n    similarity_score: float = 1.0\n</code></pre>"},{"location":"reference/embar/tools/utils/","title":"utils","text":""},{"location":"reference/embar/tools/utils/#embar.tools.utils.get_api_key","title":"<code>get_api_key()</code>","text":"<p>Get API key from environment or prompt user.</p> Source code in <code>src/embar/tools/utils.py</code> <pre><code>def get_api_key() -&gt; str:\n    \"\"\"Get API key from environment or prompt user.\"\"\"\n    api_key = os.environ.get(\"ANTHROPIC_API_KEY\")\n    if not api_key:\n        print(\"ANTHROPIC_API_KEY environment variable not set.\")\n        api_key = input(\"Please enter your Anthropic API key: \").strip()\n        if not api_key:\n            print(\"Error: API key is required.\")\n            sys.exit(1)\n    return api_key\n</code></pre>"},{"location":"reference/embar/tools/utils/#embar.tools.utils.load_config","title":"<code>load_config(config_path=None)</code>","text":"<p>Load and validate configuration from file.</p> Source code in <code>src/embar/tools/utils.py</code> <pre><code>def load_config(config_path: str | None = None) -&gt; MigrateConfig:\n    \"\"\"Load and validate configuration from file.\"\"\"\n    if config_path is None:\n        config_path = \"embar.toml\"\n\n    if not os.path.exists(config_path):\n        print(f\"Error: Config file '{config_path}' not found.\")\n        sys.exit(1)\n\n    with open(config_path, \"rb\") as f:\n        config_data = tomllib.load(f)\n\n    try:\n        return MigrateConfig(**config_data)\n    except TypeError as e:\n        print(f\"Error: Invalid config format: {e}\")\n        sys.exit(1)\n</code></pre>"},{"location":"reference/embar/tools/utils/#embar.tools.utils.load_env_file","title":"<code>load_env_file()</code>","text":"<p>Load environment variables from .env file if it exists.</p> Source code in <code>src/embar/tools/utils.py</code> <pre><code>def load_env_file():\n    \"\"\"Load environment variables from .env file if it exists.\"\"\"\n    # Try current directory first, then parent directory\n    for env_path in [\".env\", \"../.env\"]:\n        if os.path.exists(env_path):\n            with open(env_path, \"r\") as f:\n                for line in f:\n                    line = line.strip()\n                    if line and not line.startswith(\"#\") and \"=\" in line:\n                        key, value = line.split(\"=\", 1)\n                        os.environ[key.strip()] = value.strip()\n            break\n</code></pre>"},{"location":"schemas/basics/","title":"Schema Basics","text":"<p>Schemas in Embar are defined as Python classes that inherit from <code>Table</code>. Each column is defined as a class variable with a type annotation.</p>"},{"location":"schemas/basics/#defining-a-table","title":"Defining a Table","text":"<p>The simplest table definition:</p> <pre><code>from embar.column.common import Integer, Text\nfrom embar.table import Table\n\nclass User(Table):\n    id: Integer = Integer()\n    email: Text = Text()\n</code></pre> <p>This creates a table called <code>user</code> with two columns: <code>id</code> and <code>email</code>.</p>"},{"location":"schemas/basics/#table-naming","title":"Table Naming","text":"<p>By default, Embar generates table names from your class name by converting from PascalCase to snake_case:</p> <pre><code>class UserProfile(Table):\n    id: Integer = Integer()\n\n# Table name will be \"user_profile\"\n</code></pre> <p>You can override this with an explicit table name:</p> <pre><code>from embar.config import EmbarConfig\n\nclass UserProfile(Table):\n    embar_config: EmbarConfig = EmbarConfig(table_name=\"users\")\n\n    id: Integer = Integer()\n</code></pre>"},{"location":"schemas/basics/#column-naming","title":"Column Naming","text":"<p>Like table names, column names are auto-generated from the field name:</p> <pre><code>class User(Table):\n    user_id: Integer = Integer()\n    # Column name will be \"user_id\"\n</code></pre> <p>You can provide an explicit name as the first argument:</p> <pre><code>class User(Table):\n    id: Integer = Integer(\"user_id\")\n    # Field name is \"id\", column name is \"user_id\"\n</code></pre> <p>This is useful when you want shorter field names in Python but more explicit column names in the database.</p>"},{"location":"schemas/basics/#column-types","title":"Column Types","text":"<p>Embar provides several column types. The most common ones are:</p> <ul> <li><code>Integer</code>: Integer values</li> <li><code>Text</code>: Text/string values</li> <li><code>Float</code>: Floating point values</li> </ul> <p>For the full list of available types:</p> <ul> <li>Postgres data types</li> <li>Sqlite data types</li> </ul>"},{"location":"schemas/basics/#basic-column-configuration","title":"Basic Column Configuration","text":"<p>Columns accept several configuration options:</p>"},{"location":"schemas/basics/#primary-keys","title":"Primary Keys","text":"<pre><code>class User(Table):\n    id: Integer = Integer(primary=True)\n</code></pre>"},{"location":"schemas/basics/#not-null","title":"Not Null","text":"<pre><code>class User(Table):\n    email: Text = Text(not_null=True)\n</code></pre>"},{"location":"schemas/basics/#default-values","title":"Default Values","text":"<pre><code>class User(Table):\n    status: Text = Text(default=\"active\")\n</code></pre> <p>When creating a new row, fields with defaults can be omitted:</p> <pre><code>user = User()\n# status will be \"active\"\n</code></pre>"},{"location":"schemas/basics/#combining-options","title":"Combining Options","text":"<pre><code>class User(Table):\n    id: Integer = Integer(primary=True)\n    email: Text = Text(\"user_email\", not_null=True)\n    status: Text = Text(default=\"active\", not_null=True)\n</code></pre>"},{"location":"schemas/basics/#foreign-keys","title":"Foreign Keys","text":"<p>Foreign keys reference columns in other tables:</p> <pre><code>class User(Table):\n    id: Integer = Integer(primary=True)\n\nclass Message(Table):\n    id: Integer = Integer(primary=True)\n    user_id: Integer = Integer().fk(lambda: User.id)\n</code></pre> <p>The lambda is required because <code>User</code> might not be defined yet when <code>Message</code> is being created.</p> <p>You can specify <code>on_delete</code> behavior:</p> <pre><code>class Message(Table):\n    user_id: Integer = Integer().fk(\n        lambda: User.id,\n        on_delete=\"cascade\"\n    )\n</code></pre>"},{"location":"schemas/basics/#a-complete-example","title":"A Complete Example","text":"<pre><code>from embar.column.common import Integer, Text\nfrom embar.config import EmbarConfig\nfrom embar.table import Table\n\nclass User(Table):\n    embar_config: EmbarConfig = EmbarConfig(table_name=\"users\")\n\n    id: Integer = Integer(primary=True)\n    email: Text = Text(\"user_email\", not_null=True)\n    name: Text = Text(default=\"Anonymous\")\n\nclass Message(Table):\n    id: Integer = Integer(primary=True)\n    user_id: Integer = Integer(not_null=True).fk(lambda: User.id)\n    content: Text = Text(not_null=True)\n</code></pre>"},{"location":"schemas/basics/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Relations for working with related data</li> <li>Add Constraints like indexes and unique constraints</li> <li>Explore the full list of Postgres data types or Sqlite data types</li> </ul>"},{"location":"schemas/constraints/","title":"Constraints","text":"<p>Constraints are defined in the table's <code>embar_config</code> and passed as a list. They generate additional SQL statements when you run migrations.</p>"},{"location":"schemas/constraints/#indexes","title":"Indexes","text":"<p>Indexes improve query performance on frequently searched columns. Create them with the <code>Index</code> class:</p> <pre><code>from embar.column.common import Integer, Text\nfrom embar.config import EmbarConfig\nfrom embar.constraint import Index\nfrom embar.table import Table\n\nclass User(Table):\n    embar_config: EmbarConfig = EmbarConfig(\n        constraints=[Index(\"email_idx\").on(lambda: User.email)]\n    )\n\n    id: Integer = Integer(primary=True)\n    email: Text = Text()\n</code></pre> <p>This generates:</p> <pre><code>CREATE INDEX \"email_idx\" ON \"user\"(\"email\");\n</code></pre>"},{"location":"schemas/constraints/#multi-column-indexes","title":"Multi-Column Indexes","text":"<p>Pass multiple columns to <code>on()</code> for composite indexes:</p> <pre><code>class User(Table):\n    embar_config: EmbarConfig = EmbarConfig(\n        constraints=[\n            Index(\"name_email_idx\").on(\n                lambda: User.last_name,\n                lambda: User.first_name\n            )\n        ]\n    )\n\n    id: Integer = Integer(primary=True)\n    first_name: Text = Text()\n    last_name: Text = Text()\n</code></pre> <p>This generates:</p> <pre><code>CREATE INDEX \"name_email_idx\" ON \"user\"(\"last_name\", \"first_name\");\n</code></pre>"},{"location":"schemas/constraints/#partial-indexes","title":"Partial Indexes","text":"<p>Add a <code>where()</code> clause to create a partial index (Postgres and Sqlite):</p> <pre><code>from embar.query.where import Eq\n\nclass User(Table):\n    embar_config: EmbarConfig = EmbarConfig(\n        constraints=[\n            Index(\"active_users_idx\")\n                .on(lambda: User.email)\n                .where(lambda: Eq(User.status, \"active\"))\n        ]\n    )\n\n    id: Integer = Integer(primary=True)\n    email: Text = Text()\n    status: Text = Text()\n</code></pre> <p>This generates:</p> <pre><code>CREATE INDEX \"active_users_idx\" ON \"user\"(\"email\") WHERE \"status\" = :p0;\n</code></pre> <p>Partial indexes are smaller and faster when you only need to index a subset of rows.</p>"},{"location":"schemas/constraints/#unique-constraints","title":"Unique Constraints","text":"<p>Unique constraints ensure no duplicate values exist in a column. Use the <code>UniqueIndex</code> class:</p> <pre><code>from embar.constraint import UniqueIndex\n\nclass User(Table):\n    embar_config: EmbarConfig = EmbarConfig(\n        constraints=[UniqueIndex(\"email_unique\").on(lambda: User.email)]\n    )\n\n    id: Integer = Integer(primary=True)\n    email: Text = Text()\n</code></pre> <p>This generates:</p> <pre><code>CREATE UNIQUE INDEX \"email_unique\" ON \"user\"(\"email\");\n</code></pre>"},{"location":"schemas/constraints/#multi-column-unique-constraints","title":"Multi-Column Unique Constraints","text":"<p>Create unique constraints across multiple columns:</p> <pre><code>class User(Table):\n    embar_config: EmbarConfig = EmbarConfig(\n        constraints=[\n            UniqueIndex(\"org_email_unique\").on(\n                lambda: User.org_id,\n                lambda: User.email\n            )\n        ]\n    )\n\n    id: Integer = Integer(primary=True)\n    org_id: Integer = Integer()\n    email: Text = Text()\n</code></pre> <p>This ensures that each email is unique within an organization, but the same email can exist in different organizations.</p> <p>This generates:</p> <pre><code>CREATE UNIQUE INDEX \"org_email_unique\" ON \"user\"(\"org_id\", \"email\");\n</code></pre>"},{"location":"schemas/constraints/#multiple-constraints","title":"Multiple Constraints","text":"<p>Add multiple constraints to a single table:</p> <pre><code>class Message(Table):\n    embar_config: EmbarConfig = EmbarConfig(\n        constraints=[\n            Index(\"user_idx\").on(lambda: Message.user_id),\n            Index(\"created_idx\").on(lambda: Message.created_at),\n            UniqueIndex(\"content_unique\").on(lambda: Message.content)\n        ]\n    )\n\n    id: Integer = Integer(primary=True)\n    user_id: Integer = Integer()\n    content: Text = Text()\n    created_at: Integer = Integer()\n</code></pre> <p>This generates three separate SQL statements during migration.</p>"},{"location":"schemas/constraints/#applying-constraints","title":"Applying Constraints","text":"<p>Constraints are created when you run migrations:</p> <pre><code>import psycopg\nfrom embar.db.pg import PgDb\n\ndatabase_url = \"postgres://pg:pw@localhost:25432/db\"\nconn = psycopg.Connection.connect(database_url)\ndb = PgDb(conn)\ndb.migrate([User, Message]).run()\n</code></pre> <p>The <code>migrate()</code> method generates both table creation and constraint creation SQL.</p>"},{"location":"schemas/constraints/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Basic schemas for defining tables</li> <li>Explore Relations for foreign keys</li> </ul>"},{"location":"schemas/data-types-pg/","title":"Data Types (Postgres)","text":"<p>Embar provides comprehensive support for PostgreSQL data types. All types are imported from <code>embar.column.pg</code> and <code>embar.column.common</code>.</p>"},{"location":"schemas/data-types-pg/#integer-types","title":"Integer Types","text":""},{"location":"schemas/data-types-pg/#integer","title":"Integer","text":"<p>Standard integer type.</p> <pre><code>from embar.column.common import Integer\nfrom embar.table import Table\n\nclass Product(Table):\n    quantity: Integer = Integer()\n</code></pre> <p>Generates: <pre><code>\"quantity\" INTEGER\n</code></pre></p>"},{"location":"schemas/data-types-pg/#smallint","title":"SmallInt","text":"<p>Small integer type for values from -32768 to 32767.</p> <pre><code>from embar.column.pg import SmallInt\n\nclass Product(Table):\n    stock: SmallInt = SmallInt()\n</code></pre> <p>Generates: <pre><code>\"stock\" SMALLINT\n</code></pre></p>"},{"location":"schemas/data-types-pg/#bigint","title":"BigInt","text":"<p>Large integer type for values beyond the standard integer range.</p> <pre><code>from embar.column.pg import BigInt\n\nclass Analytics(Table):\n    views: BigInt = BigInt()\n</code></pre> <p>Generates: <pre><code>\"views\" BIGINT\n</code></pre></p>"},{"location":"schemas/data-types-pg/#serial-types","title":"Serial Types","text":"<p>Serial types are auto-incrementing integers.</p>"},{"location":"schemas/data-types-pg/#serial","title":"Serial","text":"<p>Auto-incrementing integer.</p> <pre><code>from embar.column.pg import Serial\n\nclass User(Table):\n    id: Serial = Serial(primary=True)\n</code></pre> <p>Generates: <pre><code>\"id\" SERIAL\n</code></pre></p>"},{"location":"schemas/data-types-pg/#smallserial","title":"SmallSerial","text":"<p>Auto-incrementing small integer.</p> <pre><code>from embar.column.pg import SmallSerial\n\nclass Tag(Table):\n    id: SmallSerial = SmallSerial(primary=True)\n</code></pre> <p>Generates: <pre><code>\"id\" SMALLSERIAL\n</code></pre></p>"},{"location":"schemas/data-types-pg/#bigserial","title":"BigSerial","text":"<p>Auto-incrementing big integer.</p> <pre><code>from embar.column.pg import BigSerial\n\nclass Event(Table):\n    id: BigSerial = BigSerial(primary=True)\n</code></pre> <p>Generates: <pre><code>\"id\" BIGSERIAL\n</code></pre></p>"},{"location":"schemas/data-types-pg/#text-types","title":"Text Types","text":""},{"location":"schemas/data-types-pg/#text","title":"Text","text":"<p>Variable-length text with no limit.</p> <pre><code>from embar.column.common import Text\n\nclass Post(Table):\n    content: Text = Text()\n</code></pre> <p>Generates: <pre><code>\"content\" TEXT\n</code></pre></p>"},{"location":"schemas/data-types-pg/#varchar","title":"Varchar","text":"<p>Variable-length text with optional length limit.</p> <pre><code>from embar.column.pg import Varchar\n\nclass User(Table):\n    username: Varchar = Varchar(length=50)\n</code></pre> <p>Generates: <pre><code>\"username\" VARCHAR(50)\n</code></pre></p> <p>Without a length limit:</p> <pre><code>class User(Table):\n    bio: Varchar = Varchar()\n</code></pre> <p>Generates: <pre><code>\"bio\" VARCHAR\n</code></pre></p>"},{"location":"schemas/data-types-pg/#char","title":"Char","text":"<p>Fixed-length character type.</p> <pre><code>from embar.column.pg import Char\n\nclass Country(Table):\n    code: Char = Char(length=2)\n</code></pre> <p>Generates: <pre><code>\"code\" CHAR(2)\n</code></pre></p>"},{"location":"schemas/data-types-pg/#numeric-types","title":"Numeric Types","text":""},{"location":"schemas/data-types-pg/#numeric","title":"Numeric","text":"<p>Arbitrary precision decimal type with configurable precision and scale.</p> <pre><code>from embar.column.pg import Numeric\n\nclass Product(Table):\n    price: Numeric = Numeric(precision=10, scale=2)\n</code></pre> <p>Generates: <pre><code>\"price\" NUMERIC(10, 2)\n</code></pre></p> <p>With precision only:</p> <pre><code>class Product(Table):\n    score: Numeric = Numeric(precision=5)\n</code></pre> <p>Generates: <pre><code>\"score\" NUMERIC(5)\n</code></pre></p>"},{"location":"schemas/data-types-pg/#pgdecimal","title":"PgDecimal","text":"<p>Alias for Numeric (DECIMAL is an alias for NUMERIC in PostgreSQL).</p> <pre><code>from embar.column.pg import PgDecimal\n\nclass Invoice(Table):\n    total: PgDecimal = PgDecimal(precision=12, scale=2)\n</code></pre> <p>Generates: <pre><code>\"total\" DECIMAL(12, 2)\n</code></pre></p>"},{"location":"schemas/data-types-pg/#float","title":"Float","text":"<p>Real floating point type.</p> <pre><code>from embar.column.common import Float\n\nclass Measurement(Table):\n    temperature: Float = Float()\n</code></pre> <p>Generates: <pre><code>\"temperature\" REAL\n</code></pre></p>"},{"location":"schemas/data-types-pg/#doubleprecision","title":"DoublePrecision","text":"<p>Double precision floating point type.</p> <pre><code>from embar.column.pg import DoublePrecision\n\nclass Calculation(Table):\n    result: DoublePrecision = DoublePrecision()\n</code></pre> <p>Generates: <pre><code>\"result\" DOUBLE PRECISION\n</code></pre></p>"},{"location":"schemas/data-types-pg/#boolean","title":"Boolean","text":"<p>Boolean type for true/false values.</p> <pre><code>from embar.column.pg import Boolean\n\nclass User(Table):\n    active: Boolean = Boolean(default=True)\n</code></pre> <p>Generates: <pre><code>\"active\" BOOLEAN\n</code></pre></p>"},{"location":"schemas/data-types-pg/#json-types","title":"JSON Types","text":""},{"location":"schemas/data-types-pg/#json","title":"Json","text":"<p>JSON data stored as text.</p> <pre><code>from embar.column.pg import Json\n\nclass Config(Table):\n    settings: Json = Json()\n</code></pre> <p>Generates: <pre><code>\"settings\" JSON\n</code></pre></p>"},{"location":"schemas/data-types-pg/#jsonb","title":"Jsonb","text":"<p>Binary JSON with indexing support. Recommended over Json for most use cases.</p> <pre><code>import asyncio\n\nfrom embar.db.pg import AsyncPgDb\nfrom embar.column.pg import Jsonb\n\nclass User(Table):\n    metadata: Jsonb = Jsonb()\n\n# Usage\nasync def main():\n    db = AsyncPgDb(...)\n    user = User(metadata={\"theme\": \"dark\", \"language\": \"en\"})\n    await db.insert(User).values(user)\n</code></pre> <p>Generates: <pre><code>\"metadata\" JSONB\n</code></pre></p>"},{"location":"schemas/data-types-pg/#date-and-time-types","title":"Date and Time Types","text":""},{"location":"schemas/data-types-pg/#date","title":"Date","text":"<p>Calendar date (year, month, day).</p> <pre><code>from datetime import date\nfrom embar.column.pg import Date\n\nclass Event(Table):\n    event_date: Date = Date()\n\n# Usage\nevent = Event(event_date=date(2025, 1, 15))\n</code></pre> <p>Generates: <pre><code>\"event_date\" DATE\n</code></pre></p>"},{"location":"schemas/data-types-pg/#time","title":"Time","text":"<p>Time of day without date.</p> <pre><code>from datetime import time\nfrom embar.column.pg import Time\n\nclass Schedule(Table):\n    start_time: Time = Time()\n\n# Usage\nschedule = Schedule(start_time=time(9, 30))\n</code></pre> <p>Generates: <pre><code>\"start_time\" TIME\n</code></pre></p>"},{"location":"schemas/data-types-pg/#timestamp","title":"Timestamp","text":"<p>Date and time without timezone.</p> <pre><code>from datetime import datetime\nfrom embar.column.pg import Timestamp\n\nclass Post(Table):\n    created_at: Timestamp = Timestamp()\n\n# Usage\npost = Post(created_at=datetime.now())\n</code></pre> <p>Generates: <pre><code>\"created_at\" TIMESTAMP\n</code></pre></p>"},{"location":"schemas/data-types-pg/#interval","title":"Interval","text":"<p>Time interval (duration).</p> <pre><code>from datetime import timedelta\nfrom embar.column.pg import Interval\n\nclass Task(Table):\n    duration: Interval = Interval()\n\n# Usage\ntask = Task(duration=timedelta(hours=2, minutes=30))\n</code></pre> <p>Generates: <pre><code>\"duration\" INTERVAL\n</code></pre></p>"},{"location":"schemas/data-types-pg/#enum-types","title":"Enum Types","text":"<p>PostgreSQL enums require defining both the enum type and the column type.</p> <pre><code>from enum import auto\nfrom embar.column.pg import EmbarEnum, EnumCol, PgEnum\n\nclass StatusEnum(EmbarEnum):\n    PENDING = auto()\n    ACTIVE = auto()\n    COMPLETED = auto()\n\nclass StatusPgEnum(PgEnum[StatusEnum]):\n    name: str = \"status_enum\"\n    enum: type[StatusEnum] = StatusEnum\n\nclass Task(Table):\n    status: EnumCol[StatusEnum] = EnumCol(StatusPgEnum)\n\n# Usage\nasync def main():\n    db = AsyncPgDb(...)\n    task = Task(status=\"ACTIVE\")\n    await db.insert(Task).values(task)\n</code></pre> <p>The enum must be included in migrations:</p> <pre><code>async def main():\n    db = AsyncPgDb(...)\n    await db.migrate([Task], enums=[StatusPgEnum])\n</code></pre> <p>Generates: <pre><code>CREATE TYPE status_enum AS ENUM ('PENDING', 'ACTIVE', 'COMPLETED');\n</code></pre></p> <p>And for the column: <pre><code>\"status\" status_enum\n</code></pre></p>"},{"location":"schemas/data-types-pg/#common-column-options","title":"Common Column Options","text":"<p>All column types support these options:</p>"},{"location":"schemas/data-types-pg/#primary-key","title":"Primary Key","text":"<pre><code>class User(Table):\n    id: Integer = Integer(primary=True)\n</code></pre>"},{"location":"schemas/data-types-pg/#not-null","title":"Not Null","text":"<pre><code>class User(Table):\n    email: Text = Text(not_null=True)\n</code></pre>"},{"location":"schemas/data-types-pg/#default-values","title":"Default Values","text":"<pre><code>class User(Table):\n    status: Text = Text(default=\"active\")\n    created_at: Timestamp = Timestamp(default=datetime.now())\n</code></pre>"},{"location":"schemas/data-types-pg/#custom-column-name","title":"Custom Column Name","text":"<pre><code>class User(Table):\n    email: Text = Text(\"user_email\")\n</code></pre>"},{"location":"schemas/data-types-sqlite/","title":"Data Types (SQLite)","text":"<p>Embar provides support for SQLite data types. All types are imported from <code>embar.column.sqlite</code> and <code>embar.column.common</code>.</p> <p>SQLite has a flexible type system. These column types provide the standard SQLite type affinities.</p>"},{"location":"schemas/data-types-sqlite/#integer","title":"Integer","text":"<p>Integer values.</p> <pre><code>from embar.column.common import Integer\nfrom embar.table import Table\n\nclass Product(Table):\n    quantity: Integer = Integer()\n</code></pre> <p>Generates: <pre><code>\"quantity\" INTEGER\n</code></pre></p>"},{"location":"schemas/data-types-sqlite/#text","title":"Text","text":"<p>Variable-length text.</p> <pre><code>from embar.column.common import Text\n\nclass User(Table):\n    email: Text = Text()\n</code></pre> <p>Generates: <pre><code>\"email\" TEXT\n</code></pre></p>"},{"location":"schemas/data-types-sqlite/#float","title":"Float","text":"<p>Floating point values (stored as REAL in SQLite).</p> <pre><code>from embar.column.common import Float\n\nclass Measurement(Table):\n    temperature: Float = Float()\n</code></pre> <p>Generates: <pre><code>\"temperature\" REAL\n</code></pre></p>"},{"location":"schemas/data-types-sqlite/#blob","title":"Blob","text":"<p>Binary data storage.</p> <pre><code>from embar.column.sqlite import Blob\n\nclass Document(Table):\n    file_data: Blob = Blob()\n\n# Usage\ndoc = Document(file_data=b\"binary content here\")\nasync def main():\n    await db.insert(Document).values(doc)\n</code></pre> <p>Generates: <pre><code>\"file_data\" BLOB\n</code></pre></p>"},{"location":"schemas/data-types-sqlite/#common-column-options","title":"Common Column Options","text":"<p>All column types support these options:</p>"},{"location":"schemas/data-types-sqlite/#primary-key","title":"Primary Key","text":"<pre><code>class User(Table):\n    id: Integer = Integer(primary=True)\n</code></pre>"},{"location":"schemas/data-types-sqlite/#not-null","title":"Not Null","text":"<pre><code>class User(Table):\n    email: Text = Text(not_null=True)\n</code></pre>"},{"location":"schemas/data-types-sqlite/#default-values","title":"Default Values","text":"<pre><code>class User(Table):\n    status: Text = Text(default=\"active\")\n</code></pre>"},{"location":"schemas/data-types-sqlite/#custom-column-name","title":"Custom Column Name","text":"<pre><code>class User(Table):\n    email: Text = Text(\"user_email\")\n</code></pre>"},{"location":"schemas/relations/","title":"Relations","text":"<p>Foreign keys define relationships between tables. In Embar, you create foreign keys using the <code>.fk()</code> method on any column type.</p>"},{"location":"schemas/relations/#basic-foreign-key","title":"Basic Foreign Key","text":"<p>Use the <code>.fk()</code> method to reference a column in another table:</p> <pre><code>from embar.column.common import Integer, Text\nfrom embar.table import Table\n\nclass User(Table):\n    id: Integer = Integer(primary=True)\n    email: Text = Text()\n\nclass Message(Table):\n    id: Integer = Integer(primary=True)\n    user_id: Integer = Integer().fk(lambda: User.id)\n    content: Text = Text()\n</code></pre> <p>The lambda syntax (<code>lambda: User.id</code>) is required because <code>User</code> might not be defined yet when Python evaluates the <code>Message</code> class body.</p> <p>This generates:</p> <pre><code>\"user_id\" INTEGER REFERENCES \"user\"(\"id\")\n</code></pre>"},{"location":"schemas/relations/#on-delete-behavior","title":"On Delete Behavior","text":"<p>You can specify what happens when the referenced row is deleted using the <code>on_delete</code> parameter:</p> <pre><code>class Message(Table):\n    id: Integer = Integer(primary=True)\n    user_id: Integer = Integer().fk(\n        lambda: User.id,\n        on_delete=\"cascade\"\n    )\n    content: Text = Text()\n</code></pre>"},{"location":"schemas/relations/#available-options","title":"Available Options","text":"<p>The <code>on_delete</code> parameter accepts these string literals:</p> <ul> <li><code>\"cascade\"</code>: Delete this row when the referenced row is deleted</li> <li><code>\"set null\"</code>: Set this column to NULL when the referenced row is deleted</li> <li><code>\"restrict\"</code>: Prevent deletion of the referenced row if this row exists</li> <li><code>\"no action\"</code>: Same as restrict (default SQL behavior)</li> <li><code>\"set default\"</code>: Set this column to its default value when the referenced row is deleted</li> </ul>"},{"location":"schemas/relations/#cascade-example","title":"Cascade Example","text":"<p>When a user is deleted, all their messages are deleted:</p> <pre><code>class Message(Table):\n    user_id: Integer = Integer().fk(\n        lambda: User.id,\n        on_delete=\"cascade\"\n    )\n</code></pre> <p>Generates:</p> <pre><code>\"user_id\" INTEGER REFERENCES \"user\"(\"id\") ON DELETE cascade\n</code></pre>"},{"location":"schemas/relations/#set-null-example","title":"Set Null Example","text":"<p>When a user is deleted, the foreign key is set to NULL:</p> <pre><code>class Message(Table):\n    user_id: Integer = Integer().fk(\n        lambda: User.id,\n        on_delete=\"set null\"\n    )\n</code></pre> <p>Make sure the column allows NULL values (don't use <code>not_null=True</code>).</p> <p>Generates:</p> <pre><code>\"user_id\" INTEGER REFERENCES \"user\"(\"id\") ON DELETE set null\n</code></pre>"},{"location":"schemas/relations/#multi-level-relations","title":"Multi-Level Relations","text":"<p>You can chain foreign keys across multiple tables:</p> <pre><code>class Organization(Table):\n    id: Integer = Integer(primary=True)\n    name: Text = Text()\n\nclass User(Table):\n    id: Integer = Integer(primary=True)\n    org_id: Integer = Integer().fk(lambda: Organization.id)\n    email: Text = Text()\n\nclass Message(Table):\n    id: Integer = Integer(primary=True)\n    user_id: Integer = Integer().fk(lambda: User.id, on_delete=\"cascade\")\n    content: Text = Text()\n</code></pre>"},{"location":"schemas/relations/#composite-constraints","title":"Composite Constraints","text":"<p>For more complex relationships, combine foreign keys with other column options:</p> <pre><code>class Message(Table):\n    id: Integer = Integer(primary=True)\n    user_id: Integer = Integer(not_null=True).fk(\n        lambda: User.id,\n        on_delete=\"cascade\"\n    )\n    content: Text = Text(not_null=True)\n</code></pre> <p>This ensures every message must have a user, and messages are deleted when their user is deleted.</p>"},{"location":"schemas/relations/#working-with-foreign-keys","title":"Working with Foreign Keys","text":"<p>When querying, use joins to fetch related data:</p> <pre><code>from typing import Annotated\nfrom pydantic import BaseModel\nfrom embar.db.pg import AsyncPgDb\nfrom embar.query.where import Eq\n\nclass UserWithMessages(BaseModel):\n    email: Annotated[str, User.email]\n    messages: Annotated[list[str], Message.content.many()]\n\nasync def main():\n    db = AsyncPgDb(...)\n    users = await (\n        db.select(UserWithMessages)\n        .from_(User)\n        .left_join(Message, Eq(User.id, Message.user_id))\n        .group_by(User.id)\n    )\n</code></pre> <p>For more on querying related data, see Joins.</p>"},{"location":"schemas/relations/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Constraints like indexes and unique constraints</li> <li>Explore Joins for querying related data</li> </ul>"}]}